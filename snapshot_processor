#!/usr/bin/python
import dateutil.parser
import hashlib
import logging
import logging.handlers
import mplayer
import os
import pprint
import pytz
import sys
import time
import umsgpack
import urllib2

from ConfigParser import ConfigParser

from abc import ABCMeta, abstractmethod, abstractproperty
from datetime import datetime, timedelta
from mimetypes import MimeTypes
from mplayer import Player
from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive
from pydrive.files import FileNotUploadedError
from Queue import Queue, Empty
from threading import Thread
from time import sleep
from umsgpack import UnpackException
from urllib import pathname2url, urlencode
from watchdog.events import FileSystemEventHandler
from watchdog.observers import Observer

sys.displayhook = pprint.pprint

APP=os.path.basename(__file__)
DIR=os.path.abspath(os.path.dirname(__file__))
log = logging.getLogger(APP)

TTS_URL = 'http://translate.google.com/translate_tts'

config = ConfigParser()
config.optionxform=str
config.read([os.path.expanduser('~/.{}'.format(APP))])

snapshot_root = config.get('snapshots', 'root_dir')
heartbeat_interval_seconds = int(config.get('snapshots', 'heartbeat_interval_seconds'))
notification_interval_seconds = int(config.get('snapshots', 'notification_interval_seconds'))
snapshot_validity_seconds = int(config.get('snapshots', 'snapshot_validity_seconds'))

# watch-dogged directories
image_snapshots_dir = config.get('image_snapshots', 'dir')
sample_snapshots_dir = config.get('sample_snapshots', 'dir')

snapshot_queue = Queue()
notification_queue = Queue()

class TTSProcessor(Thread):

    def __init__(self):
        super(TTSProcessor, self).__init__()
        self.player = None

    def run(self):
        # black-holding STDOUT causes properties to not work
        self.player = Player(stderr=open('/dev/null', 'w'), autospawn=True)
        while True:
            notification = None
            try:
                notification = notification_queue.get()
            except Exception as e:
                log.error(e)
            else:
                notification_queue.task_done()
            self.say(str(notification))

    def stop(self):
        if self.player:
            self.player.quit()

    def say(self, message):
        msg_checksum = TTSProcessor.checksum(message)
        log.debug("Checksum for \"{}\" is [{}]".format(message, msg_checksum))
        tts_file = "{}.mp3".format(msg_checksum)
        tts_path = os.path.join(DIR, tts_file)
        log.debug("{} exists? {}".format(tts_path, os.path.isfile(tts_path)))
        if not os.path.isfile(tts_path):
            values = {'tl': 'en', 'q': message}
            data = urlencode(values)
            request = urllib2.Request(TTS_URL, data)
            request.add_header('User-agent', 'Mozilla/5.0')
            opener = urllib2.build_opener()
            log.debug("Fetching \"{}\" from {}".format(message, TTS_URL))
            f = open(tts_path, "wb")
            f.write(opener.open(request).read())
            f.close()
            log.debug("Written {} bytes to {}".format(os.path.getsize(tts_path), tts_path))
        # now play
        self.player.loadfile(tts_path)
        delay = int(self.player.length)
        # block for the duration of this audio sample
        log.debug("Saying \"{}\" for {}s".format(message, delay))
        sleep(delay)

    @staticmethod
    def checksum(message):
        m = hashlib.md5()
        m.update(message)
        return m.hexdigest()


class Snapshot(object):
    __metaclass__ = ABCMeta

    def __init__(self, file_path, validity_seconds):
        self.file_path = file_path
        self.validity_seconds = validity_seconds

    @abstractproperty
    def timestamp(self):
        return NotImplemented

    @abstractproperty
    def is_expired(self):
        return NotImplemented

    @abstractproperty
    def data(self):
        return NotImplemented

    @abstractproperty
    def devices(self):
        return NotImplemented


class SampledSnapshot(Snapshot):

    def __init__(self, file_path, validity_seconds):
        super(SampledSnapshot, self).__init__(file_path=file_path, validity_seconds=validity_seconds)
        f = open(file_path)
        self.snapshot_data = umsgpack.unpack(f)
        self.timestamp_data = dateutil.parser.parse(self.snapshot_data['timestamp'])
        if 'data' in self.snapshot_data:
            self.devices_data = self.snapshot_data['data']
        else:
            self.devices_data = None

    @property
    def timestamp(self):
        return self.timestamp_data

    @property
    def is_expired(self):
        now = datetime.utcnow().replace(tzinfo=pytz.utc)
        return now - self.timestamp_data > timedelta(seconds=self.validity_seconds)

    @property
    def data(self):
        return self.snapshot_data

    @property
    def devices(self):
        if self.devices_data is None:
            return {}
        return self.devices_data

    def __str__(self):
        string = "{}".format(self.timestamp.strftime('%X %x %Z'))
        if self.devices:
            return string + ": {} devices: {}".format(len(self.devices), ','.join(self.devices.keys()))
        return string


class UploadEventHandler(FileSystemEventHandler):

    def __init__(self, gauth_creds_file, gdrive_folder):
        super(UploadEventHandler, self).__init__()
        self.last_modified = None
        self._gdrive_folder = gdrive_folder
        if '~' in gauth_creds_file:
            self._gauth_creds_file = os.path.expanduser(gauth_creds_file)
        else:
            self._gauth_creds_file = os.path.abspath(gauth_creds_file)
        self._gauth = None
        self.drive = GoogleDrive(self.gauth)
        self._gdrive_folder_id = self._get_gdrive_folder_id(self.drive, gdrive_folder)
        log.debug("Monitoring directories in {} for changes: {}".format(snapshot_root, str([sample_snapshots_dir, image_snapshots_dir])))
        self.mime = MimeTypes()

    @property
    def gauth(self):
        if self._gauth is None:
            self._gauth = GoogleAuth()
        if not os.path.exists(self._gauth_creds_file):
            log.debug("Google credentials not found in [{}]. Interactive setup may follow.".format(self._gauth_creds_file))
        # Try to load saved client credentials
        self._gauth.LoadCredentialsFile(self._gauth_creds_file)
        if self._gauth.credentials is None:
            # Authenticate if they're not there
            self._gauth.LocalWebserverAuth()
        elif self._gauth.access_token_expired:
            # Refresh them if expired
            self._gauth.Refresh()
        else:
            # Initialize the saved creds
            self._gauth.Authorize()
        if not os.path.exists(self._gauth_creds_file):
            # Save the current credentials to a file
            self._gauth.SaveCredentialsFile(self._gauth_creds_file)
            log.debug("Saved Google credentials to {}".format(self._gauth_creds_file))
        return self._gauth

    @staticmethod
    def _get_gdrive_folder_id(gdrive, gdrive_folder):
        log.debug("Checking for existence of Google Drive folder '{}'".format(gdrive_folder))
        file_list = gdrive.ListFile({
            'q': "'root' in parents and trashed=false and mimeType = 'application/vnd.google-apps.folder'"
            " and title = '{}'".format(gdrive_folder)
        }).GetList()
        if len(file_list) == 0:
            log.debug("Creating Google Drive folder '{}'".format(gdrive_folder))
            folder = gdrive.CreateFile({
                'description': "Created by {}".format(APP), 'title':gdrive_folder, 'mimeType':'application/vnd.google-apps.folder'})
            folder.Upload()
            folder_id = folder['id']
        elif len(file_list) == 1:
            folder_id = file_list[0]['id']
        else:
            raise RuntimeError("Unexpected result listing Google Drive for {}: {}".format(gdrive_folder, str(file_list)))
        log.debug("Google Drive folder ID for folder '{}' is '{}'".format(gdrive_folder, folder_id))
        return folder_id

    # we listen to on-modified events because the file is
    # created and then written to subsequently.
    def on_modified(self, event):
        super(UploadEventHandler, self).on_modified(event)
        what = 'directory' if event.is_directory else 'file'
        # the file has been written to and has valid content
        if not event.is_directory:
            snapshot_path = event.src_path
            # de-duplication
            if snapshot_path != self.last_modified:
                self.last_modified = snapshot_path
            else:
                return
            # cross-check that we're in the right place
            if snapshot_path.startswith(snapshot_root):
                try:
                    if sample_snapshots_dir in snapshot_path:
                        try:
                            snapshot = SampledSnapshot(file_path=snapshot_path, validity_seconds=snapshot_validity_seconds)
                            log.info("Snapshot: {} from {}".format(snapshot, snapshot_path))
                            snapshot_queue.put(snapshot)
                            last_snapshot_path = snapshot_path
                        except UnpackException:
                            log.exception("Cannot unpack snapshot data in {}".format(snapshot_path))
                    elif image_snapshots_dir in snapshot_path:
                        mime_type = self.mime.guess_type(pathname2url(snapshot_path))
                        if mime_type is not None:
                            mime_type = mime_type[0]
                        log.info("'{}' snapshot from {}".format(mime_type, snapshot_path))
                        try:
                            f = self.drive.CreateFile({
                                'title': os.path.basename(snapshot_path),
                                'mimeType': mime_type,
                                'parents': [{"kind": "drive#fileLink", "id": self._gdrive_folder_id}]
                            })
                            f.SetContentFile(snapshot_path)
                            f.Upload()
                            log.info("Uploaded '{}' to Google Drive folder '{}' (ID: '{}')".format(
                                os.path.basename(snapshot_path), self._gdrive_folder, f['id']))
                        except FileNotUploadedError:
                            log.exception("Cannot upload {} to Google Drive".format(snapshot_path))
                except Exception:
                    log.exception("Cannot process {}".format(snapshot_path))


class SnapshotProcessor(Thread):

    def __init__(self):
        super(SnapshotProcessor, self).__init__()
        self.last_snapshot = 0
        self.active_devices = {}
        self.latest_snapshot = datetime.utcnow().replace(tzinfo=pytz.utc)
        self.last_notification = 0

    def run(self):
        while True:
            snapshot = None
            try:
                snapshot = snapshot_queue.get(timeout=heartbeat_interval_seconds)
            except Empty:
                # deal with the heartbeat deficit below
                pass
            except Exception as e:
                log.error(e)
            else:
                snapshot_queue.task_done()

            if snapshot is not None:
                if snapshot.is_expired:
                    log.debug("Discarding expired snapshot {}".format(snapshot))
                    pass
                new_devices = False
                # only non-expired snapshots qualify as recent updates
                self.last_snapshot = time.time()
                if len(snapshot.devices) == 0:
                    self.active_devices.clear()
                else:
                    new_device_names = snapshot.devices.keys()
                    # first purge dead keys
                    for device_name in self.active_devices.keys():
                        if device_name not in new_device_names:
                            del self.active_devices[device_name]
                    # now add new ones
                    for device_name in new_device_names:
                        if device_name not in self.active_devices:
                            new_devices = True
                            self.active_devices[device_name] = snapshot.timestamp
                if len(self.active_devices) > 0:
                    log.debug("{} active device(s).".format(len(self.active_devices)))
                last_notified = time.time() - self.last_notification
                if (last_notified > notification_interval_seconds or new_devices) \
                    and len(self.active_devices) > 0 \
                    and self.latest_snapshot < snapshot.timestamp:
                    self.latest_snapshot = snapshot.timestamp
                    self.last_notification = time.time()
                    log.info("Sending notification for {}".format(str(self.active_devices.keys())))
                    for device_name in self.active_devices.keys():
                        notification_queue.put(device_name)
            else:
                inactivity = time.time() - self.last_snapshot
                if inactivity > heartbeat_interval_seconds:
                    log.warn("A heartbeat or snapshot is overdue (after {} seconds)".format(heartbeat_interval_seconds))


if __name__ == "__main__":
    # set up logging
    log.setLevel(logging.DEBUG)
    syslog_handler = logging.handlers.SysLogHandler(address = '/dev/log')
    formatter = logging.Formatter('%(name)s [%(levelname)s] %(message)s')
    syslog_handler.setFormatter(formatter)
    log.addHandler(syslog_handler)
    stream_handler = logging.StreamHandler(stream=sys.stdout)
    log.addHandler(stream_handler)
    # ensure that auth is properly set up first
    upload_event_handler = UploadEventHandler(gauth_creds_file=config.get('gdrive', 'creds_file'), gdrive_folder=config.get('gdrive', 'folder'))
    # start threads
    observer = Observer()
    observer.schedule(upload_event_handler, config.get('snapshots', 'root_dir'), recursive=True)
    observer.start()
    processor = SnapshotProcessor()
    processor.daemon = True
    processor.start()
    notifier = TTSProcessor()
    notifier.daemon = True
    notifier.start()
    try:
        while True:
            time.sleep(1)
    except(KeyboardInterrupt, SystemExit):
        log.info("Stopping threads...")
        observer.stop()
        log.info("Waiting for completion...")
        observer.join()
        log.info("Waiting for queue threads...")
        snapshot_queue.join()
        notification_queue.join()
        notifier.stop()
