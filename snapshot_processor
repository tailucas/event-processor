#!/usr/bin/python
import dateutil.parser
import hashlib
import logging
import logging.handlers
import mplayer
import os
import pprint
import pytz
import sys
import time
import umsgpack
import urllib2

from ConfigParser import ConfigParser

from abc import ABCMeta, abstractmethod, abstractproperty
from datetime import datetime, timedelta
from mplayer import Player
from Queue import Queue, Empty
from threading import Thread
from time import sleep
from umsgpack import UnpackException
from urllib import urlencode
from watchdog.events import FileSystemEventHandler
from watchdog.observers import Observer

sys.displayhook = pprint.pprint

APP=os.path.basename(__file__)
DIR=os.path.abspath(os.path.dirname(__file__))
log = logging.getLogger(APP)

TTS_URL = 'http://translate.google.com/translate_tts'

config = ConfigParser()
config.optionxform=str
config.read([os.path.expanduser('~/.{}'.format(APP))])

snapshot_root = config.get('snapshots', 'root_dir')
heartbeat_interval_seconds = int(config.get('snapshots', 'heartbeat_interval_seconds'))
sample_snapshots_dir = config.get('sample_snapshots', 'dir')
notification_interval_seconds = int(config.get('snapshots', 'notification_interval_seconds'))
snapshot_validity_seconds = int(config.get('snapshots', 'snapshot_validity_seconds'))

snapshot_queue = Queue()
notification_queue = Queue()

class TTSProcessor(Thread):

    def __init__(self):
        super(TTSProcessor, self).__init__()
        self.player = None

    def run(self):
        # black-holding STDOUT causes properties to not work
        self.player = Player(stderr=open('/dev/null', 'w'), autospawn=True)
        while True:
            notification = None
            try:
                notification = notification_queue.get()
            except Exception as e:
                log.error(e)
            else:
                notification_queue.task_done()
            self.say(str(notification))

    def stop(self):
        if self.player:
            self.player.quit()

    def say(self, message):
        msg_checksum = TTSProcessor.checksum(message)
        log.debug("Checksum for \"{}\" is [{}]".format(message, msg_checksum))
        tts_file = "{}.mp3".format(msg_checksum)
        tts_path = os.path.join(DIR, tts_file)
        log.debug("{} exists? {}".format(tts_path, os.path.isfile(tts_path)))
        if not os.path.isfile(tts_path):
            values = {'tl': 'en', 'q': message}
            data = urlencode(values)
            request = urllib2.Request(TTS_URL, data)
            request.add_header('User-agent', 'Mozilla/5.0')
            opener = urllib2.build_opener()
            log.debug("Fetching \"{}\" from {}".format(message, TTS_URL))
            f = open(tts_path, "wb")
            f.write(opener.open(request).read())
            f.close()
            log.debug("Written {} bytes to {}".format(os.path.getsize(tts_path), tts_path))
        # now play
        self.player.loadfile(tts_path)
        delay = int(self.player.length)
        # block for the duration of this audio sample
        log.debug("Saying \"{}\" for {}s".format(message, delay))
        sleep(delay)

    @staticmethod
    def checksum(message):
        m = hashlib.md5()
        m.update(message)
        return m.hexdigest()


class Snapshot(object):
    __metaclass__ = ABCMeta

    def __init__(self, file_path, validity_seconds):
        self.file_path = file_path
        self.validity_seconds = validity_seconds

    @abstractproperty
    def timestamp(self):
        return NotImplemented

    @abstractproperty
    def is_expired(self):
        return NotImplemented

    @abstractproperty
    def data(self):
        return NotImplemented

    @abstractproperty
    def devices(self):
        return NotImplemented


class SampledSnapshot(Snapshot):

    def __init__(self, file_path, validity_seconds):
        super(SampledSnapshot, self).__init__(file_path=file_path, validity_seconds=validity_seconds)
        f = open(file_path)
        self.snapshot_data = umsgpack.unpack(f)
        self.timestamp_data = dateutil.parser.parse(self.snapshot_data['timestamp'])
        if 'data' in self.snapshot_data:
            self.devices_data = self.snapshot_data['data']
        else:
            self.devices_data = None

    @property
    def timestamp(self):
        return self.timestamp_data

    @property
    def is_expired(self):
        now = datetime.utcnow().replace(tzinfo=pytz.utc)
        return now - self.timestamp_data > timedelta(seconds=self.validity_seconds)

    @property
    def data(self):
        return self.snapshot_data

    @property
    def devices(self):
        if self.devices_data is None:
            return {}
        return self.devices_data

    def __str__(self):
        string = "{}".format(self.timestamp.strftime('%X %x %Z'))
        if self.devices:
            return string + ": {} devices: {}".format(len(self.devices), ','.join(self.devices.keys()))
        return string


class UploadEventHandler(FileSystemEventHandler):

    def __init__(self):
        super(UploadEventHandler, self).__init__()
        self.last_modified = None


    # we listen to on-modified events because the file is
    # created and then written to subsequently.
    def on_modified(self, event):
        super(UploadEventHandler, self).on_modified(event)
        what = 'directory' if event.is_directory else 'file'
        # the file has been written to and has valid content
        if not event.is_directory:
            snapshot_path = event.src_path
            # de-duplication
            if snapshot_path != self.last_modified:
                self.last_modified = snapshot_path
            else:
                return
            # cross-check that we're in the right place
            if snapshot_path.startswith(snapshot_root):
                if sample_snapshots_dir in snapshot_path:
                    try:
                        snapshot = SampledSnapshot(file_path=snapshot_path, validity_seconds=snapshot_validity_seconds)
                        log.info("Snapshot: {} from {}".format(snapshot, snapshot_path))
                        snapshot_queue.put(snapshot)
                        last_snapshot_path = snapshot_path
                    except UnpackException:
                        log.exception("Cannot unpack snapshot data in {}".format(snapshot_path))
                    except Exception:
                        log.exception("Cannot process {}".format(snapshot_path))


class SnapshotProcessor(Thread):

    def __init__(self):
        super(SnapshotProcessor, self).__init__()
        self.last_snapshot = 0
        self.active_devices = {}
        self.latest_snapshot = datetime.utcnow().replace(tzinfo=pytz.utc)
        self.last_notification = 0

    def run(self):
        while True:
            snapshot = None
            try:
                snapshot = snapshot_queue.get(timeout=heartbeat_interval_seconds)
            except Empty:
                # deal with the heartbeat deficit below
                pass
            except Exception as e:
                log.error(e)
            else:
                snapshot_queue.task_done()

            if snapshot is not None:
                if snapshot.is_expired:
                    log.debug("Discarding expired snapshot {}".format(snapshot))
                    pass
                new_devices = False
                # only non-expired snapshots qualify as recent updates
                self.last_snapshot = time.time()
                if len(snapshot.devices) == 0:
                    self.active_devices.clear()
                else:
                    new_device_names = snapshot.devices.keys()
                    # first purge dead keys
                    for device_name in self.active_devices.keys():
                        if device_name not in new_device_names:
                            del self.active_devices[device_name]
                    # now add new ones
                    for device_name in new_device_names:
                        if device_name not in self.active_devices:
                            new_devices = True
                            self.active_devices[device_name] = snapshot.timestamp
                if len(self.active_devices) > 0:
                    log.debug("{} active device(s).".format(len(self.active_devices)))
                last_notified = time.time() - self.last_notification
                if (last_notified > notification_interval_seconds or new_devices) \
                    and len(self.active_devices) > 0 \
                    and self.latest_snapshot < snapshot.timestamp:
                    self.latest_snapshot = snapshot.timestamp
                    self.last_notification = time.time()
                    log.info("Sending notification for {}".format(str(self.active_devices.keys())))
                    for device_name in self.active_devices.keys():
                        notification_queue.put(device_name)
            else:
                inactivity = time.time() - self.last_snapshot
                if inactivity > heartbeat_interval_seconds:
                    log.warn("A heartbeat or snapshot is overdue (after {} seconds)".format(heartbeat_interval_seconds))


if __name__ == "__main__":
    # set up logging
    log.setLevel(logging.DEBUG)
    syslog_handler = logging.handlers.SysLogHandler(address = '/dev/log')
    formatter = logging.Formatter('%(name)s [%(levelname)s] %(message)s')
    syslog_handler.setFormatter(formatter)
    log.addHandler(syslog_handler)
    stream_handler = logging.StreamHandler(stream=sys.stdout)
    log.addHandler(stream_handler)
    # start threads
    observer = Observer()
    observer.schedule(UploadEventHandler(), config.get('snapshots', 'root_dir'), recursive=True)
    observer.start()
    processor = SnapshotProcessor()
    processor.daemon = True
    processor.start()
    notifier = TTSProcessor()
    notifier.daemon = True
    notifier.start()
    try:
        while True:
            time.sleep(1)
    except(KeyboardInterrupt, SystemExit):
        log.info("Stopping threads...")
        observer.stop()
        log.info("Waiting for completion...")
        observer.join()
        log.info("Waiting for queue threads...")
        snapshot_queue.join()
        notification_queue.join()
        notifier.stop()
