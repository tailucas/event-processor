#!/usr/bin/python
import dateutil.parser
import hashlib
import logging
import logging.handlers
import os
import pprint
import sys
import time
import umsgpack
import urllib2

from ConfigParser import ConfigParser

from abc import ABCMeta, abstractmethod, abstractproperty
from threading import Thread
from time import sleep
from umsgpack import UnpackException
from watchdog.events import FileSystemEventHandler
from watchdog.observers import Observer

sys.displayhook = pprint.pprint

APP=os.path.basename(__file__)
log = logging.getLogger(APP)

TTS_URL = 'http://translate.google.com/translate_tts'

config = ConfigParser()
config.read([os.path.expanduser('~/.{}'.format(APP))])

snapshot_root = config.get('snapshots', 'root_dir')
sample_snapshots_dir = config.get('sample_snapshots', 'dir')


def checksum(message):
    m = hashlib.md5()
    m.update(message)
    return m.hexdigest()


class TTSProcessor(object):

    def __init__(self):
        pass

    def say(self, message):
        msg_checksum = checksum(message)

        values = {'tl': 'en', 'q', message}
        data = urllib.urlencode(values)
        request = urllib2.Request(TTS_URL, data)
        request.add_header('User-agent', 'Mozilla/5.0')
        opener = urllib2.build_opener()

        tts_file = "{}.mp3".format(msg_checksum)
        f = open(tts_file, "wb")
        f.write(opener.open(request).read())
        f.close()

class Snapshot(object):
    __metaclass__ = ABCMeta

    def __init__(self, file_path):
        self.file_path = file_path

    @abstractproperty
    def timestamp(self):
        return NotImplemented

    @abstractproperty
    def data(self):
        return NotImplemented

    @abstractproperty
    def devices(self):
        return NotImplemented


class SampledSnapshot(Snapshot):

    def __init__(self, file_path):
        super(SampledSnapshot, self).__init__(file_path=file_path)
        f = open(file_path)
        self.snapshot_data = umsgpack.unpack(f)
        self.timestamp_data = dateutil.parser.parse(self.snapshot_data['timestamp'])
        self.devices_data = self.snapshot_data['data']

    @property
    def timestamp(self):
        return self.timestamp_data

    @property
    def data(self):
        return self.snapshot_data

    @property
    def devices(self):
        return self.devices_data

    def __str__(self):
        return "{}: {} devices: {}".format(self.timestamp.strftime('%X %x %Z'), len(self.devices), ','.join(self.devices.keys()))


class UploadEventHandler(FileSystemEventHandler):
    # we listen to on-modified events because the file is
    # created and then written to subsequently.
    def on_modified(self, event):
        super(UploadEventHandler, self).on_modified(event)
        what = 'directory' if event.is_directory else 'file'
        # the file has been written to and has valid content
        if not event.is_directory:
            log.info("Modified {}: {}".format(what, event.src_path))
            snapshot_path = event.src_path
            # cross-check that we're in the right place
            if snapshot_path.startswith(snapshot_root):
                if sample_snapshots_dir in snapshot_path:
                    try:
                        snapshot = SampledSnapshot(file_path=snapshot_path)
                        log.info("Loaded snapshot data {}".format(snapshot))
                    except UnpackException:
                        log.exception("Cannot unpack snapshot data in {}".format(snapshot_path))
                    except Exception:
                        log.exception("Cannot process {}".format(snapshot_path))


if __name__ == "__main__":
    # set up logging
    log.setLevel(logging.DEBUG)
    syslog_handler = logging.handlers.SysLogHandler(address = '/dev/log')
    formatter = logging.Formatter('%(name)s [%(levelname)s] %(message)s')
    syslog_handler.setFormatter(formatter)
    log.addHandler(syslog_handler)
    stream_handler = logging.StreamHandler(stream=sys.stdout)
    log.addHandler(stream_handler)
    # start threads
    observer = Observer()
    observer.schedule(UploadEventHandler(), config.get('snapshots', 'root_dir'), recursive=True)
    observer.start()
    try:
        while True:
            time.sleep(1)
    except(KeyboardInterrupt, SystemExit):
        log.info("Stopping threads.")
        observer.stop()
        log.info("Waiting for completion.")
        observer.join()
