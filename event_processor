#!/usr/bin/python
import dateutil.parser
import hashlib
import logging
import logging.handlers

import abc
import copy
import json
import os
import pytz
import signal
import sys
import threading
import time
import umsgpack
import zmq

from boto import dynamodb2
from boto.dynamodb2.table import Table
from boto.dynamodb2.exceptions import ItemNotFound, JSONResponseError, DynamoDBError
from boto.ec2 import cloudwatch
from ConfigParser import ConfigParser
from datetime import datetime, timedelta
from dateutil import tz
from pprint import pprint
from sets import Set
from Queue import Queue, Empty
from resin.exceptions import RequestError
from resin.models.device import Device
from threading import Thread, Timer
from time import sleep
from umsgpack import UnpackException
from zmq import ContextTerminated
from flask import Flask, flash, request, render_template, url_for, redirect, session, escape

# unbuffered STDOUT for print
sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)
sys.displayhook = pprint

APP = os.path.basename(__file__)
DIR = os.path.abspath(os.path.dirname(__file__))
# PID file check
pidfile = '/var/run/{}.pid'.format(APP)
if os.path.isfile(pidfile):
    pid = int(open(pidfile, 'r').read())
    message = '{} already exists containing PID {}.'.format(pidfile, pid)
    proc_path = '/proc/{}/cmdline'.format(pid)
    # existing process?
    if os.path.isfile(proc_path):
        proc_info = open(proc_path, 'r').read()
        if 'python' in proc_info and APP in proc_info:
            print '{} is already running. {}'.format(APP, message)
            sys.exit(1)
    print '{} Removing stale PID file.'.format(message)
    # what's in the PID file is stale, destroy it
    os.unlink(pidfile)
# create a new PID file
file(pidfile, 'w').write(str(os.getpid()))

# set the working directory for libraries that assume this (such as PyDrive)
os.chdir(DIR)
log = logging.getLogger(APP)
# do not propagate to console logging
log.propagate = False

config = ConfigParser()
config.optionxform = str
config.read([os.path.join(DIR, '{}.conf'.format(APP))])

DATE_FORMAT = '%Y-%m-%dT%H:%M:%S.%f%z'

rest_api = Flask(APP)

URL_WORKER_EVENT_PROCESSOR = 'inproc://event-processor'
zmq_context = zmq.Context()
zmq_context.setsockopt(zmq.LINGER, 0)

event_processor = None


def is_list(value):
    return isinstance(value, list)


def make_payload(timestamp=None, data=None):
    payload = dict()
    if timestamp is None:
        timestamp = time.time()
    payload['timestamp'] = datetime.utcfromtimestamp(timestamp).replace(tzinfo=pytz.utc).strftime(DATE_FORMAT)
    if data is not None and len(data) > 0:
        payload['data'] = data
    log.debug(json.dumps(payload))
    return umsgpack.packb(payload)


@rest_api.route('/logging')
def debug():
    log.setLevel(request.args.get('level'))
    return 'OK'


@rest_api.route('/', methods=['GET', 'POST'])
def index():
    group_disabled = dict()
    device_listing = dict()
    input_labels = dict()
    awol_inputs = event_processor.awol_inputs
    if len(awol_inputs) > 0:
        flash(message='{} devices are unavailable at this time.'.format(len(awol_inputs)), category='danger')
    for device_key, device_config in event_processor.input_config.items():
        if 'group_name' not in device_config:
            device_listing[device_key] = device_config
        else:
            group_name = device_config['group_name']
            if group_name not in device_listing:
                device_listing[group_name] = dict()
                device_listing[group_name]['grouped_inputs'] = dict()
            device_listing[group_name]['grouped_inputs'][device_key] = device_config
            if group_name not in input_labels:
                input_labels[group_name] = list()
            input_labels[group_name].append(device_config['device_label'])
            # manufacture a device label for the group
            device_listing[group_name]['device_label'] = group_name
            # check for enabled/disabled disparity
            if 'device_disabled' in device_config:
                device_listing[group_name]['device_disabled'] = device_config['device_disabled']
                if group_name not in group_disabled:
                    group_disabled[group_name] = device_config['device_disabled']
                elif group_disabled[group_name] != device_config['device_disabled']:
                    device_listing[group_name]['mixed_disabled'] = True
            elif group_name in group_disabled and group_disabled[group_name]:
                device_listing[group_name]['mixed_disabled'] = True
    if request.method == 'POST':
        device_key = request.form['device_key']
        if 'grouped_inputs' not in device_listing[device_key]:
            if 'device_disabled' not in device_listing[device_key]:
                disable = True
                device_listing[device_key]['device_disabled'] = True
            else:
                disable = None
                del device_listing[device_key]['device_disabled']
            event_processor.flash_info = False
            event_processor.input_config = (
                device_key,
                {'device_disabled': disable}
            )
            event_processor.flash_info = True
        else:
            # ambiguity => enabled
            if 'mixed_disabled' in device_listing[device_key]:
                disable = None
                # ambiguity resolved
                del device_listing[device_key]['mixed_disabled']
                del device_listing[device_key]['device_disabled']
            elif 'device_disabled' not in device_listing[device_key]:
                disable = True
                device_listing[device_key]['device_disabled'] = True
            else:
                disable = None
                del device_listing[device_key]['device_disabled']
            event_processor.flash_info = False
            for grouped_device_key, grouped_device in device_listing[device_key]['grouped_inputs'].items():
                grouped_device['device_disabled'] = disable
                event_processor.input_config = (
                    grouped_device_key,
                    {'device_disabled': disable}
                )
            event_processor.flash_info = True
    return render_template('index.html',
                           inputs=device_listing,
                           input_labels=input_labels,
                           awol_inputs=awol_inputs)


@rest_api.route('/config', methods=['GET', 'POST'])
def show_config():
    return render_template('config.html')


@rest_api.route('/input_config', methods=['GET', 'POST'])
def input_config():
    if request.method == 'POST':
        device_key = request.form['device_key']
        try:
            customized = False
            to_save = dict()
            group_name = request.form['group_name'].strip()
            if len(group_name) > 0:
                to_save['group_name'] = group_name
                customized = True
            else:
                to_save['group_name'] = None
            if request.form.get('multi_trigger'):
                to_save['multi_trigger'] = True
                customized = True
            else:
                to_save['multi_trigger'] = None
            if len(request.form['activation_interval']) > 0:
                to_save['activation_interval'] = int(request.form['activation_interval'])
                customized = True
            else:
                to_save['activation_interval'] = None
            if len(request.form['trigger_window']) > 0:
                to_save['trigger_window'] = int(request.form['trigger_window'])
                customized = True
            else:
                to_save['trigger_window'] = None
            to_save['customized'] = customized
            event_processor.input_config = (
                device_key,
                to_save
            )
        except ValueError as e:
            message = "Cannot update '{}'".format(event_processor.input_config[device_key]['device_label'])
            flash(message='{}: {}'.format(message, e.message), category='danger')
    return render_template('input_config.html',
                           inputs=event_processor.input_config,
                           default_trigger_window=int(config.get('config', 'default_trigger_window')),
                           default_activation_interval=int(config.get('config', 'default_activation_interval')))


@rest_api.route('/input_link', methods=['GET', 'POST'])
def input_link():
    if request.method == 'POST':
        event_processor.input_config = (
            request.form['device_key'],
            {'linked_inputs': request.form.getlist('linked_input')}
        )
    return render_template('input_link.html',
                           inputs=event_processor.input_config)


@rest_api.route('/output_link', methods=['GET', 'POST'])
def output_link():
    if request.method == 'POST':
        event_processor.input_config = (
            request.form['device_key'],
            {'linked_outputs': request.form.getlist('linked_output')}
        )
    return render_template('output_link.html',
                           inputs=event_processor.input_config,
                           outputs=event_processor.outputs)


@rest_api.route('/output_config', methods=['GET', 'POST'])
def output_config():
    if request.method == 'POST':
        to_save = dict()
        device_params = request.form['device_params'].strip()
        if len(device_params) > 0:
            to_save['device_params'] = device_params
        else:
            to_save['device_params'] = None
        event_processor.output_config = (
            request.form['device_key'],
            to_save
        )
    return render_template('output_config.html',
                           outputs=event_processor.output_config)


class SignalHandler:

    def __init__(self):
        self.last_signal = 0
        signal.signal(signal.SIGTERM, self.terminate)
        signal.signal(signal.SIGHUP, self.hup)

    def hup(self, signum, frame):
        log.warn('Signal {} received.'.format(signum))
        self.last_signal = signum
        if log.getEffectiveLevel() == logging.INFO:
            log.setLevel(logging.DEBUG)
        elif log.getEffectiveLevel() == logging.DEBUG:
            log.setLevel(logging.INFO)

    def terminate(self, signum, frame):
        log.warn('Signal {} received.'.format(signum))
        self.last_signal = signum
        raise RuntimeWarning()


def thread_nanny(threads_tracked, signal_handler):
    while True:
        # kill the nanny now
        if signal_handler.last_signal == signal.SIGTERM:
            break
        threads_alive = Set()
        for thread_info in threading.enumerate():
            if thread_info.isAlive():
                threads_alive.add(thread_info.getName())
        if len(threads_tracked - threads_alive) > 0:
            message = 'A thread has died. Expected threads are [{}], missing is [{}].'.format(threads_tracked, threads_tracked - threads_alive)
            log.error(message)
        sleep(10)


class EventProcessor(Thread):

    def __init__(self):
        super(EventProcessor, self).__init__()
        self.name = self.__class__.__name__
        self.daemon = True

        self.inputs = dict()
        self.outputs = dict()

        self._input_trigger_history = dict()
        self._input_active_history = dict()

        self._origin_ips = dict()
        self._origin_connections = dict()

        self._input_origin = dict()
        self._output_origin = dict()

        self._inputs_by_origin = dict()
        self._outputs_by_origin = dict()

        self._awol_inputs = set()
        self._awol_outputs = set()

        self._db_storage = None

        self._general_config = None
        self._general_config_table = None

        self._input_config = None
        self._input_config_table = None

        self._output_config = None
        self._output_config_table = None

        self._metrics = None

        self.flash_info = True

        self.socket = zmq_context.socket(zmq.PULL)
        self.socket.bind(URL_WORKER_EVENT_PROCESSOR)

    @property
    def general_config(self):
        return self._general_config

    @general_config.setter
    def general_config(self, config_update):
        config_key, updated_config = config_update
        self._general_config = dict()

    @property
    def input_config(self):
        devices = copy.deepcopy(self.inputs)
        devices_config = self._input_config
        for device_key in devices.keys():
            if device_key in devices_config:
                devices[device_key].update(devices_config[device_key])
        return devices

    @input_config.setter
    def input_config(self, config_update):
        device_key, updated_config = config_update
        EventProcessor._update_config(
            device_key=device_key,
            devices=self.inputs,
            device_configs=self._input_config,
            updates=updated_config,
            table_member=self._input_config_table,
            primary_key={'device_key': device_key},
            flash_info=self.flash_info)

    @property
    def output_config(self):
        devices = copy.deepcopy(self.outputs)
        devices_config = self._output_config
        for device_key in devices.keys():
            if device_key in devices_config:
                devices[device_key].update(devices_config[device_key])
        return devices

    @output_config.setter
    def output_config(self, config_update):
        device_key, updated_config = config_update
        EventProcessor._update_config(
            device_key=device_key,
            devices=self.outputs,
            device_configs=self._output_config,
            updates=updated_config,
            table_member=self._output_config_table,
            primary_key={'device_key': device_key},
            flash_info=self.flash_info)

    @property
    def awol_inputs(self):
        return self._awol_inputs

    @staticmethod
    def _update_config(device_key, devices, device_configs, updates, table_member, primary_key, flash_info=True):
        device_label = devices[device_key]['device_label']
        device_config = dict()
        try:
            device_config = device_configs[device_key]
        except KeyError:
            device_configs[device_key] = device_config
        try:
            table_name = table_member.table_name
            log.info("Updating table '{}'...".format(table_name))
            try:
                log.debug("Item '{}' to be updated with '{}'".format(primary_key, updates))
                table_item = table_member.get_item(**primary_key)
                for key, value in updates.items():
                    if value:
                        table_item[key] = value
                    elif key in table_item:
                        del table_item[key]
                saved = table_item.partial_save()
            except ItemNotFound:
                log.debug("Item '{}' not found in '{}'. Creating new.".format(primary_key, table_name))
                put_args = dict()
                put_args['data'] = dict()
                put_args['data'].update(primary_key)
                put_args['data'].update(updates)
                saved = table_member.put_item(**put_args)
            if saved:
                if flash_info:
                    flash("Updated '{}'".format(device_label))
                for key, value in updates.items():
                    if value:
                        device_config[key] = value
                    elif key in device_config:
                        del device_config[key]
            else:
                if flash_info:
                    flash("'{}' not updated.".format(device_label), category='warning')
        except Exception as e:
            message = "Cannot update '{}'".format(device_label)
            log.exception(message)
            flash(message='{}: {}'.format(message, e.message), category='danger')

    def _update_devices(self, event_origin, device_info):
        devices_updated = 0
        for input_outputs, device_origin, origin_devices, awol_devices, io in [
            (self.inputs, self._input_origin, self._inputs_by_origin, self._awol_inputs, 'inputs'),
            (self.outputs, self._output_origin, self._outputs_by_origin, self._awol_outputs, 'outputs')
        ]:
            for device in device_info[io]:
                try:
                    devices_updated += self._update_device(
                        input_outputs=input_outputs,
                        device_origin=device_origin,
                        origin_devices=origin_devices,
                        event_origin=event_origin,
                        awol_devices=awol_devices,
                        device=device
                    )
                except RuntimeError:
                    log.exception('Bad device @ {}.'.format(device_origin))
        return devices_updated

    def _update_device(self, input_outputs, device_origin, origin_devices, event_origin, awol_devices, device):
        # device_key must always be present
        try:
            device_key = device['device_key']
        except KeyError:
            raise RuntimeError("No device key in {}".format(device))
        # set the device label if that hasn't already been done
        if 'device_label' not in device:
            device['device_label'] = device_key
        # associate the device with this event origin
        if event_origin not in origin_devices:
            origin_devices[event_origin] = set()
        if device_key not in origin_devices[event_origin]:
            origin_devices[event_origin].add(device_key)
        # has this device been awol?
        awol_devices.discard(device_key)
        # has this device been seen?
        if device_key not in device_origin:
            device_origin[device_key] = event_origin
        elif device_origin[device_key] != event_origin:
            raise RuntimeError("Device with key '{}' is already present at '{}' "
                               "but is also present at '{}' and is ignored.".format(device_key,
                                                                                    device_origin[device_key],
                                                                                    event_origin))
        if device_key not in input_outputs:
            input_outputs[device_key] = device
            return 1
        return 0

    def _process_device_event(self, event_origin, timestamp, active_device_key, active_device):
        if active_device_key in self._input_config and 'linked_outputs' in self._input_config[active_device_key]:
            output_device_keys = self._input_config[active_device_key]['linked_outputs']
            log.debug('{} {} => {}'.format(event_origin, active_device_key, output_device_keys))
            for output_device_key in output_device_keys:
                output_device_activation = dict()
                if output_device_key not in self.outputs:
                    log.warn('{} is linked to an unknown output {}'.format(active_device_key,
                                                                           output_device_key))
                    continue
                if output_device_key not in self._output_origin:
                    log.warn('{} {} => {} but nowhere to route the response.'.format(event_origin,
                                                                                     active_device_key,
                                                                                     output_device_key))
                    continue
                event_destination = self._output_origin[output_device_key]
                log.info('{} {} => {} {}'.format(
                    event_origin,
                    active_device_key,
                    event_destination,
                    output_device_key))
                output_device_activation.update(self.outputs[output_device_key])
                if output_device_key in self._output_config:
                    output_device_activation.update(self._output_config[output_device_key])
                output_push_socket = self._origin_connections[event_destination]
                activation_command = {
                    'trigger_output': output_device_activation,
                    'input_context': active_device
                }
                if 'activation_interval' in self._input_config[active_device_key]:
                    activation_command['trigger_duration'] = int(
                        self._input_config[active_device_key]['activation_interval']
                    )
                output_push_socket.send(make_payload(
                    timestamp=None,
                    data=activation_command))
        else:
            log.warn('{} is not configured or linked to any output: {}'.format(active_device_key, active_device))

    def post_metric(self, name, value, timestamp=None, unit='Count'):
        scalar = None
        if isinstance(value, list):
            scalar = len(value)
        elif isinstance(value, int):
            scalar = value
        else:
            raise RuntimeError('Unable to determine scalar value from {}'.format(value))
        if timestamp is None:
            timestamp = datetime.utcfromtimestamp(time.time()).replace(tzinfo=pytz.utc)
        log.debug("Posting '{}' of '{}' for '{}' at {}".format(unit,
                                                               scalar,
                                                               self.metric_namespace,
                                                               timestamp.isoformat()))
        self._metrics.put_metric_data(namespace=self.metric_namespace,
                                     name=name,
                                     value=scalar,
                                     timestamp=timestamp,
                                     unit=unit)

    def __setup_config_table(self, table_name, primary_key='device_key'):
        log.info("Loading Dynamo table '{}'...".format(table_name))
        member_table = Table(
            table_name=table_name,
            connection=self._db_storage)
        log.info("Reading table '{}'...".format(table_name))
        member = dict()
        for result in member_table.scan():
            device_key = None
            member_config = dict()
            for key, value in result.items():
                if key == primary_key:
                    device_key = value
                else:
                    member_config.update([(key, value)])
            if device_key and len(member_config) > 0:
                member[device_key] = member_config
        return member, member_table

    def add_event_origin(self, origin, ip):
        self._origin_ips[origin] = ip

    def run(self):
        # connect to AWS services
        self._db_storage = dynamodb2.connect_to_region(
            region_name=config.get('aws', 'region'),
            aws_access_key_id=config.get('aws', 'aws_access_key_id'),
            aws_secret_access_key=config.get('aws', 'aws_secret_access_key'))
        # set up metrics
        self._metrics = cloudwatch.connect_to_region(
            region_name=config.get('aws', 'region'),
            aws_access_key_id=config.get('aws', 'aws_access_key_id'),
            aws_secret_access_key=config.get('aws', 'aws_secret_access_key'))
        self.metric_namespace = '{}:{}'.format(config.get('metric', 'namespace'), APP)
        # load configuration data
        self._general_config, self._general_config_table = self.__setup_config_table(
            table_name=config.get('config', 'general_config_table'),
            primary_key='config_key')
        self._input_config, self._input_config_table = self.__setup_config_table(
            table_name=config.get('config', 'input_config_table'))
        self._output_config, self._output_config_table = self.__setup_config_table(
            table_name=config.get('config', 'output_config_table'))
        # connect to event origins
        for origin, ip in self._origin_ips.items():
            connection_string = 'tcp://{}:{}'.format(ip, config.get('zmq', 'pushpull_port'))
            log.info('Device events will be responded to via {} @ {}'.format(origin, connection_string))
            origin_push_socket = zmq_context.socket(zmq.PUSH)
            origin_push_socket.connect(connection_string)
            self._origin_connections[origin] = origin_push_socket

        while True:
            try:
                event = self.socket.recv_pyobj()
                log.debug(event)
                if isinstance(event, dict):
                    for event_origin, event_data in event.items():
                        timestamp = None
                        if 'timestamp' in event_data:
                            timestamp = dateutil.parser.parse(event_data['timestamp'])
                        else:
                            timestamp = datetime.utcnow().replace(tzinfo=pytz.utc)
                        if 'data' in event_data:
                            if 'stale_heartbeat' in event_data['data']:
                                heartbeat = event_data['data']['stale_heartbeat']
                                hb = "never"
                                if heartbeat:
                                    hb = datetime.utcfromtimestamp(heartbeat).replace(tzinfo=pytz.utc).strftime(DATE_FORMAT)
                                device_status = "unknown"
                                if 'device_status' in event_data['data']:
                                    device_status = event_data['data']['device_status']
                                new_awol = 0
                                # check if there are any inputs or outputs configured for this origin
                                for devices, origin_devices, awol_devices in [
                                    (self.inputs, self._inputs_by_origin, self._awol_inputs),
                                    (self.outputs, self._outputs_by_origin, self._awol_outputs)
                                ]:
                                    if len(origin_devices[event_origin]) > 0:
                                        log.debug("'{}' last checked-in: {} in an '{}' state.".format(
                                            event_origin,
                                            hb,
                                            device_status.lower()))
                                        for device_key in origin_devices[event_origin]:
                                            if device_key not in awol_devices:
                                                awol_devices.add(device_key)
                                                new_awol += 1
                                if new_awol > 0:
                                    log.warn("{} new devices are unavailable because '{}' has gone AWOL.".format(
                                        new_awol,
                                        event_origin
                                    ))
                            if 'device_info' in event_data['data']:
                                devices_updated = self._update_devices(
                                    event_origin=event_origin,
                                    device_info=event_data['data']['device_info'])
                                if devices_updated > 0:
                                    log.info('{} advertised {} new devices.'.format(event_origin, devices_updated))
                            if 'active_devices' in event_data['data']:
                                for active_device in event_data['data']['active_devices']:
                                    active_device_key = active_device['device_key']
                                    # input disabled?
                                    if active_device_key in self._input_config and 'device_disabled' in self._input_config[active_device_key]:
                                        continue
                                    # debounce this input
                                    if active_device_key in self._input_config and 'activation_interval' in self._input_config[active_device_key]:
                                        activation_interval = self._input_config[active_device_key]['activation_interval']
                                    else:
                                        activation_interval = int(config.get('config', 'default_activation_interval'))
                                    # multi-trigger
                                    if 'multi_trigger' in self._input_config[active_device_key]:
                                        if 'trigger_window' in self._input_config[active_device_key]:
                                            trigger_window = self._input_config[active_device_key]['trigger_window']
                                        else:
                                            trigger_window = int(config.get('config', 'default_trigger_window'))
                                        # if not in the trigger history, treat as never activated
                                        if active_device_key not in self._input_trigger_history:
                                            self._input_trigger_history[active_device_key] = time.time()
                                            continue
                                        input_last_triggered = self._input_trigger_history[active_device_key]
                                        # the device must have been considered active within the trigger window
                                        last_triggered = time.time() - input_last_triggered
                                        if last_triggered > trigger_window:
                                            # update the history and continue
                                            self._input_trigger_history[active_device_key] = time.time()
                                            log.debug('Not activating {} because it was triggered '
                                                      'more than {} seconds ago. ({})'.format(active_device_key,
                                                                                              trigger_window,
                                                                                              last_triggered))
                                            continue
                                    # debounce
                                    if active_device_key in self._input_active_history:
                                        input_last_active = self._input_active_history[active_device_key]
                                        last_activated = time.time() - input_last_active
                                        if last_activated < activation_interval:
                                            # device is still considered active
                                            log.debug('Not activating {} because it was triggered '
                                                      'less than {} seconds ago. ({})'.format(active_device_key,
                                                                                              activation_interval,
                                                                                              last_activated))
                                            continue
                                    self._input_active_history[active_device_key] = time.time()
                                    # active devices are presently assumed to be inputs
                                    self._update_device(
                                        input_outputs=self.inputs,
                                        device_origin=self._input_origin,
                                        event_origin=event_origin,
                                        device=active_device)
                                    log.debug('{} {}'.format(origin, active_device_key))
                                    self._process_device_event(
                                        event_origin=origin,
                                        timestamp=timestamp,
                                        active_device_key=active_device_key,
                                        active_device=active_device)
            except ContextTerminated:
                self.socket.close()
                origin_push_socket.close()
                break
            except Exception:
                log.exception(self.__class__.__name__)
                continue


class SourceSubscriber(Thread):

    def __init__(self, label, publisher_endpoint):
        super(SourceSubscriber, self).__init__()
        self.name = '{}::{}'.format(self.__class__.__name__, label)
        self.daemon = True

        self._label = label
        self._publisher_endpoint = publisher_endpoint

        self.subscriber = zmq_context.socket(zmq.SUB)
        self.processor = zmq_context.socket(zmq.PUSH)

        self.last_message = None

    def run(self):
        log.info('Subscribing to {} @ {}'.format(self._label, self._publisher_endpoint))
        self.subscriber.connect(self._publisher_endpoint)
        self.subscriber.setsockopt(zmq.SUBSCRIBE, "")
        self.processor.connect(URL_WORKER_EVENT_PROCESSOR)
        while True:
            try:
                publisher_event = umsgpack.unpackb(self.subscriber.recv())
                self.last_message = time.time()
                self.processor.send_pyobj({self._label: publisher_event})
            except UnpackException:
                log.exception('Cannot unpack message from {}.'.format(self._label))
                continue
            except ContextTerminated:
                self.subscriber.close()
                self.processor.close()
                break
            except Exception:
                log.exception(self.__class__.__name__)
                continue


class OriginNanny(Thread):

    def __init__(self):
        super(OriginNanny, self).__init__()
        self.name = self.__class__.__name__
        self.daemon = True

        self.processor = zmq_context.socket(zmq.PUSH)

        self.origin_subscriber = dict()
        self._max_heartbeat_delay = int(config.get('app', 'max_heartbeat_delay_seconds'))

    def add_origin_subscriber(self, origin, ip, subscriber):
        self.origin_subscriber[origin] = (ip, subscriber)

    def run(self):
        self.processor.connect(URL_WORKER_EVENT_PROCESSOR)
        # warm-up to wait for first volley of heartbeats
        sleep(self._max_heartbeat_delay)
        while True:
            resin_device = Device()
            for origin, (ip, subscriber) in self.origin_subscriber.items():
                # when last was an event seen by this subscriber
                last_message = subscriber.last_message
                if last_message is None or time.time() - subscriber.last_message > self._max_heartbeat_delay:
                    device_status = None
                    device_last_seen = None
                    if last_message:
                        last_message = datetime.utcfromtimestamp(last_message).replace(tzinfo=pytz.utc).strftime(DATE_FORMAT)
                    else:
                        last_message = "never"
                    try:
                        for d in resin_device.get_by_name(origin):
                            device_ip = d['ip_address'].split()[0]
                            # this matches the origin by name and IP
                            if device_ip == ip:
                                device_status = d['status']
                                device_last_seen = d['last_seen_time']
                                if device_last_seen is None:
                                    device_last_seen = "unknown"
                    except RequestError as e:
                        log.debug("Unable to fetch device information for Resin device '{}': {}".format(origin,
                                                                                                        e.message))
                    log_message = "'{}' last activity was {}.".format(origin, last_message)
                    if device_status:
                        log.debug("{} Device is {} (last seen: {})".format(log_message,
                                                                           device_status,
                                                                           device_last_seen))
                    else:
                        log.debug(log_message)
                    try:
                        # used as an out-of-band trigger for something amiss
                        payload = {
                            'stale_heartbeat': subscriber.last_message,
                        }
                        if device_status:
                            payload['device_status'] = device_status
                        self.processor.send_pyobj({origin: {'data': payload}})
                    except ContextTerminated:
                        self.processor.close()
                        break
            sleep(self._max_heartbeat_delay)

if __name__ == "__main__":
    # DEBUG logging until startup complete
    log.setLevel(logging.DEBUG)
    syslog_handler = logging.handlers.SysLogHandler(address='/dev/log')
    formatter = logging.Formatter('%(name)s [%(levelname)s] %(message)s')
    syslog_handler.setFormatter(formatter)
    log.addHandler(syslog_handler)
    if sys.stdout.isatty():
        log.warn("Using console logging because there is a tty.")
        stream_handler = logging.StreamHandler(stream=sys.stdout)
        stream_handler.setFormatter(formatter)
        log.addHandler(stream_handler)
    threads_tracked = Set()
    # bind main processor first
    event_processor = EventProcessor()
    origin_nanny = OriginNanny()
    # set up subscribers
    subscription_sources = config.get('app', 'subscription_sources').split(',')
    for source in subscription_sources:
        label_ip = source.split(':')
        source_label = label_ip[0]
        source_ip = label_ip[1]
        connection_string = 'tcp://{}:{}'.format(source_ip, config.get('zmq', 'pubsub_port'))
        subscriber = SourceSubscriber(label=source_label, publisher_endpoint=connection_string)
        threads_tracked.add(subscriber.getName())
        subscriber.start()
        # nanny the heartbeats
        origin_nanny.add_origin_subscriber(origin=source_label, ip=source_ip, subscriber=subscriber)
        # make sure that the event processor creates a PUSH socket for each output
        event_processor.add_event_origin(origin=source_label, ip=source_ip)
    # start the event processor
    event_processor.start()
    origin_nanny.start()
    threads_tracked.add(event_processor.getName())
    # set up signal handlers
    signal_handler = SignalHandler()
    # start threads
    f = threading.Thread(name='nanny', target=thread_nanny, args=(threads_tracked, signal_handler,))
    f.setDaemon(True)
    f.start()
    try:
        # startup completed
        # back to INFO logging
        log.setLevel(logging.INFO)
        rest_api.secret_key = config.get('flask', 'session_secret_key')
        rest_api.jinja_env.add_extension('jinja2.ext.loopcontrols')
        rest_api.jinja_env.filters.update({
            'is_list': is_list,
        })
        rest_api.run(
            host=config.get('app', 'eth0_ip'),
            port=int(config.get('flask', 'http_port')),
            debug=config.get('flask', 'debug').lower() == 'true',
            use_reloader=False)
    except(KeyboardInterrupt, RuntimeWarning):
        zmq_context.term()
    finally:
        log.info('Removing PID file {}'.format(pidfile))
        os.unlink(pidfile)

    log.info('Exiting with code {}'.format(signal_handler.last_signal))
    # exit using the signal, if any
    sys.exit(signal_handler.last_signal)