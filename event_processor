#!/usr/bin/python
import dateutil.parser
import hashlib
import logging
import logging.handlers

import abc
import collections
import copy
import os
import pytz
import requests
import signal
import simplejson as json
import sqlite3
import sys
import threading
import time
import umsgpack
import zmq

from boto import dynamodb2, sqs
from boto.dynamodb2.table import Table
from boto.dynamodb2.exceptions import ItemNotFound, JSONResponseError, DynamoDBError
from boto.ec2 import cloudwatch
from ConfigParser import ConfigParser
from datetime import datetime, timedelta
from dateutil import tz
from operator import itemgetter, attrgetter
from pprint import pprint
from sets import Set
from pylru import lrucache
from Queue import Queue, Empty
from requests.exceptions import ConnectionError
from resin.exceptions import RequestError
from resin.models.device import Device
from simplejson.scanner import JSONDecodeError
from threading import Thread, Timer
from time import sleep
from umsgpack import UnpackException
from flask import Flask, flash, request, render_template, url_for, redirect, session, escape
from flask.ext.compress import Compress
from zmq.error import ZMQError, ContextTerminated, Again

# unbuffered STDOUT for print
sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)
sys.displayhook = pprint

APP = os.path.basename(__file__)
DIR = os.path.abspath(os.path.dirname(__file__))
# PID file check
pidfile = '/var/run/{}.pid'.format(APP)
if os.path.isfile(pidfile):
    try:
        pid = int(open(pidfile, 'r').read())
        message = '{} already exists containing PID {}.'.format(pidfile, pid)
        proc_path = '/proc/{}/cmdline'.format(pid)
        # existing process?
        if os.path.isfile(proc_path):
            proc_info = open(proc_path, 'r').read()
            if 'python' in proc_info and APP in proc_info:
                print '{} is already running. {}'.format(APP, message)
                sys.exit(1)
    except ValueError:
        message = '{} contains no valid PID.'.format(pidfile)
    print '{} Removing stale PID file.'.format(message)
    # what's in the PID file is stale, destroy it
    os.unlink(pidfile)
# create a new PID file
file(pidfile, 'w').write(str(os.getpid()))

# set the working directory for libraries that assume this (such as PyDrive)
os.chdir(DIR)
log = logging.getLogger(APP)
# do not propagate to console logging
log.propagate = False

config = ConfigParser()
config.optionxform = str
config.read([os.path.join(DIR, '{}.conf'.format(APP))])

DATE_FORMAT = '%Y-%m-%dT%H:%M:%S.%f%z'

rest_api = Flask(APP)
Compress(rest_api)

URL_WORKER_EVENT_PROCESSOR = 'inproc://event-processor'
URL_WORKER_EVENT_LOG = 'inproc://event-log'
zmq_context = zmq.Context()
zmq_context.setsockopt(zmq.LINGER, 0)

interruptable_sleep = threading.Event()

event_processor = None
event_log = None
ngrok_tunnel_url = None


def is_list(value):
    return isinstance(value, list)


def make_payload(timestamp=None, data=None):
    payload = dict()
    if timestamp is None:
        timestamp = datetime.utcnow().replace(tzinfo=pytz.utc)
    elif isinstance(timestamp, float):
        timestamp = datetime.utcfromtimestamp(timestamp).replace(tzinfo=pytz.utc)
    if isinstance(timestamp, datetime):
        timestamp = timestamp.strftime(DATE_FORMAT)
    if not isinstance(timestamp, basestring):
        log.warn('Non-string timestamp {} for payload {}'.format(timestamp, data))
    payload['timestamp'] = timestamp
    if data is not None and len(data) > 0:
        payload['data'] = data
    log.debug(json.dumps(payload))
    return umsgpack.packb(payload)


@rest_api.route('/logging')
def debug():
    log.setLevel(request.args.get('level'))
    return 'OK'


@rest_api.route('/', methods=['GET', 'POST'])
def index():
    meter_history = dict()
    group_disabled = dict()
    device_listing = dict()
    input_labels = dict()
    awol_input_labels = set()
    awol_inputs = event_processor.awol_inputs
    if len(awol_inputs) > 0:
        flash(message='{} devices are unavailable right now.'.format(len(awol_inputs)), category='danger')
    for device_key, device_config in event_processor.input_config.items():
        if device_key in awol_inputs:
            awol_input_labels.add(device_config['device_label'])
        if 'group_name' not in device_config:
            device_listing[device_key] = device_config
        else:
            group_name = device_config['group_name']
            if group_name not in device_listing:
                device_listing[group_name] = dict()
                device_listing[group_name]['grouped_inputs'] = dict()
            device_listing[group_name]['grouped_inputs'][device_key] = device_config
            if group_name not in input_labels:
                input_labels[group_name] = list()
            input_labels[group_name].append(device_config['device_label'])
            # manufacture a device label for the group
            device_listing[group_name]['device_label'] = group_name
            # check for enabled/disabled disparity
            if 'device_disabled' in device_config:
                device_listing[group_name]['device_disabled'] = device_config['device_disabled']
                if group_name not in group_disabled:
                    group_disabled[group_name] = device_config['device_disabled']
                elif group_disabled[group_name] != device_config['device_disabled']:
                    device_listing[group_name]['mixed_disabled'] = True
            elif group_name in group_disabled and group_disabled[group_name]:
                device_listing[group_name]['mixed_disabled'] = True
    if request.method == 'POST':
        if 'panic_button' in request.form:
            log.info('Panic button pressed.')
            processor = zmq_context.socket(zmq.PUSH)
            processor.connect(URL_WORKER_EVENT_PROCESSOR)
            processor.send_pyobj({
                config.get('app', 'device_name'): {
                    'data': {
                        'active_devices': [
                            {
                                'device_key': 'App Panic Button',
                                'device_label': 'Panic Button',
                                'type': 'Panic Button'
                            }
                        ]
                    }
                }
            })
            processor.close()
        elif 'meter_reset' in request.form:
            device_key = request.form['meter_reset']
            reset_value = 0
            if 'meter_reset_value' in device_listing[device_key]:
                reset_value = device_listing[device_key]['meter_reset_value']
            # override with the prompt value if specified
            if 'prompt_val' in request.form:
                try:
                    reset_value = int(request.form['prompt_val'])
                except:
                    # oh well
                    pass
            if 'meter_reset_additive' in device_listing[device_key]:
                meter_value = device_listing[device_key]['meter_value']
                meter_value += reset_value
                # override the reset value
                reset_value = meter_value
            # update both the in memory model and the stored configuration
            device_listing[device_key]['meter_value'] = reset_value
            event_processor.flash_info = False
            event_processor.input_config = (
                device_key,
                {'meter_value': reset_value}
            )
            event_processor.flash_info = True
        elif 'meter_history' in request.form:
            scheme = None
            if 'X-Forwarded-Proto' in request.headers:
                scheme = request.headers['X-Forwarded-Proto']
            return redirect(url_for(
                'show_metrics',
                meter=request.form['meter_history'],
                _external=True,
                _scheme=scheme))
        elif 'device_key' in request.form:
            device_key = request.form['device_key']
            if 'grouped_inputs' not in device_listing[device_key]:
                if 'device_disabled' not in device_listing[device_key]:
                    disable = True
                    device_listing[device_key]['device_disabled'] = True
                else:
                    disable = None
                    del device_listing[device_key]['device_disabled']
                event_processor.flash_info = False
                event_processor.input_config = (
                    device_key,
                    {'device_disabled': disable}
                )
                event_processor.flash_info = True
            else:
                # ambiguity => enabled
                if 'mixed_disabled' in device_listing[device_key]:
                    disable = None
                    # ambiguity resolved
                    del device_listing[device_key]['mixed_disabled']
                    del device_listing[device_key]['device_disabled']
                elif 'device_disabled' not in device_listing[device_key]:
                    disable = True
                    device_listing[device_key]['device_disabled'] = True
                else:
                    disable = None
                    del device_listing[device_key]['device_disabled']
                event_processor.flash_info = False
                for grouped_device_key, grouped_device in device_listing[device_key]['grouped_inputs'].items():
                    grouped_device['device_disabled'] = disable
                    event_processor.input_config = (
                        grouped_device_key,
                        {'device_disabled': disable}
                    )
                event_processor.flash_info = True
        else:
            log.error('No action associated with this request: {}'.format(request.form))
    return render_template('index.html',
                           inputs=device_listing,
                           input_labels=input_labels,
                           awol_inputs=awol_inputs,
                           awol_input_labels=awol_input_labels,
                           meter_history=meter_history)


@rest_api.route('/metrics', methods=['GET', 'POST'])
def show_metrics():
    meter_history_day = list()
    meter_history_week = list()
    meter_history_month = list()
    meter_history_year = list()
    device_key = request.args.get('meter')
    device_config = event_processor.input_config[device_key]
    if device_config['type'] != 'Meter':
        flash('{} is not a meter.'.format(device_key), category='danger')
        return redirect(url_for('index'))
    meter_metric = event_processor._metrics.list_metrics(
        metric_name=device_key,
        namespace=event_processor.metric_namespace)
    if len(meter_metric) > 0:
        end_time = datetime.now().replace(tzinfo=tz.tzlocal())
        for stat_period, stat_interval, time_delta in [
            (60, meter_history_day, timedelta(days=1)),
            (3600, meter_history_week, timedelta(days=7)),
            (86400, meter_history_month, timedelta(days=31)),
            (604800, meter_history_year, timedelta(days=365))
        ]:
            meter_stats = meter_metric[0].query(
                start_time=end_time - time_delta,
                end_time=end_time,
                period=stat_period,
                statistics='Sum')
            log.info('Meter stats for {}::{} for period {}: {}'.format(
                event_processor.metric_namespace,
                device_key,
                stat_period,
                len(meter_stats)))
            for meter_stat in meter_stats:
                time_of_day = meter_stat['Timestamp']
                metric = meter_stat['Sum']
                # TODO: fix units
                stat_interval.append((time_of_day.isoformat(), metric / 1000.0))
    return render_template('metrics.html',
                           metric_title=device_config['device_label'],
                           metric_legend='Units',
                           meter_history_day=sorted(meter_history_day),
                           meter_history_day_title='1-minute sum',
                           meter_history_week=sorted(meter_history_week),
                           meter_history_week_title='1-hour sum',
                           meter_history_month=sorted(meter_history_month),
                           meter_history_month_title='24-hour sum',
                           meter_history_year=sorted(meter_history_year),
                           meter_history_year_title='1-week sum')


@rest_api.route('/event_log', methods=['GET', 'POST'])
def event_log():
    events = dict()
    if request.method == 'GET':
        # TODO: configurable
        events = event_log.get_events(since_ts=int(
            (datetime.utcnow() - timedelta(hours=24)).strftime('%s')
        ))
    return render_template('event_log.html',
                           events=events)


@rest_api.route('/config', methods=['GET', 'POST'])
def show_config():
    return render_template('config.html')


@rest_api.route('/input_config', methods=['GET', 'POST'])
def input_config():
    device_key = None
    if request.method == 'POST':
        device_key = request.form['device_key']
        try:
            customized = False
            to_save = dict()
            if 'group_name' in request.form:
                group_name = request.form['group_name'].strip()
                if len(group_name) > 0:
                    to_save['group_name'] = group_name
                    customized = True
                else:
                    to_save['group_name'] = None
            if device_key in request.form.getlist('info_notify'):
                to_save['info_notify'] = True
                customized = True
            else:
                to_save['info_notify'] = None
            if request.form.get('multi_trigger'):
                to_save['multi_trigger'] = True
                customized = True
            else:
                to_save['multi_trigger'] = None
            if len(request.form['activation_interval']) > 0:
                to_save['activation_interval'] = int(request.form['activation_interval'])
                customized = True
            else:
                to_save['activation_interval'] = None
            if len(request.form['trigger_window']) > 0:
                to_save['trigger_window'] = int(request.form['trigger_window'])
                customized = True
            else:
                to_save['trigger_window'] = None
            if request.form.get('meter_mode', None) and request.form['meter_mode'] != 'default':
                to_save['meter_mode'] = request.form['meter_mode']
                customized = True
            else:
                to_save['meter_mode'] = None
            if request.form.get('meter_low_limit', None) and len(request.form['meter_low_limit']) > 0:
                to_save['meter_low_limit'] = int(request.form['meter_low_limit'])
                customized = True
            else:
                to_save['meter_low_limit'] = None
            if request.form.get('meter_high_limit', None) and len(request.form['meter_high_limit']) > 0:
                to_save['meter_high_limit'] = int(request.form['meter_high_limit'])
                customized = True
            else:
                to_save['meter_high_limit'] = None
            if request.form.get('meter_reset_value', None) and len(request.form['meter_reset_value']) > 0:
                to_save['meter_reset_value'] = int(request.form['meter_reset_value'])
                customized = True
            else:
                to_save['meter_reset_value'] = None
            if device_key in request.form.getlist('meter_reset_additive'):
                to_save['meter_reset_additive'] = True
                customized = True
            else:
                to_save['meter_reset_additive'] = None
            to_save['customized'] = customized
            event_processor.input_config = (
                device_key,
                to_save
            )
        except ValueError as e:
            message = "Cannot update '{}'".format(event_processor.input_config[device_key]['device_label'])
            flash(message='{}: {}'.format(message, e.message), category='danger')
    return render_template('input_config.html',
                           inputs=event_processor.input_config,
                           last_saved_device_key=device_key,
                           default_trigger_window=int(config.get('config', 'default_trigger_window')),
                           default_activation_interval=int(config.get('config', 'default_activation_interval')))


@rest_api.route('/input_link', methods=['GET', 'POST'])
def input_link():
    device_key = None
    if request.method == 'POST':
        device_key = request.form['device_key']
        event_processor.input_config = (
            device_key,
            {'linked_inputs': request.form.getlist('linked_input')}
        )
    return render_template('input_link.html',
                           inputs=event_processor.input_config,
                           last_saved_device_key=device_key)


@rest_api.route('/output_link', methods=['GET', 'POST'])
def output_link():
    device_key = None
    if request.method == 'POST':
        device_key = request.form['device_key']
        event_processor.input_config = (
            device_key,
            {'linked_outputs': request.form.getlist('linked_output')}
        )
    return render_template('output_link.html',
                           inputs=event_processor.input_config,
                           last_saved_device_key=device_key,
                           outputs=event_processor.outputs)


@rest_api.route('/output_config', methods=['GET', 'POST'])
def output_config():
    device_key = None
    if request.method == 'POST':
        device_key = request.form['device_key']
        to_save = dict()
        device_params = request.form['device_params'].strip()
        if len(device_params) > 0:
            to_save['device_params'] = device_params
        else:
            to_save['device_params'] = None
        event_processor.output_config = (
            device_key,
            to_save
        )
    return render_template('output_config.html',
                           outputs=event_processor.output_config,
                           last_saved_device_key=device_key)


class SignalHandler:

    def __init__(self):
        self.last_signal = 0
        signal.signal(signal.SIGTERM, self.terminate)
        signal.signal(signal.SIGHUP, self.hup)

    def hup(self, signum, frame):
        log.warn('Signal {} received.'.format(signum))
        self.last_signal = signum
        if log.getEffectiveLevel() == logging.INFO:
            log.setLevel(logging.DEBUG)
        elif log.getEffectiveLevel() == logging.DEBUG:
            log.setLevel(logging.INFO)

    def terminate(self, signum, frame):
        log.warn('Signal {} received.'.format(signum))
        self.last_signal = signum
        raise RuntimeWarning()


def thread_nanny(threads_tracked, signal_handler):
    while True:
        # kill the nanny now
        if signal_handler.last_signal == signal.SIGTERM:
            break
        threads_alive = Set()
        for thread_info in threading.enumerate():
            if thread_info.isAlive():
                threads_alive.add(thread_info.getName())
        if len(threads_tracked - threads_alive) > 0:
            message = 'A thread has died. Expected threads are [{}], missing is [{}].'.format(threads_tracked, threads_tracked - threads_alive)
            log.error(message)
        sleep(10)


class EventProcessor(Thread):

    def __init__(self):
        super(EventProcessor, self).__init__()
        self.name = self.__class__.__name__
        self.daemon = True

        self.inputs = dict()
        self.outputs = dict()

        self._input_trigger_history = dict()
        self._input_active_history = dict()

        self._origin_ips = dict()
        self._origin_connections = dict()

        self._input_origin = dict()
        self._output_origin = dict()

        self._inputs_by_origin = dict()
        self._outputs_by_origin = dict()

        self._awol_inputs = set()
        self._awol_outputs = set()

        self._db_storage = None
        self._ddb_storage = None

        self._general_config = None
        self._general_config_table = None

        self._input_config = None
        self._input_config_table = None

        self._output_config = None
        self._output_config_table = None

        self._metrics = None
        self.metric_namespace = None

        self.flash_info = True

        self._max_message_validity_seconds = None

        self._device_event_lru = lrucache(100)

        self.socket = zmq_context.socket(zmq.PULL)
        self.socket.bind(URL_WORKER_EVENT_PROCESSOR)

        self.event_log = zmq_context.socket(zmq.PUSH)

    @property
    def general_config(self):
        return self._general_config

    @general_config.setter
    def general_config(self, config_update):
        config_key, updated_config = config_update
        self._general_config = dict()

    @property
    def input_config(self):
        devices = copy.deepcopy(self.inputs)
        devices_config = self._input_config
        for device_key in devices.keys():
            if device_key in devices_config:
                devices[device_key].update(devices_config[device_key])
        return devices

    @input_config.setter
    def input_config(self, config_update):
        device_key, updated_config = config_update
        EventProcessor._update_config(
            device_key=device_key,
            devices=self.inputs,
            device_configs=self._input_config,
            updates=updated_config,
            table_member=self._input_config_table,
            primary_key={'device_key': device_key},
            flash_info=self.flash_info)

    @property
    def output_config(self):
        devices = copy.deepcopy(self.outputs)
        devices_config = self._output_config
        for device_key in devices.keys():
            if device_key in devices_config:
                devices[device_key].update(devices_config[device_key])
        return devices

    @output_config.setter
    def output_config(self, config_update):
        device_key, updated_config = config_update
        EventProcessor._update_config(
            device_key=device_key,
            devices=self.outputs,
            device_configs=self._output_config,
            updates=updated_config,
            table_member=self._output_config_table,
            primary_key={'device_key': device_key},
            flash_info=self.flash_info)

    @property
    def awol_inputs(self):
        return self._awol_inputs

    @staticmethod
    def _update_config(device_key, devices, device_configs, updates, table_member, primary_key, flash_info=True):
        device_label = devices[device_key]['device_label']
        # try to get the existing device config, or create a new mapping
        device_config = dict()
        try:
            device_config = device_configs[device_key]
        except KeyError:
            device_configs[device_key] = device_config
        # these are not explicitly configured, but required
        if 'type' in devices[device_key] and 'type' not in device_configs[device_key]:
            updates['type'] = devices[device_key]['type']
        if 'device_label' in devices[device_key] and 'device_label' not in device_configs[device_key]:
            updates['device_label'] = device_label
        try:
            table_name = table_member.table_name
            log.debug("Updating table '{}'...".format(table_name))
            try:
                log.debug("Item '{}' to be updated with '{}'".format(primary_key, updates))
                table_item = table_member.get_item(**primary_key)
                for key, value in updates.items():
                    if value:
                        table_item[key] = value
                    elif key in table_item:
                        del table_item[key]
                saved = table_item.partial_save()
            except ItemNotFound:
                log.debug("Item '{}' not found in '{}'. Creating new.".format(primary_key, table_name))
                put_args = dict()
                put_args['data'] = dict()
                put_args['data'].update(primary_key)
                put_args['data'].update(updates)
                saved = table_member.put_item(**put_args)
            if saved:
                if flash_info:
                    flash("Updated '{}'".format(device_label))
                for key, value in updates.items():
                    if value:
                        device_config[key] = value
                    elif key in device_config:
                        del device_config[key]
            else:
                if flash_info:
                    flash("'{}' not updated.".format(device_label), category='warning')
        except Exception as e:
            message = "Cannot update '{}'".format(device_label)
            log.exception(message)
            flash(message='{}: {}'.format(message, e.message), category='danger')

    def _update_devices(self, event_origin, device_info):
        devices_updated = 0
        for input_outputs, device_origin, origin_devices, awol_devices, io in [
            (self.inputs, self._input_origin, self._inputs_by_origin, self._awol_inputs, 'inputs'),
            (self.outputs, self._output_origin, self._outputs_by_origin, self._awol_outputs, 'outputs')
        ]:
            for device in device_info[io]:
                try:
                    devices_updated += self._update_device(
                        input_outputs=input_outputs,
                        device_origin=device_origin,
                        origin_devices=origin_devices,
                        event_origin=event_origin,
                        awol_devices=awol_devices,
                        device=device
                    )
                except RuntimeError:
                    log.exception('Bad device @ {}.'.format(device_origin))
        return devices_updated

    def _update_device(self, input_outputs, device_origin, origin_devices, event_origin, awol_devices, device):
        # device_key must always be present
        try:
            device_key = device['device_key']
        except KeyError:
            raise RuntimeError("No device key in {}".format(device))
        # set the device label if that hasn't already been done
        if 'device_label' not in device:
            device['device_label'] = device_key
        # associate the device with this event origin
        if event_origin not in origin_devices:
            origin_devices[event_origin] = set()
        if device_key not in origin_devices[event_origin]:
            origin_devices[event_origin].add(device_key)
        # has this device been awol?
        if device_key in awol_devices:
            log.debug("'{}' is no longer AWOL.".format(device_key))
        awol_devices.discard(device_key)
        # has this device been seen?
        if device_key not in device_origin:
            device_origin[device_key] = event_origin
        elif device_origin[device_key] != event_origin:
            raise RuntimeError("Device with key '{}' is already present at '{}' "
                               "but is also present at '{}' and is ignored.".format(device_key,
                                                                                    device_origin[device_key],
                                                                                    event_origin))
        if device_key not in input_outputs:
            input_outputs[device_key] = device
            return 1
        return 0

    def _process_device_event(self, event_origin, timestamp, active_device_key, active_device):
        if active_device_key in self._input_config and 'linked_outputs' in self._input_config[active_device_key]:
            output_device_keys = self._input_config[active_device_key]['linked_outputs']
            log.debug('{} {} => {}'.format(event_origin, active_device_key, output_device_keys))
            for output_device_key in output_device_keys:
                output_device_activation = dict()
                if output_device_key not in self.outputs:
                    log.warn('{} is linked to an unknown output {}'.format(active_device_key,
                                                                           output_device_key))
                    continue
                if output_device_key not in self._output_origin:
                    log.warn('{} {} => {} but nowhere to route the response.'.format(event_origin,
                                                                                     active_device_key,
                                                                                     output_device_key))
                    continue
                # put the event information into the LRU
                self._device_event_lru[active_device_key] = timestamp
                # build up the device activation history
                activation_history = list()
                for device_key, activation_time in self._device_event_lru.items():
                    # filter out the device being activated
                    if device_key == active_device_key:
                        continue
                    try:
                        input_device_config = self._input_config[device_key]
                    except KeyError:
                        del self._device_event_lru[device_key]
                        continue
                    #TODO: make this configurable
                    if (timestamp - activation_time).seconds > 5*60:
                        continue
                    #TODO: fix
                    try:
                        input_device_label = input_device_config['device_label']
                    except KeyError:
                        log.warn('No label for device {}'.format(active_device_key))
                        input_device_label = active_device_key
                    # list of tuples
                    activation_history.append((
                        input_device_label,
                        (timestamp - activation_time).seconds
                    ))
                # get the event destination
                event_destination = self._output_origin[output_device_key]
                log.info('{} {} => {} {}'.format(
                    event_origin,
                    active_device_key,
                    event_destination,
                    output_device_key))
                # add information about the output device
                output_device_activation.update(self.outputs[output_device_key])
                # add output device configuration, if any
                if output_device_key in self._output_config:
                    output_device_activation.update(self._output_config[output_device_key])
                activation_command = {
                    'trigger_output': output_device_activation,
                    'input_context': active_device,
                    'trigger_history': activation_history,
                }
                if ngrok_tunnel_url:
                    activation_command.update({'callback_url': ngrok_tunnel_url})
                if 'activation_interval' in self._input_config[active_device_key]:
                    activation_command['trigger_duration'] = int(
                        self._input_config[active_device_key]['activation_interval']
                    )
                # dispatch the event
                self._origin_connections[event_destination].send(make_payload(
                    timestamp=timestamp,
                    data=activation_command))
                # add an entry into the event log
                try:
                    input_device_label = self._input_config[active_device_key]['device_label']
                except KeyError:
                    input_device_label = active_device_key
                try:
                    output_device_label = self._output_config[output_device_key]['device_label']
                except KeyError:
                    output_device_label = output_device_key
                self.event_log.send_pyobj({
                    'timestamp': timestamp,
                    'input_device': input_device_label,
                    'output_device': output_device_label,
                })
        else:
            log.warn('{} is not configured or linked to any output: {}'.format(active_device_key, active_device))

    def __setup_config_table(self, table_name, primary_key='device_key'):
        log.info("Loading Dynamo table '{}'...".format(table_name))
        member_table = Table(
            table_name=table_name,
            connection=self._ddb_storage)
        log.info("Reading table '{}'...".format(table_name))
        member = dict()
        for result in member_table.scan():
            device_key = None
            member_config = dict()
            for key, value in result.items():
                if key == primary_key:
                    device_key = value
                else:
                    member_config.update([(key, value)])
            if device_key and len(member_config) > 0:
                member[device_key] = member_config
        return member, member_table

    def add_event_origin(self, origin, ip):
        self._origin_ips[origin] = ip

    def run(self):
        # set up local DB storage
        self._db_storage = sqlite3.connect(database=config.get('db', 'tablespace_path'))
        # connect to AWS services
        self._ddb_storage = dynamodb2.connect_to_region(
            region_name=config.get('aws', 'region'),
            aws_access_key_id=config.get('aws', 'aws_access_key_id'),
            aws_secret_access_key=config.get('aws', 'aws_secret_access_key'))
        # set up metrics
        self._metrics = cloudwatch.connect_to_region(
            region_name=config.get('aws', 'region'),
            aws_access_key_id=config.get('aws', 'aws_access_key_id'),
            aws_secret_access_key=config.get('aws', 'aws_secret_access_key'))
        self.metric_namespace = '{}:{}'.format(config.get('metric', 'namespace'), APP)
        # load configuration data
        self._general_config, self._general_config_table = self.__setup_config_table(
            table_name=config.get('config', 'general_config_table'),
            primary_key='config_key')
        self._input_config, self._input_config_table = self.__setup_config_table(
            table_name=config.get('config', 'input_config_table'))
        self._output_config, self._output_config_table = self.__setup_config_table(
            table_name=config.get('config', 'output_config_table'))
        # connect to event origins
        for origin, ip in self._origin_ips.items():
            connection_string = 'tcp://{}:{}'.format(ip, config.get('zmq', 'pushpull_port'))
            log.info('Device events will be responded to via {} @ {}'.format(origin, connection_string))
            origin_push_socket = zmq_context.socket(zmq.PUSH)
            origin_push_socket.connect(connection_string)
            self._origin_connections[origin] = origin_push_socket
        # event log
        self.event_log.connect(URL_WORKER_EVENT_LOG)
        # informational notifications
        # TODO: move to UI configuration
        self.notify_not_before_time = dateutil.parser.parse(config.get('info_notify', 'not_before_time'))
        self.notify_not_after_time = dateutil.parser.parse(config.get('info_notify', 'not_after_time'))
        # message validity
        self._max_message_validity_seconds = int(config.get('app', 'max_message_validity_seconds'))
        # set up the special input for the panic button
        self._update_device(
            input_outputs=self.inputs,
            device_origin=self._input_origin,
            origin_devices=self._inputs_by_origin,
            event_origin=config.get('app', 'device_name'),
            awol_devices=self._awol_inputs,
            device={
                'device_key': 'App Panic Button',
                'device_label': 'Panic Button',
                'type': 'Panic Button'
            })
        while True:
            try:
                event = self.socket.recv_pyobj()
                log.debug(event)
                if isinstance(event, dict):
                    for event_origin, event_data in event.items():
                        if not isinstance(event_data, dict):
                            log.warn('Ignoring non-dict event format from {}: {} ({})'.format(
                                event_origin, event_data.__class__, event_data))
                            continue
                        timestamp = None
                        if 'timestamp' in event_data:
                            timestamp = dateutil.parser.parse(event_data['timestamp'])
                        else:
                            timestamp = datetime.utcnow().replace(tzinfo=pytz.utc)
                            log_msg = "Message from {} does not include a 'timestamp' so it can't be filtered if it " \
                                      "is stale. Using {}.".format(event_origin, timestamp.strftime(DATE_FORMAT))
                            if 'data' in event_data and 'active_devices' in event_data['data']:
                                log.warn(log_msg)
                            else:
                                log.debug(log_msg)
                        if 'sqs' in event_origin:
                            device_disable = None
                            if 'enable' in event_data:
                                device_disable = False
                            elif 'disable' in event_data:
                                device_disable = True
                            # no action?
                            if device_disable is None:
                                log.warn('No valid action found in SQS message: {}'.format(event_data))
                                continue
                            # this is a fuzzy name that refers to either a group or specific device
                            device_descriptions = None
                            if 'device_description' in event_data:
                                device_descriptions = event_data['device_description']
                            if device_descriptions is None:
                                log.warn('No valid device description found in SQS message: {}'.format(event_data))
                                continue
                            event_processor.flash_info = False
                            for device_description in device_descriptions:
                                for device_key, device_config in self._input_config.items():
                                    device_name_match = False
                                    device_name_test = device_config['device_label'].lower()
                                    # custom skill
                                    if device_name_test.startswith(device_description.lower()):
                                        device_name_match = True
                                    # smart home skill device ID
                                    elif device_name_test.replace(' ','_').replace('(', '#').replace(')', '#') == device_description:
                                        device_name_match = True
                                    elif 'group_name' in device_config and device_config['group_name']:
                                        device_name_test = device_config['group_name'].lower()
                                        if device_name_test.startswith(device_description.lower()):
                                            device_name_match = True
                                        elif device_name_test.replace(' ','_').replace('(', '#').replace(')', '#') == device_description:
                                            device_name_match = True
                                    if device_name_match:
                                        # device matches our description
                                        log.info('Updating device {} based on matching description {}; disable: {}'.format(device_key, device_description, device_disable))
                                        event_processor.input_config = (
                                            device_key,
                                            {'device_disabled': device_disable}
                                        )
                            event_processor.flash_info = True
                        elif 'data' in event_data:
                            if 'stale_heartbeat' in event_data['data']:
                                stale_heartbeat = event_data['data']['stale_heartbeat']
                                device_status = "unknown"
                                if 'device_status' in event_data['data']:
                                    device_status = event_data['data']['device_status']
                                new_awol = 0
                                # check if there are any inputs or outputs configured for this origin
                                for devices, origin_devices, awol_devices in [
                                    (self.inputs, self._inputs_by_origin, self._awol_inputs),
                                    (self.outputs, self._outputs_by_origin, self._awol_outputs)
                                ]:
                                    if event_origin in origin_devices and len(origin_devices[event_origin]) > 0:
                                        log.debug("'{}' last checked-in: {} in an '{}' state.".format(
                                            event_origin,
                                            stale_heartbeat,
                                            device_status.lower()))
                                        for device_key in origin_devices[event_origin]:
                                            if device_key not in awol_devices:
                                                awol_devices.add(device_key)
                                                new_awol += 1
                                if new_awol > 0:
                                    log.warn("{} devices are unavailable because '{}' has gone AWOL ({} devices on {}).".format(
                                        len(awol_devices),
                                        event_origin,
                                        new_awol,
                                        event_origin
                                    ))
                            if 'heartbeat_age' in event_data['data']:
                                heartbeat_age = int(event_data['data']['heartbeat_age'])
                                # show this as a metric
                                self._metrics.put_metric_data(
                                    namespace=self.metric_namespace,
                                    name='Heartbeat Age',
                                    value=heartbeat_age,
                                    dimensions={
                                        'Device': event_origin,
                                    },
                                    timestamp=timestamp,
                                    unit='Seconds')
                            if 'device_info' in event_data['data']:
                                devices_updated = self._update_devices(
                                    event_origin=event_origin,
                                    device_info=event_data['data']['device_info'])
                                if devices_updated > 0:
                                    log.info('{} advertised {} new devices.'.format(event_origin, devices_updated))
                            if 'active_devices' in event_data['data']:
                                for active_device in event_data['data']['active_devices']:
                                    active_device_key = active_device['device_key']
                                    # input known?
                                    if active_device_key not in self._input_config:
                                        log.warn("Input device '{}' is not configured, ignoring.".format(active_device_key))
                                        continue
                                    active_device_config = self._input_config[active_device_key]
                                    # update meter if necessary
                                    if 'type' in active_device and 'meter' in active_device['type'].lower():
                                        meter_update = int(active_device['sample_value'])
                                        # metric dimensions
                                        metric_dimensions = dict()
                                        metric_dimensions['device_type'] = 'meter'
                                        if 'device_label' in active_device:
                                            metric_dimensions['device_label'] = active_device['device_label']
                                        # show this as a metric
                                        self._metrics.put_metric_data(
                                            namespace=self.metric_namespace,
                                            name=active_device_key,
                                            value=meter_update,
                                            dimensions=metric_dimensions,
                                            timestamp=timestamp,
                                            unit='Count')
                                        cur_value = 0
                                        if 'meter_value' in active_device_config:
                                            cur_value = active_device_config['meter_value']
                                        elif 'meter_reset_value' in active_device_config:
                                            cur_value = active_device_config['meter_reset_value']
                                        if 'meter_mode' in active_device_config:
                                            if active_device_config['meter_mode'] == 'incrementing':
                                                cur_value += meter_update
                                            elif active_device_config['meter_mode'] == 'decrementing':
                                                cur_value -= meter_update
                                        self.flash_info = False
                                        event_processor.input_config = (
                                            active_device_key,
                                            {'meter_value': cur_value}
                                        )
                                        # TODO: units
                                        event_detail = "({:.1f} units)".format(int(cur_value) / 1000.0)
                                        if 'event_detail' in active_device:
                                            event_detail = "{} {}".format(active_device['event_detail'], event_detail)
                                        active_device['event_detail'] = event_detail
                                        self.flash_info = True
                                    # message stale?
                                    message_age = datetime.utcnow().replace(tzinfo=pytz.utc) - timestamp
                                    if message_age > timedelta(seconds=self._max_message_validity_seconds):
                                        log.warn('Skipping further processing of {} from {} due to '
                                                 'message age {} exceeding {} seconds.'.format(
                                            active_device_key,
                                            event_origin,
                                            message_age.seconds,
                                            self._max_message_validity_seconds))
                                        continue
                                    # input disabled?
                                    if 'device_disabled' in active_device_config:
                                        continue
                                    # only consider a meter active if the value is out of bounds
                                    if 'type' in active_device and 'meter' in active_device['type'].lower():
                                        meter_value = active_device_config['meter_value']
                                        out_of_range = False
                                        if 'meter_low_limit' in active_device_config:
                                            if meter_value < active_device_config['meter_low_limit']:
                                                out_of_range = True
                                        if 'meter_high_limit' in active_device_config:
                                            if meter_value > active_device_config['meter_high_limit']:
                                                out_of_range = True
                                        if not out_of_range:
                                            continue
                                    # multi-trigger
                                    if 'multi_trigger' in active_device_config:
                                        if 'trigger_window' in active_device_config:
                                            trigger_window = active_device_config['trigger_window']
                                        else:
                                            trigger_window = int(config.get('config', 'default_trigger_window'))
                                        # if not in the trigger history, treat as never activated
                                        if active_device_key not in self._input_trigger_history:
                                            self._input_trigger_history[active_device_key] = time.time()
                                            continue
                                        input_last_triggered = self._input_trigger_history[active_device_key]
                                        # the device must have been considered active within the trigger window
                                        last_triggered = time.time() - input_last_triggered
                                        if last_triggered > trigger_window:
                                            # update the history and continue
                                            self._input_trigger_history[active_device_key] = time.time()
                                            log.debug('Not activating {} because it was triggered '
                                                      'more than {} seconds ago. ({})'.format(active_device_key,
                                                                                              trigger_window,
                                                                                              last_triggered))
                                            continue
                                    # get the event detail for debouncing
                                    event_detail = None
                                    if 'event_detail' in active_device:
                                        event_detail = active_device['event_detail']
                                    # debounce
                                    if active_device_key in self._input_active_history:
                                        # debounce this input
                                        if active_device_key in self._input_config and 'activation_interval' in active_device_config:
                                            activation_interval = active_device_config['activation_interval']
                                        else:
                                            activation_interval = int(config.get('config', 'default_activation_interval'))
                                        input_last_active, last_event_detail = self._input_active_history[active_device_key]
                                        if last_event_detail == event_detail:
                                            last_activated = time.time() - input_last_active
                                            if last_activated < activation_interval:
                                                # device is still considered active
                                                log.debug('Not activating {} ({}) because it was triggered '
                                                          'less than {} seconds ago. ({})'.format(active_device_key,
                                                                                                  last_event_detail,
                                                                                                  activation_interval,
                                                                                                  last_activated))
                                                continue
                                    self._input_active_history[active_device_key] = (time.time(), event_detail)
                                    # active devices are presently assumed to be inputs
                                    self._update_device(
                                        input_outputs=self.inputs,
                                        device_origin=self._input_origin,
                                        origin_devices=self._inputs_by_origin,
                                        event_origin=event_origin,
                                        awol_devices=self._awol_inputs,
                                        device=active_device)
                                    log.debug('{} {}'.format(origin, active_device_key))
                                    # informational event?
                                    #TODO: move to _process_device_event
                                    if 'info_notify' in active_device_config:
                                        # make a future date that is relative (after) now time.
                                        now = datetime.now().replace(tzinfo=tz.tzlocal())
                                        not_before = now.replace(
                                            hour=self.notify_not_before_time.hour,
                                            minute=self.notify_not_before_time.minute,
                                            second=0,
                                            microsecond=0)
                                        not_after = now.replace(
                                            hour=self.notify_not_after_time.hour,
                                            minute=self.notify_not_after_time.minute,
                                            second=0,
                                            microsecond=0)
                                        defer_until = None
                                        if now < not_before:
                                            defer_until = not_before
                                        if now >= not_after:
                                            # the not-before time may not be on the same day
                                            defer_until = not_before + timedelta(days=1)
                                        if defer_until:
                                            # defer the notification
                                            log.info("Deferring notification for '{}' until {}".format(
                                                active_device_key,
                                                defer_until))
                                            continue
                                    self._process_device_event(
                                        event_origin=origin,
                                        timestamp=timestamp,
                                        active_device_key=active_device_key,
                                        active_device=active_device)
            except ContextTerminated:
                self.socket.close()
                for origin_push_socket in self._origin_connections.values():
                    origin_push_socket.close()
                self.event_log.close()
                break
            except Exception:
                log.exception(self.__class__.__name__)
                sleep(1)
                continue


class EventLog(Thread):

    def __init__(self):
        super(EventLog, self).__init__()
        self.name = self.__class__.__name__
        self.daemon = True

        self._ddb_storage = None
        self._event_log_table = None
        self._metrics = None
        self.metric_namespace = None

        self.socket = zmq_context.socket(zmq.PULL)
        self.socket.bind(URL_WORKER_EVENT_LOG)

    def get_events(self, since_ts):
        event_data = self._event_log_table.scan(timestamp__gte=since_ts)
        # extract the event data from the result set
        event_log = list()
        for event in event_data:
            timestamp = event['timestamp']
            event_log.append((
                int(timestamp),
                event['input_device'],
                event['output_device'],
                datetime.utcfromtimestamp(timestamp).replace(tzinfo=pytz.utc).astimezone(tz=tz.tzlocal()).strftime('%c')
            ))
        # reorder based on the timestamp
        return sorted(event_log, key=itemgetter(0, 1, 2), reverse=True)

    def run(self):
        # connect to AWS services
        self._ddb_storage = dynamodb2.connect_to_region(
            region_name=config.get('aws', 'region'),
            aws_access_key_id=config.get('aws', 'aws_access_key_id'),
            aws_secret_access_key=config.get('aws', 'aws_secret_access_key'))
        self._event_log_table = Table(
            table_name='event_log',
            connection=self._ddb_storage)
        # set up metrics
        self._metrics = cloudwatch.connect_to_region(
            region_name=config.get('aws', 'region'),
            aws_access_key_id=config.get('aws', 'aws_access_key_id'),
            aws_secret_access_key=config.get('aws', 'aws_secret_access_key'))
        self.metric_namespace = '{}:{}'.format(config.get('metric', 'namespace'), APP)
        while True:
            try:
                event = self.socket.recv_pyobj()
                log.debug(event)
                timestamp = event['timestamp']
                # work around Python's brain-dead date handling
                unix_timestamp = int((timestamp.replace(tzinfo=None) - datetime(1970, 1, 1)).total_seconds())
                put_args = dict()
                put_args['data'] = dict()
                put_args['data'].update({
                    # pad some millis for the actual insertion time to avoid key conflicts
                    'timestamp': float('{}.{}'.format(unix_timestamp, datetime.now().microsecond)),
                    'input_device': event['input_device'],
                    'output_device': event['output_device'],
                })
                saved = self._event_log_table.put_item(**put_args)
                if not saved:
                    log.warn('Unable to save event log entry: {}'.format(event))
                    continue
                # show this as a metric
                self._metrics.put_metric_data(
                    namespace=self.metric_namespace,
                    name='Device Event',
                    value=1,
                    dimensions={
                        'Device': config.get('app', 'device_name'),
                    },
                    timestamp=timestamp,
                    unit='Count')
            except ContextTerminated:
                self.socket.close()
                break
            except Exception:
                log.exception(self.__class__.__name__)
                continue


class SourceSubscriber(Thread):

    def __init__(self, label, publisher_endpoint):
        super(SourceSubscriber, self).__init__()
        self.name = '{}::{}'.format(self.__class__.__name__, label)
        self.daemon = True

        self._label = label
        self._publisher_endpoint = publisher_endpoint

        self.subscriber = zmq_context.socket(zmq.SUB)
        self.processor = zmq_context.socket(zmq.PUSH)

        self._reconnected = False
        self.last_message = None
        # use half of the tolerated heartbeat value
        self._zmq_poll_period = int(config.get('app', 'max_heartbeat_delay_seconds'))/2

    def run(self):
        log.info('Subscribing to {} @ {}'.format(self._label, self._publisher_endpoint))
        self.subscriber.connect(self._publisher_endpoint)
        self.subscriber.setsockopt(zmq.SUBSCRIBE, "")
        self.processor.connect(URL_WORKER_EVENT_PROCESSOR)
        while True:
            try:
                # timeout in millis
                zmq_events = self.subscriber.poll(timeout=self._zmq_poll_period*1000)
                #TODO: remove nanny
                if zmq_events == 0:
                    # if a single message has been received ever
                    if self.last_message:
                        log.info('{} reconnecting to {} after more than {} seconds of inactivity...'.format(
                            self.name,
                            self._publisher_endpoint,
                            self._zmq_poll_period))
                        try:
                            self.subscriber.close()
                        except ZMQError:
                            log.exception(self.name)
                        self.subscriber = zmq_context.socket(zmq.SUB)
                        self.subscriber.connect(self._publisher_endpoint)
                        self.subscriber.setsockopt(zmq.SUBSCRIBE, "")
                        self._reconnected = True
                    # nothing to do otherwise
                    continue
                try:
                    publisher_event = umsgpack.unpackb(
                        self.subscriber.recv(zmq.NOBLOCK))
                except Again as e:
                    log.debug('{}: {}'.format(self.name, e.message))
                    continue
                # output how long since the last message
                if self.last_message and self._reconnected:
                    log.info('{} resumes events after {} seconds.'.format(
                        self._label,
                        time.time() - self.last_message))
                self.last_message = time.time()
                self._reconnected = False
                self.processor.send_pyobj({self._label: publisher_event})
            except UnpackException:
                log.exception('Cannot unpack message from {}.'.format(self._label))
                continue
            except ContextTerminated:
                self.subscriber.close()
                self.processor.close()
                break
            except ZMQError:
                log.exception(self.name)
                break
            except Exception:
                log.exception(self.name)
                sleep(1)
                continue


class SQSListener(Thread):

    def __init__(self):
        super(SQSListener, self).__init__()
        self.name = self.__class__.__name__
        self.daemon = True

        self.processor = zmq_context.socket(zmq.PUSH)
        self._sqs = None
        self._sqs_queue = None

    def run(self):
        sqs_queue_name = config.get('sqs', 'queue')
        log.info('Listening for control messages on SQS queue {}'.format(sqs_queue_name))
        # set up notifications
        self._sqs = sqs.connect_to_region(
            region_name=config.get('aws', 'region'),
            aws_access_key_id=config.get('aws', 'aws_access_key_id'),
            aws_secret_access_key=config.get('aws', 'aws_secret_access_key'))
        self._sqs_queue = self._sqs.get_queue(queue_name=sqs_queue_name)
        self.processor.connect(URL_WORKER_EVENT_PROCESSOR)
        while True:
            try:
                sqs_message = self._sqs_queue.read(wait_time_seconds=20)
                if sqs_message is None:
                    continue
                # forward for further processing
                message_body = sqs_message.get_body()
                try:
                    self.processor.send_pyobj({'sqs': json.loads(message_body)})
                except JSONDecodeError:
                    log.exception('Unstructured SQS message: {}'.format(message_body))
                # done with the message, at any rate
                self._sqs_queue.delete_message(sqs_message)
            except UnpackException:
                log.exception('Cannot unpack message from {}.'.format(self._label))
                continue
            except ContextTerminated:
                self.processor.close()
                break
            except ZMQError:
                log.exception(self.name)
                break
            except Exception:
                log.exception(self.name)
                sleep(1)
                continue


class OriginNanny(Thread):

    def __init__(self):
        super(OriginNanny, self).__init__()
        self.name = self.__class__.__name__
        self.daemon = True

        self.processor = zmq_context.socket(zmq.PUSH)

        self.origin_subscriber = dict()
        self._max_heartbeat_delay = int(config.get('app', 'max_heartbeat_delay_seconds'))

    def add_origin_subscriber(self, origin, ip, subscriber):
        self.origin_subscriber[origin] = (ip, subscriber)

    def run(self):
        self.processor.connect(URL_WORKER_EVENT_PROCESSOR)
        # warm-up to wait for first volley of heartbeats
        interruptable_sleep.wait(self._max_heartbeat_delay)
        while True:
            try:
                resin_device = Device()
                for origin, (ip, subscriber) in self.origin_subscriber.items():
                    payload = dict()
                    # when last was an event seen by this subscriber
                    last_message = subscriber.last_message
                    heartbeat_age = None
                    if last_message:
                        heartbeat_age = time.time() - subscriber.last_message
                    if last_message is None or heartbeat_age > self._max_heartbeat_delay:
                        device_status = None
                        device_last_seen = None
                        if last_message:
                            last_message = datetime.utcfromtimestamp(last_message).replace(tzinfo=pytz.utc).strftime(DATE_FORMAT)
                        else:
                            last_message = "never"
                        try:
                            for d in resin_device.get_by_name(origin):
                                device_ip = d['ip_address'].split()[0]
                                # this matches the origin by name and IP
                                if device_ip == ip:
                                    device_status = d['status']
                                    device_last_seen = d['last_seen_time']
                                    if device_last_seen is None:
                                        device_last_seen = "unknown"
                        except (RequestError, ConnectionError) as e:
                            log.debug("Unable to fetch device information for Resin device '{}': {}".format(origin,
                                                                                                            e.message))
                        log_message = "'{}' last activity was {}.".format(origin, last_message)
                        if device_status:
                            log.debug("{} Device is {} (last seen: {})".format(log_message,
                                                                               device_status,
                                                                               device_last_seen))
                        else:
                            log.debug(log_message)
                        # used as an out-of-band trigger for something amiss
                        payload['stale_heartbeat'] = last_message
                        if device_status:
                            payload['device_status'] = device_status
                    # do this for each device irrespective of stale or not
                    if heartbeat_age:
                        payload['heartbeat_age'] = heartbeat_age
                    # send out either a stale alert or the heartbeat
                    if len(payload) > 0:
                        self.processor.send_pyobj({origin: {'data': payload}})
            except ContextTerminated:
                self.processor.close()
                break
            # sleep here unless interrupted
            interruptable_sleep.wait(self._max_heartbeat_delay)


class CallbackUrlDiscovery(Thread):

    def __init__(self):
        super(CallbackUrlDiscovery, self).__init__()
        self.name = self.__class__.__name__
        self.daemon = True

        self._discover_url = 'http://127.0.0.1:{}/api/tunnels/{}'.format(
            config.get('ngrok', 'client_api_port'),
            config.get('ngrok', 'tunnel_name'))

    def run(self):
        while True:
            try:
                # sudo update
                global ngrok_tunnel_url
                ngrok_tunnel_url = requests.get(self._discover_url).json()['public_url']
                log.info('External call-back URL is {}'.format(ngrok_tunnel_url))
                break
            except Exception:
                sleep(1)


if __name__ == "__main__":
    # DEBUG logging until startup complete
    log.setLevel(logging.DEBUG)
    syslog_handler = logging.handlers.SysLogHandler(address='/dev/log')
    formatter = logging.Formatter('%(name)s [%(levelname)s] %(message)s')
    syslog_handler.setFormatter(formatter)
    log.addHandler(syslog_handler)
    if sys.stdout.isatty():
        log.warn("Using console logging because there is a tty.")
        stream_handler = logging.StreamHandler(stream=sys.stdout)
        stream_handler.setFormatter(formatter)
        log.addHandler(stream_handler)
    threads_tracked = Set()
    # bind listeners first
    event_log = EventLog()
    event_processor = EventProcessor()
    origin_nanny = OriginNanny()
    # set up subscribers
    subscription_sources = config.get('app', 'subscription_sources').split(',')
    for source in subscription_sources:
        label_ip = source.split(':')
        source_label = label_ip[0]
        source_ip = label_ip[1]
        connection_string = 'tcp://{}:{}'.format(source_ip, config.get('zmq', 'pubsub_port'))
        subscriber = SourceSubscriber(label=source_label, publisher_endpoint=connection_string)
        threads_tracked.add(subscriber.getName())
        subscriber.start()
        # nanny the heartbeats
        origin_nanny.add_origin_subscriber(origin=source_label, ip=source_ip, subscriber=subscriber)
        # make sure that the event processor creates a PUSH socket for each output
        event_processor.add_event_origin(origin=source_label, ip=source_ip)
    # notifications
    sqs_listener = SQSListener()
    # start the event processor
    event_log.start()
    event_processor.start()
    origin_nanny.start()
    threads_tracked.add(event_processor.getName())
    sqs_listener.start()
    threads_tracked.add(sqs_listener.getName())
    # set up signal handlers
    signal_handler = SignalHandler()
    # start threads
    f = threading.Thread(name='nanny', target=thread_nanny, args=(threads_tracked, signal_handler,))
    f.setDaemon(True)
    f.start()
    try:
        # startup completed
        # back to INFO logging
        log.setLevel(logging.INFO)
        # discover callback URL
        CallbackUrlDiscovery().start()
        # start frontend
        rest_api.secret_key = config.get('flask', 'session_secret_key')
        rest_api.jinja_env.add_extension('jinja2.ext.loopcontrols')
        rest_api.jinja_env.filters.update({
            'is_list': is_list,
        })
        rest_api.run(
            threaded=True,
            # listen on all interfaces
            host='0.0.0.0',
            port=int(config.get('flask', 'http_port')),
            debug=config.get('flask', 'debug').lower() == 'true',
            use_reloader=False)
    except(KeyboardInterrupt, RuntimeWarning):
        # bring any threads out of their Pythonic coma
        interruptable_sleep.set()
        zmq_context.term()
    finally:
        log.info('Removing PID file {}'.format(pidfile))
        os.unlink(pidfile)

    log.info('Exiting with code {}'.format(signal_handler.last_signal))
    # exit using the signal, if any
    sys.exit(signal_handler.last_signal)
