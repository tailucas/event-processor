#!/usr/bin/env python
import dateutil.parser
import logging
import logging.handlers

import boto3
import copy
import os
import pytz
import requests
import signal
import simplejson as json
import sqlite3
import sys
import threading
import time
import umsgpack
import zmq

from AWSIoTPythonSDK.MQTTLib import AWSIoTMQTTClient

from boto3.dynamodb.conditions import Attr
from bs4 import BeautifulSoup
from configparser import ConfigParser
from datetime import datetime, timedelta
from dateutil import tz
from decimal import Decimal
from io import BytesIO
from operator import itemgetter
# noinspection PyDeprecation
from pylru import lrucache
from requests.exceptions import ConnectionError
from raven.contrib.flask import Sentry
from resin.exceptions import RequestError
from resin.models.device import Device
from simplejson.scanner import JSONDecodeError
from socket import gaierror
from telegram import Bot as TelegramBot, \
    InlineQueryResultArticle, InputTextMessageContent, \
    ParseMode
from telegram.error import TelegramError, \
    Unauthorized, \
    BadRequest, \
    TimedOut, \
    ChatMigrated, \
    NetworkError
from telegram.ext import Updater as TelegramUpdater, \
    CommandHandler as TelegramCommandHandler, \
    MessageHandler as TelegramMessageHandler, \
    Filters as TelegramFilters, \
    InlineQueryHandler as TelegramInlineHandler
from telegram.utils.helpers import escape_markdown
from telegram.utils.request import TimedOut
from threading import Thread
from time import sleep
from umsgpack import UnpackException
from urllib.parse import urlparse
from uuid import uuid4
from flask import Flask, g, flash, request, render_template, url_for, redirect
from flask_compress import Compress
from werkzeug.serving import make_server
from zmq.error import ZMQError, ContextTerminated, Again


APP = os.path.basename(__file__)
if sys.stdout.isatty() and os.system('systemctl status app') == 0:
    print("{} is already running. Use 'systemctl stop app' to stop first.".format(APP))
    sys.exit(1)

# set the working directory for libraries that assume this (such as PyDrive)
DIR = os.path.abspath(os.path.dirname(__file__))
os.chdir(DIR)
log = logging.getLogger(APP)
# do not propagate to console logging
log.propagate = False

config = ConfigParser()
config.optionxform = str
config.read([os.path.join(DIR, '{}.conf'.format(APP))])

DATE_FORMAT = '%Y-%m-%dT%H:%M:%S.%f%z'

rest_api = Flask(APP)
Compress(rest_api)

URL_WORKER_EVENT_PROCESSOR = 'inproc://event-processor'
URL_WORKER_EVENT_LOG = 'inproc://event-log'
URL_WORKER_TELEGRAM_BOT = 'inproc://telegram-bot'
zmq_context = zmq.Context()
zmq_context.setsockopt(zmq.LINGER, 0)

interruptable_sleep = threading.Event()

event_processor = None
event_log = None
ngrok_tunnel_url = None
ngrok_tunnel_url_with_bauth = None

sentry = Sentry()


def is_list(value):
    return isinstance(value, list)


def make_timestamp(timestamp=None, make_string=False):
    if timestamp is None:
        timestamp = datetime.utcnow()
    elif isinstance(timestamp, float) or isinstance(timestamp, int):
        timestamp = datetime.utcfromtimestamp(timestamp)
    elif isinstance(timestamp, str):
        timestamp = dateutil.parser.parse(timestamp)
    if make_string:
        return timestamp.strftime(DATE_FORMAT)
    # not naive datetime
    return timestamp.replace(tzinfo=pytz.utc)


def parse_datetime(value=None, as_tz=pytz.utc):
    timestamp = datetime.utcnow().replace(tzinfo=as_tz)
    if value is None:
        return timestamp
    if isinstance(value, str):
        try:
            timestamp = dateutil.parser.parse(value)
            log.debug('Parsed timestamp is {}'.format(timestamp))
        except ValueError:
            log.exception("Cannot parse date-like string {}. Defaulting to '{}'.".format(value, timestamp))
    elif isinstance(value, datetime):
        timestamp = value
    else:
        raise RuntimeError("Unknown date/time type: '{}'".format(value))
    # ensure that some timezone information is present
    if timestamp.tzinfo is None:
        local_tz = tz.tzlocal()
        log.debug('{}: setting to local time {}'.format(timestamp, local_tz))
        # we use the default specific to the physical locality of the devices
        timestamp = timestamp.replace(tzinfo=local_tz)
    if timestamp.tzinfo != as_tz:
        # now adjust to requested TZ
        log.debug('{}: setting to {} from {}'.format(timestamp, as_tz, timestamp.tzinfo))
        timestamp = timestamp.astimezone(tz=as_tz)
    return timestamp


def make_payload(timestamp=None, data=None):
    payload = {'timestamp': make_timestamp(timestamp, True)}
    if data is not None and len(data) > 0:
        payload['data'] = data
    log.debug(json.dumps(payload))
    return umsgpack.packb(payload)


@rest_api.route('/logging')
def debug():
    log.setLevel(request.args.get('level'))
    return 'OK'


@rest_api.errorhandler(500)
def internal_server_error():
    return render_template('error.html',
                           event_id=g.sentry_event_id,
                           public_dsn=sentry.client.get_public_dsn('https')
                           )


@rest_api.route('/', methods=['GET', 'POST'])
def index():
    meter_history = {}
    group_disabled = {}
    device_listing = {}
    input_labels = {}
    awol_input_labels = set()
    awol_inputs = event_processor.awol_inputs
    if len(awol_inputs) > 0:
        flash(message='{} devices are unavailable right now.'.format(len(awol_inputs)), category='danger')
    for device_key, device_config in list(event_processor.input_config.items()):
        if device_key in awol_inputs:
            awol_input_labels.add(device_config['device_label'])
        if 'group_name' not in device_config:
            device_listing[device_key] = device_config
        else:
            group_name = device_config['group_name']
            if group_name not in device_listing:
                device_listing[group_name] = {}
                device_listing[group_name]['grouped_inputs'] = {}
            device_listing[group_name]['grouped_inputs'][device_key] = device_config
            if group_name not in input_labels:
                input_labels[group_name] = []
            input_labels[group_name].append(device_config['device_label'])
            # manufacture a device label for the group
            device_listing[group_name]['device_label'] = group_name
            # check for enabled/disabled disparity
            if 'device_disabled' in device_config:
                device_listing[group_name]['device_disabled'] = device_config['device_disabled']
                if group_name not in group_disabled:
                    group_disabled[group_name] = device_config['device_disabled']
                elif group_disabled[group_name] != device_config['device_disabled']:
                    device_listing[group_name]['mixed_disabled'] = True
            elif group_name in group_disabled and group_disabled[group_name]:
                device_listing[group_name]['mixed_disabled'] = True
    if request.method == 'POST':
        if 'panic_button' in request.form:
            log.info('Panic button pressed.')
            processor = zmq_context.socket(zmq.PUSH)
            processor.connect(URL_WORKER_EVENT_PROCESSOR)
            processor.send_pyobj({
                config.get('app', 'device_name'): {
                    'data': {
                        'active_devices': [
                            {
                                'device_key': 'App Panic Button',
                                'device_label': 'Panic Button',
                                'type': 'Panic Button'
                            }
                        ]
                    }
                }
            })
            processor.close()
        elif 'meter_reset' in request.form:
            device_key = request.form['meter_reset']
            reset_value = 0
            if 'meter_reset_value' in device_listing[device_key]:
                reset_value = device_listing[device_key]['meter_reset_value']
            # override with the prompt value if specified
            if 'prompt_val' in request.form:
                try:
                    reset_value = int(request.form['prompt_val'])
                except ValueError:
                    # oh well
                    pass
            if 'meter_reset_additive' in device_listing[device_key]:
                iot_message = {'adjust_register': reset_value}
                meter_value = device_listing[device_key]['meter_value']
                meter_value += reset_value
                # override the reset value
                reset_value = meter_value
            else:
                iot_message = {'set_register': reset_value}
            # update the in memory model
            device_listing[device_key]['meter_value'] = reset_value
            # send IoT message
            event_processor.iot.connect()
            event_processor.iot.publish(config.get('iot', 'topic_pub_meter'), json.dumps(iot_message), 0)
            event_processor.iot.disconnect()
        elif 'meter_history' in request.form:
            scheme = None
            if 'X-Forwarded-Proto' in request.headers:
                scheme = request.headers['X-Forwarded-Proto']
            return redirect(url_for(
                'show_metrics',
                meter=request.form['meter_history'],
                _external=True,
                _scheme=scheme))
        elif 'device_key' in request.form:
            device_key = request.form['device_key']
            if 'grouped_inputs' not in device_listing[device_key]:
                if 'device_disabled' not in device_listing[device_key]:
                    disable = True
                    device_listing[device_key]['device_disabled'] = True
                else:
                    disable = None
                    del device_listing[device_key]['device_disabled']
                event_processor.flash_info = False
                event_processor.input_config = (
                    device_key,
                    {'device_disabled': disable}
                )
                event_processor.flash_info = True
            else:
                # ambiguity => enabled
                if 'mixed_disabled' in device_listing[device_key]:
                    disable = None
                    # ambiguity resolved
                    del device_listing[device_key]['mixed_disabled']
                    del device_listing[device_key]['device_disabled']
                elif 'device_disabled' not in device_listing[device_key]:
                    disable = True
                    device_listing[device_key]['device_disabled'] = True
                else:
                    disable = None
                    del device_listing[device_key]['device_disabled']
                event_processor.flash_info = False
                for grouped_device_key, grouped_device in list(device_listing[device_key]['grouped_inputs'].items()):
                    grouped_device['device_disabled'] = disable
                    event_processor.input_config = (
                        grouped_device_key,
                        {'device_disabled': disable}
                    )
                event_processor.flash_info = True
        else:
            log.error('No action associated with this request: {}'.format(request.form))
    return render_template('index.html',
                           inputs=device_listing,
                           input_labels=input_labels,
                           awol_inputs=awol_inputs,
                           awol_input_labels=awol_input_labels,
                           meter_history=meter_history)


@rest_api.route('/metrics', methods=['GET', 'POST'])
def show_metrics():
    meter_history_day = []
    meter_history_week = []
    meter_history_month = []
    meter_history_year = []
    device_key = request.args.get('meter')
    device_config = event_processor.input_config[device_key]
    if device_config['type'] != 'meter':
        flash('{} is not a meter.'.format(device_key), category='danger')
        return redirect(url_for('index'))
    metric_namespace = 'automation'
    # TODO: get all meter metrics by dimension
    metric_name = device_config['device_label'] + ' Metered'
    end_time = make_timestamp()
    for stat_period, stat_interval, time_delta in [
        (60, meter_history_day, timedelta(days=1)),
        (3600, meter_history_week, timedelta(days=7)),
        (86400, meter_history_month, timedelta(days=31)),
        (604800, meter_history_year, timedelta(days=365))
    ]:
        meter_stats = event_processor.metrics.get_metric_statistics(
            Namespace=metric_namespace,
            MetricName=metric_name,
            Dimensions=[
                {
                    'Name': 'device_type',
                    'Value': device_config['type']
                },
            ],
            StartTime=end_time - time_delta,
            EndTime=end_time,
            Period=stat_period,
            Statistics=['Sum'])['Datapoints']
        log.info('Meter stats for {}::{} for period {}: {}'.format(
            metric_namespace,
            metric_name,
            stat_period,
            len(meter_stats)))
        for meter_stat in meter_stats:
            meter_reading_unit_factor = 1
            if 'meter_reading_unit_factor' in device_config:
                meter_reading_unit_factor = device_config['meter_reading_unit_factor']
            stat_interval.append((
                make_timestamp(meter_stat['Timestamp']).astimezone(tz=tz.tzlocal()).isoformat(),
                meter_stat['Sum'] / float(meter_reading_unit_factor)
            ))
    unit_name = 'Units'
    if 'meter_reading_unit' in device_config:
        unit_name = device_config['meter_reading_unit']
    return render_template('metrics.html',
                           metric_title=device_config['device_label'],
                           metric_legend=unit_name,
                           meter_history_day=sorted(meter_history_day),
                           meter_history_day_title='1-minute sum',
                           meter_history_week=sorted(meter_history_week),
                           meter_history_week_title='1-hour sum',
                           meter_history_month=sorted(meter_history_month),
                           meter_history_month_title='24-hour sum',
                           meter_history_year=sorted(meter_history_year),
                           meter_history_year_title='1-week sum')


@rest_api.route('/event_log', methods=['GET', 'POST'])
def event_log():
    events = {}
    if request.method == 'GET':
        # TODO: configurable
        events = event_log.get_events(since_ts=int(
            (datetime.utcnow() - timedelta(hours=24)).strftime('%s')
        ))
    return render_template('event_log.html',
                           events=events)


@rest_api.route('/config', methods=['GET', 'POST'])
def show_config():
    return render_template('config.html')


@rest_api.route('/input_config', methods=['GET', 'POST'])
def input_config():
    device_key = None
    if request.method == 'POST':
        device_key = request.form['device_key']
        try:
            customized = False
            to_save = {}
            if 'group_name' in request.form:
                group_name = request.form['group_name'].strip()
                if len(group_name) > 0:
                    to_save['group_name'] = group_name
                    customized = True
                else:
                    to_save['group_name'] = None
            if device_key in request.form.getlist('info_notify'):
                to_save['info_notify'] = True
                customized = True
            else:
                to_save['info_notify'] = None
            if request.form.get('multi_trigger'):
                to_save['multi_trigger'] = True
                customized = True
            else:
                to_save['multi_trigger'] = None
            if len(request.form['activation_interval']) > 0:
                to_save['activation_interval'] = int(request.form['activation_interval'])
                customized = True
            else:
                to_save['activation_interval'] = None
            if len(request.form['trigger_window']) > 0:
                to_save['trigger_window'] = int(request.form['trigger_window'])
                customized = True
            else:
                to_save['trigger_window'] = None
            if request.form.get('meter_low_limit', None) and len(request.form['meter_low_limit']) > 0:
                to_save['meter_low_limit'] = int(request.form['meter_low_limit'])
                customized = True
            else:
                to_save['meter_low_limit'] = None
            if request.form.get('meter_high_limit', None) and len(request.form['meter_high_limit']) > 0:
                to_save['meter_high_limit'] = int(request.form['meter_high_limit'])
                customized = True
            else:
                to_save['meter_high_limit'] = None
            if request.form.get('meter_reset_value', None) and len(request.form['meter_reset_value']) > 0:
                to_save['meter_reset_value'] = int(request.form['meter_reset_value'])
                customized = True
            else:
                to_save['meter_reset_value'] = None
            if device_key in request.form.getlist('meter_reset_additive'):
                to_save['meter_reset_additive'] = True
                customized = True
            else:
                to_save['meter_reset_additive'] = None
            if request.form.get('meter_iot_topic', None) and len(request.form['meter_iot_topic'].strip()) > 0:
                to_save['meter_iot_topic'] = request.form['meter_iot_topic'].strip()
                customized = True
            else:
                to_save['meter_iot_topic'] = None
            if request.form.get('meter_reading_unit', None) and len(request.form['meter_reading_unit'].strip()) > 0:
                to_save['meter_reading_unit'] = request.form['meter_reading_unit'].strip()
                customized = True
            else:
                to_save['meter_reading_unit'] = None
            if request.form.get('meter_reading_unit_factor', None) and \
                    len(request.form['meter_reading_unit_factor']) > 0:
                meter_reading_unit_factor = int(request.form['meter_reading_unit_factor'])
                if 1 <= meter_reading_unit_factor <= 1000000000 and (meter_reading_unit_factor % 10 == 0):
                    to_save['meter_reading_unit_factor'] = meter_reading_unit_factor
                    customized = True
            else:
                to_save['meter_reading_unit_factor'] = None
            if request.form.get('meter_reading_unit_precision', None) and len(
                    request.form['meter_reading_unit_precision']) > 0:
                meter_reading_unit_precision = int(request.form['meter_reading_unit_precision'])
                if 1 <= meter_reading_unit_precision <= 9:
                    to_save['meter_reading_unit_precision'] = meter_reading_unit_precision
                    customized = True
            else:
                to_save['meter_reading_unit_precision'] = None
            to_save['customized'] = customized
            event_processor.input_config = (
                device_key,
                to_save
            )
        except ValueError as e:
            exception_msg = "Cannot update '{}'".format(event_processor.input_config[device_key]['device_label'])
            flash(message='{}: {}'.format(exception_msg, str(e)), category='danger')
    return render_template('input_config.html',
                           inputs=event_processor.input_config,
                           last_saved_device_key=device_key,
                           default_trigger_window=int(config.get('config', 'default_trigger_window')),
                           default_activation_interval=int(config.get('config', 'default_activation_interval')))


@rest_api.route('/input_link', methods=['GET', 'POST'])
def input_link():
    device_key = None
    if request.method == 'POST':
        device_key = request.form['device_key']
        event_processor.input_config = (
            device_key,
            {'linked_inputs': request.form.getlist('linked_input')}
        )
    return render_template('input_link.html',
                           inputs=event_processor.input_config,
                           last_saved_device_key=device_key)


@rest_api.route('/output_link', methods=['GET', 'POST'])
def output_link():
    device_key = None
    if request.method == 'POST':
        device_key = request.form['device_key']
        event_processor.input_config = (
            device_key,
            {'linked_outputs': request.form.getlist('linked_output')}
        )
    return render_template('output_link.html',
                           inputs=event_processor.input_config,
                           last_saved_device_key=device_key,
                           outputs=event_processor.outputs)


@rest_api.route('/output_config', methods=['GET', 'POST'])
def output_config():
    device_key = None
    if request.method == 'POST':
        device_key = request.form['device_key']
        to_save = {}
        device_params = request.form['device_params'].strip()
        if len(device_params) > 0:
            to_save['device_params'] = device_params
        else:
            to_save['device_params'] = None
        event_processor.output_config = (
            device_key,
            to_save
        )
    return render_template('output_config.html',
                           outputs=event_processor.output_config,
                           last_saved_device_key=device_key)


def telegram_bot_echo(bot, update):
    try:
        authorized_users = config.get('telegram', 'authorized_users').split(',')
        if str(update.effective_user.id) not in authorized_users:
            log.warning('Unauthorized message {}'.format(str(update)))
            return

        log.info('Telegram Bot {} got message {} (chat ID: {}).'.format(bot.username,
                                                                        update.effective_message.text,
                                                                        update.effective_message.chat_id))

        group_info = bot.get_chat(chat_id=config.getint('telegram', 'chat_room_id'))
        bot_response = "I am in the [{}]({}) group.".format(group_info.title, group_info.invite_link)
        dashboard_link = '[Dashboard]({})'.format(ngrok_tunnel_url)
        bot.send_message(chat_id=update.effective_message.chat_id,
                         text=bot_response + "\n" + dashboard_link,
                         parse_mode='Markdown')
    except Exception:
        log.exception('bot handler')
        sentry.captureException()


def telegram_bot_cmd(bot, update, args):
    try:
        authorized_users = config.get('telegram', 'authorized_users').split(',')
        if str(update.effective_user.id) not in authorized_users:
            log.warning('Unauthorized message {}'.format(str(update)))
            return

        log.info('Telegram Bot {} got command {} with args {} (chat ID: {}).'.format(bot.username,
                                                                                     update.effective_message.text,
                                                                                     str(args),
                                                                                     update.effective_message.chat_id))
        bot.send_message(chat_id=update.effective_message.chat_id,
                         text='[Dashboard]({})'.format(ngrok_tunnel_url_with_bauth),
                         parse_mode='Markdown')
        # status update
        if update.effective_message.text.startswith('/report'):
            processor = zmq_context.socket(zmq.PUSH)
            processor.connect(URL_WORKER_EVENT_PROCESSOR)
            processor.send_pyobj({
                config.get('app', 'device_name'): {
                    'data': {
                        'active_devices': [
                            {
                                'device_key': 'App Dash Button',
                                'device_label': 'Dash Button',
                                'type': 'Dash Button'
                            }
                        ]
                    }
                }
            })
            processor.close()
    except Exception:
        log.exception('bot handler')
        sentry.captureException()


def telegram_bot_inline(bot, update):
    try:
        authorized_users = config.get('telegram', 'authorized_users').split(',')
        if str(update.inline_query.from_user.id) not in authorized_users:
            log.warning('Unauthorized message {}'.format(str(update)))
            return

        log.info('Telegram Bot {} got inline query {} from {} {} (location: {}).'.format(bot.username,
                                                                                         update.inline_query.query,
                                                                                         update.inline_query.from_user.first_name,
                                                                                         update.inline_query.from_user.last_name,
                                                                                         update.inline_query.location))

        query = update.inline_query.query
        if not query:
            return
        results = [
            InlineQueryResultArticle(
                id=uuid4(),
                title="Dashboard",
                url=ngrok_tunnel_url,
                input_message_content=InputTextMessageContent(
                    query.upper())),
            InlineQueryResultArticle(
                id=uuid4(),
                title="Report",
                input_message_content=InputTextMessageContent(
                    "*{}*".format(escape_markdown(query)),
                    parse_mode=ParseMode.MARKDOWN)),
            InlineQueryResultArticle(
                id=uuid4(),
                title="Panic",
                input_message_content=InputTextMessageContent(
                    "_{}_".format(escape_markdown(query)),
                    parse_mode=ParseMode.MARKDOWN))]
        update.inline_query.answer(results)
    except Exception:
        log.exception('bot handler')
        sentry.captureException()


def telegram_error_handler(bot, update, error):
    try:
        raise error
    except NetworkError as e:
        log.warning('Problem with {} network {}: {}'.format(bot, update, e.message))
    except TelegramError as e:
        log.warning('Problem with {} processing {}: {}'.format(bot, update, e.message))
    except Exception:
        log.exception('bot')
        sentry.captureException()


# noinspection PyUnusedLocal
class SignalHandler:

    def __init__(self):
        self.last_signal = 0
        signal.signal(signal.SIGTERM, self.terminate)
        signal.signal(signal.SIGHUP, self.hup)

    def hup(self, signum, frame):
        log.warning('Signal {} received.'.format(signum))
        self.last_signal = signum
        if log.getEffectiveLevel() == logging.INFO:
            log.setLevel(logging.DEBUG)
        elif log.getEffectiveLevel() == logging.DEBUG:
            log.setLevel(logging.INFO)

    def terminate(self, signum, frame):
        log.warning('Signal {} received.'.format(signum))
        self.last_signal = signum
        raise RuntimeWarning()


# noinspection PyShadowingNames
def thread_nanny(threads_tracked, signal_handler):
    while True:
        # kill the nanny now
        if signal_handler.last_signal == signal.SIGTERM:
            break
        threads_alive = set()
        for thread_info in threading.enumerate():
            if thread_info.isAlive():
                threads_alive.add(thread_info.getName())
        if len(threads_tracked - threads_alive) > 0:
            error_msg = 'A thread has died. Expected threads are [{}], ' \
                        'missing is [{}].'.format(threads_tracked, threads_tracked - threads_alive)
            log.error(error_msg)
            os._exit(1)
        sleep(10)


class EventProcessor(Thread):

    def __init__(self):
        super(EventProcessor, self).__init__(name=self.__class__.__name__)
        self.daemon = True

        self.inputs = {}
        self.outputs = {}

        self._input_trigger_history = {}
        self._input_active_history = {}

        self._origin_ips = {}
        self._origin_connections = {}

        self._input_origin = {}
        self._output_origin = {}

        self._inputs_by_origin = {}
        self._outputs_by_origin = {}

        self._awol_inputs = set()
        self._awol_outputs = set()

        self._db_storage = None
        self._ddb_storage = None

        self._general_config = None
        self._general_config_table = None

        self._input_config = None
        self._input_config_table = None

        self._output_config = None
        self._output_config_table = None

        self.metrics = None
        self.metric_namespace = None

        self.flash_info = True

        self._max_message_validity_seconds = None

        self._device_event_lru = lrucache(100)

        self.socket = zmq_context.socket(zmq.PULL)
        self.socket.bind(URL_WORKER_EVENT_PROCESSOR)

        self.event_log = zmq_context.socket(zmq.PUSH)

        self.bot = zmq_context.socket(zmq.PUSH)

        self.iot = AWSIoTMQTTClient(APP, useWebsocket=True)
        self.iot.configureEndpoint(
            config.get('iot', 'endpoint'),
            443)
        self.iot.configureCredentials(config.get('iot', 'root_ca_path'))
        self.iot.configureOfflinePublishQueueing(0)
        self.iot.configureDrainingFrequency(2)
        self.iot.configureConnectDisconnectTimeout(10)
        self.iot.configureMQTTOperationTimeout(5)

    @property
    def general_config(self):
        return self._general_config

    @general_config.setter
    def general_config(self, config_update):
        # noinspection PyUnusedLocal
        config_key, updated_config = config_update
        self._general_config = {}

    @property
    def input_config(self):
        devices = copy.deepcopy(self.inputs)
        devices_config = self._input_config
        for device_key in list(devices.keys()):
            if device_key in devices_config:
                devices[device_key].update(devices_config[device_key])
        return devices

    @input_config.setter
    def input_config(self, config_update):
        device_key, updated_config = config_update
        EventProcessor._update_config(
            device_key=device_key,
            devices=self.inputs,
            device_configs=self._input_config,
            updates=updated_config,
            table_member=self._input_config_table,
            primary_key={'device_key': device_key},
            flash_info=self.flash_info)

    @property
    def output_config(self):
        devices = copy.deepcopy(self.outputs)
        devices_config = self._output_config
        for device_key in list(devices.keys()):
            if device_key in devices_config:
                devices[device_key].update(devices_config[device_key])
        return devices

    @output_config.setter
    def output_config(self, config_update):
        device_key, updated_config = config_update
        EventProcessor._update_config(
            device_key=device_key,
            devices=self.outputs,
            device_configs=self._output_config,
            updates=updated_config,
            table_member=self._output_config_table,
            primary_key={'device_key': device_key},
            flash_info=self.flash_info)

    @property
    def awol_inputs(self):
        return self._awol_inputs

    @staticmethod
    def _update_config(device_key, devices, device_configs, updates, table_member, primary_key, flash_info=True):
        device_label = devices[device_key]['device_label']
        # try to get the existing device config, or create a new mapping
        device_config = {}
        try:
            device_config = device_configs[device_key]
        except KeyError:
            device_configs[device_key] = device_config
        # these are not explicitly configured, but required
        if 'type' in devices[device_key] and 'type' not in device_configs[device_key]:
            updates['type'] = devices[device_key]['type']
        if 'device_label' in devices[device_key] and 'device_label' not in device_configs[device_key]:
            updates['device_label'] = device_label
        try:
            table_name = table_member.table_name
            log.debug("Updating table '{}'...".format(table_name))
            saved = False
            log.debug("Item '{}' to be updated with '{}'".format(primary_key, updates))
            # why no partial_update boto3?
            ddb_set_expression = []
            ddb_remove_expression = []
            attribute_values = {}
            attribute_names = {}
            val_counter = 1
            for key, value in list(updates.items()):
                attribute_holder = ':{}'.format('val'+str(val_counter))
                # reserved word
                if value:
                    ddb_key = '#'+key
                    ddb_set_expression.append('{} = {}'.format(ddb_key, attribute_holder))
                    attribute_names[ddb_key] = key
                    if value is True:
                        attribute_values[attribute_holder] = 1
                    else:
                        attribute_values[attribute_holder] = value
                    val_counter += 1
                else:
                    ddb_remove_expression.append('{}'.format(key))
            ddb_set = ''
            ddb_remove = ''
            if len(ddb_set_expression) > 0:
                ddb_set = 'SET {}'.format(', '.join(ddb_set_expression))
            if len(ddb_remove_expression) > 0:
                ddb_remove = 'REMOVE {}'.format(', '.join(ddb_remove_expression))
            if len(attribute_values) == 0:
                attribute_values = None
            if len(attribute_names) == 0:
                attribute_names = None
            ddb_expression = ''
            if len(ddb_set) > 0:
                ddb_expression = ddb_set
            if len(ddb_remove) > 0:
                if len(ddb_set) > 0:
                    ddb_expression += ' '
                ddb_expression += ddb_remove
            if len(ddb_expression) > 0:
                log.debug('Updating table {} ({}) with {} using {} and {}.'.format(table_name,
                                                                                   primary_key,
                                                                                   ddb_expression,
                                                                                   attribute_names,
                                                                                   attribute_values))
                update_args = {
                    'Key': primary_key,
                    'UpdateExpression': ddb_expression,
                    'ReturnValues': "UPDATED_NEW"
                }
                if attribute_values:
                    update_args.update({'ExpressionAttributeValues': attribute_values})
                if attribute_names:
                    update_args.update({'ExpressionAttributeNames': attribute_names})
                saved = table_member.update_item(**update_args)
            if saved:
                log.debug('Updated {} with {}'.format(table_name, str(saved)))
                if flash_info:
                    flash("Updated '{}'".format(device_label))
                for key, value in list(updates.items()):
                    if value:
                        device_config[key] = value
                    elif key in device_config:
                        del device_config[key]
            else:
                if flash_info:
                    flash("'{}' not updated.".format(device_label), category='warning')
        except Exception as e:
            exception_message = "Cannot update '{}'".format(device_label)
            log.exception(exception_message)
            sentry.captureException()
            flash(message='{}: {}'.format(exception_message, str(e)), category='danger')

    def _update_devices(self, event_origin, device_info):
        devices_updated = 0
        for input_outputs, device_origin, origin_devices, awol_devices, io in [
            (self.inputs, self._input_origin, self._inputs_by_origin, self._awol_inputs, 'inputs'),
            (self.outputs, self._output_origin, self._outputs_by_origin, self._awol_outputs, 'outputs')
        ]:
            # next if only input or output
            if io not in device_info:
                continue
            for device in device_info[io]:
                try:
                    devices_updated += self._update_device(
                        input_outputs=input_outputs,
                        device_origin=device_origin,
                        origin_devices=origin_devices,
                        event_origin=event_origin,
                        awol_devices=awol_devices,
                        device=device
                    )
                except RuntimeError:
                    log.exception('Bad device @ {}.'.format(device_origin))
        return devices_updated

    def _update_device(self, input_outputs, device_origin, origin_devices, event_origin, awol_devices, device):
        # device_key must always be present
        try:
            device_key = device['device_key']
        except KeyError:
            raise RuntimeError("No device key in {}".format(device))
        # set the device label if that hasn't already been done
        if 'device_label' not in device:
            device['device_label'] = device_key
        # associate the device with this event origin
        if event_origin not in origin_devices:
            origin_devices[event_origin] = set()
        if device_key not in origin_devices[event_origin]:
            origin_devices[event_origin].add(device_key)
        # has this device been awol?
        if device_key in awol_devices:
            log.debug("'{}' is no longer AWOL.".format(device_key))
        awol_devices.discard(device_key)
        # has this device been seen?
        if device_key not in device_origin:
            device_origin[device_key] = event_origin
        elif device_origin[device_key] != event_origin:
            raise RuntimeError("Device with key '{}' is already present at '{}' "
                               "but is also present at '{}' and is ignored.".format(device_key,
                                                                                    device_origin[device_key],
                                                                                    event_origin))
        if device_key not in input_outputs:
            input_outputs[device_key] = device
            return 1
        return 0

    def _process_device_event(self, event_origin, timestamp, active_device_key, active_device):
        if active_device_key in self._input_config and 'linked_outputs' in self._input_config[active_device_key]:
            output_device_keys = self._input_config[active_device_key]['linked_outputs']
            log.debug('{} {} => {}'.format(event_origin, active_device_key, output_device_keys))
            for output_device_key in output_device_keys:
                output_device_activation = {}
                if output_device_key not in self.outputs:
                    log.warning('{} is linked to an unknown output {}'.format(active_device_key,
                                                                              output_device_key))
                    continue
                if output_device_key not in self._output_origin:
                    log.warning('{} {} => {} but nowhere to route the response.'.format(event_origin,
                                                                                        active_device_key,
                                                                                        output_device_key))
                    continue
                # put the event information into the LRU
                self._device_event_lru[active_device_key] = timestamp
                # build up the device activation history
                activation_history = []
                for device_key, activation_time in list(self._device_event_lru.items()):
                    # filter out the device being activated
                    if device_key == active_device_key:
                        continue
                    try:
                        input_device_config = self._input_config[device_key]
                    except KeyError:
                        del self._device_event_lru[device_key]
                        continue
                    # TODO: make this configurable
                    if (timestamp - activation_time).seconds > 5 * 60:
                        continue
                    # TODO: fix
                    try:
                        input_device_label = input_device_config['device_label']
                    except KeyError:
                        log.warning('No label for device {}'.format(active_device_key))
                        input_device_label = active_device_key
                    # list of tuples
                    activation_history.append((
                        input_device_label,
                        (timestamp - activation_time).seconds
                    ))
                # get the event destination
                event_destination = self._output_origin[output_device_key]
                log.info('{} {} => {} {}'.format(
                    event_origin,
                    active_device_key,
                    event_destination,
                    output_device_key))
                # add information about the output device
                output_device_activation.update(self.outputs[output_device_key])
                # add output device configuration, if any
                if output_device_key in self._output_config:
                    output_device_activation.update(self._output_config[output_device_key])
                activation_command = {
                    'trigger_output': output_device_activation,
                    'input_context': active_device,
                    'trigger_history': activation_history,
                }
                if 'activation_interval' in self._input_config[active_device_key]:
                    activation_command['trigger_duration'] = int(
                        self._input_config[active_device_key]['activation_interval']
                    )
                # let the bot know first
                if output_device_activation['type'].lower() == 'sms':
                    self.bot.send_pyobj({
                        'timestamp': timestamp,
                        'data': activation_command
                    })
                # strip out image data that is no longer needed
                if 'image' in active_device:
                    del active_device['image']
                # dispatch the event
                if event_destination in self._origin_connections:
                    self._origin_connections[event_destination].send(make_payload(
                        timestamp=timestamp,
                        data=activation_command))
                elif event_destination == config.get('app', 'device_name'):
                    #TODO: route this properly
                    log.warning('Not dispatching event to self: {} {} => {}.'.format(event_origin,
                                                                                     active_device_key,
                                                                                     output_device_key))
                else:
                    log.warning('{} {} => {} but nowhere to route the response.'.format(event_origin,
                                                                                        active_device_key,
                                                                                        output_device_key))
                # add an entry into the event log
                try:
                    input_device_label = self._input_config[active_device_key]['device_label']
                except KeyError:
                    input_device_label = active_device_key
                try:
                    output_device_label = self._output_config[output_device_key]['device_label']
                except KeyError:
                    output_device_label = output_device_key
                self.event_log.send_pyobj({
                    'timestamp': timestamp,
                    'input_device': input_device_label,
                    'output_device': output_device_label,
                })
        else:
            log.warning('{} is not configured or linked to any output: {}'.format(active_device_key, active_device))

    def _load_config_table(self, table_name, primary_key='device_key'):
        log.info("Loading Dynamo table '{}'...".format(table_name))
        member_table = self._ddb_storage.Table(table_name)
        log.info("Reading table '{}'...".format(table_name))
        member = {}
        scan_response = member_table.scan()
        for result in scan_response['Items']:
            device_key = None
            member_config = {}
            for key, value in list(result.items()):
                if key == primary_key:
                    device_key = value
                else:
                    member_config.update([(key, value)])
            if device_key and len(member_config) > 0:
                member[device_key] = member_config
        return member, member_table

    def add_event_origin(self, origin, ip):
        self._origin_ips[origin] = ip

    # noinspection PyBroadException
    def run(self):
        # set up local DB storage
        self._db_storage = sqlite3.connect(database=os.environ['TABLESPACE_PATH'])
        # connect to AWS services
        self._ddb_storage = boto3.resource('dynamodb')
        # set up metrics
        self.metrics = boto3.client('cloudwatch')
        self.metric_namespace = '{}:{}'.format(config.get('app', 'device_name'), APP)
        # load configuration data
        self._general_config, self._general_config_table = self._load_config_table(
            table_name=os.environ['CONFIG_TABLE_GENERAL'],
            primary_key='config_key')
        self._input_config, self._input_config_table = self._load_config_table(
            table_name=os.environ['CONFIG_TABLE_INPUT'])
        self._output_config, self._output_config_table = self._load_config_table(
            table_name=os.environ['CONFIG_TABLE_OUTPUT'])
        # connect to event origins
        for origin, ip in list(self._origin_ips.items()):
            origin_connection_string = 'tcp://{}:{}'.format(ip, config.get('zmq', 'pushpull_port'))
            log.info('Device events will be responded to via {} @ {}'.format(origin, origin_connection_string))
            origin_push_socket = zmq_context.socket(zmq.PUSH)
            origin_push_socket.connect(origin_connection_string)
            self._origin_connections[origin] = origin_push_socket
        # event log
        self.event_log.connect(URL_WORKER_EVENT_LOG)
        # bot
        self.bot.connect(URL_WORKER_TELEGRAM_BOT)
        # informational notifications
        # TODO: move to UI configuration
        self.notify_not_before_time = make_timestamp(config.get('info_notify', 'not_before_time'))
        self.notify_not_after_time = make_timestamp(config.get('info_notify', 'not_after_time'))
        # message validity
        self._max_message_validity_seconds = int(config.get('app', 'max_message_validity_seconds'))
        # set up the special input for the panic button
        self._update_device(
            input_outputs=self.inputs,
            device_origin=self._input_origin,
            origin_devices=self._inputs_by_origin,
            event_origin=config.get('app', 'device_name'),
            awol_devices=self._awol_inputs,
            device={
                'device_key': 'App Panic Button',
                'device_label': 'Panic Button',
                'type': 'Panic Button'
            })
        # set up the special input for the dash button
        self._update_device(
            input_outputs=self.inputs,
            device_origin=self._input_origin,
            origin_devices=self._inputs_by_origin,
            event_origin=config.get('app', 'device_name'),
            awol_devices=self._awol_inputs,
            device={
                'device_key': 'App Dash Button',
                'device_label': 'Dash Button',
                'type': 'Dash Button'
            })
        # set up special output for SMS (text notifications)
        self._update_device(
            input_outputs=self.outputs,
            device_origin=self._output_origin,
            origin_devices=self._outputs_by_origin,
            event_origin=config.get('app', 'device_name'),
            awol_devices=self._awol_outputs,
            device={
                'device_key': 'SMS',
                'device_label': 'SMS',
                'type': 'SMS'
            })
        while True:
            try:
                event = self.socket.recv_pyobj()
                log.debug(event)
                if isinstance(event, dict):
                    for event_origin, event_data in list(event.items()):
                        if not isinstance(event_data, dict):
                            log.warning('Ignoring non-dict event format from {}: {} ({})'.format(
                                event_origin, event_data.__class__, event_data))
                            continue
                        if 'timestamp' in event_data:
                            timestamp = make_timestamp(event_data['timestamp'])
                        else:
                            timestamp = make_timestamp()
                            log_msg = "Message from {} does not include a 'timestamp' so it can't be filtered if it " \
                                      "is stale. Using {}.".format(event_origin, timestamp.strftime(DATE_FORMAT))
                            if 'data' in event_data and 'active_devices' in event_data['data']:
                                log.warning(log_msg)
                            else:
                                log.debug(log_msg)
                        if 'sqs' in event_origin:
                            device_disable = None
                            if 'enable' in event_data:
                                device_disable = False
                            elif 'disable' in event_data:
                                device_disable = True
                            # dash button
                            if 'dash_button' in event_data:
                                log.info('Dash button event: {}'.format(event_data['dash_button']))
                                # splice in a new event
                                event_origin = config.get('app', 'device_name')
                                event_data.update({
                                    'data': {
                                        'active_devices': [
                                            {
                                                'device_key': 'App Dash Button',
                                                'device_label': 'Dash Button',
                                                'type': 'Dash Button',
                                                'dash_button': event_data['dash_button']
                                            }
                                        ]
                                    }
                                })
                                # splice in device descriptions
                                #TODO: configurable somehow
                                event_data['device_description'] = ['House Security']
                            if device_disable is not None:
                                # this is a fuzzy name that refers to either a group or specific device
                                device_descriptions = None
                                if 'device_description' in event_data:
                                    device_descriptions = event_data['device_description']
                                if device_descriptions is None:
                                    log.warning('No valid device description found in SQS message: {}'.format(event_data))
                                    continue
                                event_processor.flash_info = False
                                devices_updated = 0
                                for device_description in device_descriptions:
                                    for device_key, device_config in list(self._input_config.items()):
                                        device_name_match = False
                                        device_name_test = device_config['device_label'].lower()
                                        # custom skill
                                        if device_name_test.startswith(device_description.lower()):
                                            device_name_match = True
                                        # smart home skill device ID
                                        elif device_name_test\
                                                .replace(' ', '_')\
                                                .replace('(', '#')\
                                                .replace(')', '#') == device_description:
                                            device_name_match = True
                                        elif 'group_name' in device_config and device_config['group_name']:
                                            device_name_test = device_config['group_name'].lower()
                                            if device_name_test.startswith(device_description.lower()):
                                                device_name_match = True
                                            elif device_name_test\
                                                    .replace(' ', '_')\
                                                    .replace('(', '#')\
                                                    .replace(')', '#') == device_description:
                                                device_name_match = True
                                        if device_name_match:
                                            # device matches our description
                                            log.info(
                                                'Updating device {} based on matching description {}; '
                                                'disable: {}'.format(device_key, device_description, device_disable))
                                            try:
                                                event_processor.input_config = (
                                                    device_key,
                                                    {'device_disabled': device_disable}
                                                )
                                                devices_updated += 1
                                            except KeyError:
                                                log.exception('Problem with device {}: {}'.format(device_key,
                                                                                                  str(event_data)))
                                if devices_updated > 0:
                                    state_change = 'Enabled'
                                    if device_disable is True:
                                        state_change = 'Disabled'
                                    self.bot.send_pyobj({
                                        'message': '{} notifications for {} devices.'.format(state_change,
                                                                                             devices_updated),
                                    })
                                event_processor.flash_info = True
                                # skip further processing because of enable/disable
                                continue
                        if 'data' in event_data:
                            if 'stale_heartbeat' in event_data['data']:
                                stale_heartbeat = event_data['data']['stale_heartbeat']
                                device_status = "unknown"
                                if 'device_status' in event_data['data']:
                                    device_status = event_data['data']['device_status']
                                # check if there are any inputs or outputs configured for this origin
                                for devices, origin_devices, awol_devices in [
                                    (self.inputs, self._inputs_by_origin, self._awol_inputs),
                                    (self.outputs, self._outputs_by_origin, self._awol_outputs)
                                ]:
                                    new_awol = 0
                                    if event_origin in origin_devices and len(origin_devices[event_origin]) > 0:
                                        log.debug("'{}' last checked-in: {} in an '{}' state.".format(
                                            event_origin,
                                            stale_heartbeat,
                                            device_status.lower()))
                                        for device_key in origin_devices[event_origin]:
                                            if device_key not in awol_devices:
                                                awol_devices.add(device_key)
                                                new_awol += 1
                                    if new_awol > 0:
                                        log.warning(
                                            "{} devices are unavailable because '{}' has gone AWOL "
                                            "({} devices on {}).".format(
                                                len(awol_devices),
                                                event_origin,
                                                new_awol,
                                                event_origin
                                            ))
                            if 'heartbeat_age' in event_data['data']:
                                heartbeat_age = int(event_data['data']['heartbeat_age'])
                                # show this as a metric
                                self.metrics.put_metric_data(
                                    Namespace=self.metric_namespace,
                                    MetricData=[
                                        {
                                            'MetricName': 'Heartbeat Age',
                                            'Value': heartbeat_age,
                                            'Dimensions': [
                                                {
                                                    'Name': 'Device',
                                                    'Value': event_origin
                                                },
                                            ],
                                            'Timestamp': timestamp,
                                            'Unit': 'Seconds'
                                        },
                                    ]
                                )
                            if 'device_info' in event_data['data']:
                                devices_updated = self._update_devices(
                                    event_origin=event_origin,
                                    device_info=event_data['data']['device_info'])
                                if devices_updated > 0:
                                    log.info('{} advertised {} new devices.'.format(event_origin, devices_updated))
                            if 'active_devices' in event_data['data']:
                                for active_device in event_data['data']['active_devices']:
                                    # patch in top-level data, if any
                                    if 'storage_url' in event_data['data']:
                                        active_device['storage_url'] = event_data['data']['storage_url']
                                    active_device_key = active_device['device_key']
                                    # input known?
                                    if active_device_key not in self._input_config:
                                        log.warning(
                                            "Input device '{}' is not configured, ignoring.".format(active_device_key))
                                        continue
                                    # message stale?
                                    message_age = make_timestamp() - timestamp
                                    if message_age > timedelta(seconds=self._max_message_validity_seconds):
                                        log.warning('Skipping further processing of {} from {} due to message age '
                                                 '{} exceeding {} seconds.'.format(
                                            active_device_key,
                                            event_origin,
                                            message_age.seconds,
                                            self._max_message_validity_seconds))
                                        continue
                                    active_device_config = self._input_config[active_device_key]
                                    # always process a fresh meter update
                                    if 'type' in active_device and 'meter' in active_device['type'].lower():
                                        meter_value = int(active_device['sample_value'])
                                        meter_reading_unit = ''
                                        if 'meter_reading_unit' in active_device_config:
                                            meter_reading_unit = ' ' + active_device_config['meter_reading_unit']
                                        meter_reading_unit_factor = 1
                                        if 'meter_reading_unit_factor' in active_device_config:
                                            meter_reading_unit_factor = active_device_config[
                                                'meter_reading_unit_factor']
                                        meter_reading_unit_precision = 0
                                        if 'meter_reading_unit_precision' in active_device_config:
                                            meter_reading_unit_precision = active_device_config[
                                                'meter_reading_unit_precision']
                                        number_format_string = "{:." + str(meter_reading_unit_precision) + "f}"
                                        # update but do not persist in DDB (Lambda already does this)
                                        active_device_config.update({
                                            'meter_value': meter_value,
                                            'meter_reading': number_format_string.format(int(meter_value) / float(
                                                meter_reading_unit_factor)) + meter_reading_unit
                                        })
                                    # input disabled?
                                    if 'device_disabled' in active_device_config:
                                        continue
                                    # only consider a meter active if the value is out of bounds
                                    if 'type' in active_device and 'meter' in active_device['type'].lower():
                                        out_of_range = False
                                        if 'meter_low_limit' in active_device_config:
                                            if meter_value < active_device_config['meter_low_limit']:
                                                out_of_range = True
                                        if 'meter_high_limit' in active_device_config:
                                            if meter_value > active_device_config['meter_high_limit']:
                                                out_of_range = True
                                        if not out_of_range:
                                            continue
                                    # multi-trigger
                                    if 'multi_trigger' in active_device_config:
                                        if 'trigger_window' in active_device_config:
                                            trigger_window = active_device_config['trigger_window']
                                        else:
                                            trigger_window = int(config.get('config', 'default_trigger_window'))
                                        # if not in the trigger history, treat as never activated
                                        if active_device_key not in self._input_trigger_history:
                                            self._input_trigger_history[active_device_key] = time.time()
                                            continue
                                        input_last_triggered = self._input_trigger_history[active_device_key]
                                        # the device must have been considered active within the trigger window
                                        last_triggered = time.time() - input_last_triggered
                                        if last_triggered > trigger_window:
                                            # update the history and continue
                                            self._input_trigger_history[active_device_key] = time.time()
                                            log.debug('Not activating {} because it was triggered '
                                                      'more than {} seconds ago. ({})'.format(active_device_key,
                                                                                              trigger_window,
                                                                                              last_triggered))
                                            continue
                                    # get the event detail for debouncing
                                    event_detail = None
                                    if 'event_detail' in active_device:
                                        event_detail = active_device['event_detail']
                                    # debounce
                                    if active_device_key in self._input_active_history:
                                        # debounce this input
                                        if active_device_key in self._input_config and 'activation_interval' in active_device_config:
                                            activation_interval = active_device_config['activation_interval']
                                        else:
                                            activation_interval = int(
                                                config.get('config', 'default_activation_interval'))
                                        input_last_active, last_event_detail = self._input_active_history[
                                            active_device_key]
                                        if last_event_detail == event_detail:
                                            last_activated = time.time() - input_last_active
                                            if last_activated < activation_interval:
                                                # device is still considered active
                                                log.debug('Not activating {} ({}) because it was triggered '
                                                          'less than {} seconds ago. ({})'.format(active_device_key,
                                                                                                  last_event_detail,
                                                                                                  activation_interval,
                                                                                                  last_activated))
                                                continue
                                    self._input_active_history[active_device_key] = (time.time(), event_detail)
                                    # active devices are presently assumed to be inputs
                                    self._update_device(
                                        input_outputs=self.inputs,
                                        device_origin=self._input_origin,
                                        origin_devices=self._inputs_by_origin,
                                        event_origin=event_origin,
                                        awol_devices=self._awol_inputs,
                                        device=active_device)
                                    log.debug('{} {}'.format(origin, active_device_key))
                                    # informational event?
                                    # TODO: move to _process_device_event
                                    if 'info_notify' in active_device_config:
                                        # make a future date that is relative (after) now time.
                                        now = datetime.now().replace(tzinfo=tz.tzlocal())
                                        not_before = now.replace(
                                            hour=self.notify_not_before_time.hour,
                                            minute=self.notify_not_before_time.minute,
                                            second=0,
                                            microsecond=0)
                                        not_after = now.replace(
                                            hour=self.notify_not_after_time.hour,
                                            minute=self.notify_not_after_time.minute,
                                            second=0,
                                            microsecond=0)
                                        defer_until = None
                                        if now < not_before:
                                            defer_until = not_before
                                        if now >= not_after:
                                            # the not-before time may not be on the same day
                                            defer_until = not_before + timedelta(days=1)
                                        if defer_until:
                                            # defer the notification
                                            log.info("Deferring notification for '{}' until {}".format(
                                                active_device_key,
                                                defer_until))
                                            continue
                                    self._process_device_event(
                                        event_origin=origin,
                                        timestamp=timestamp,
                                        active_device_key=active_device_key,
                                        active_device=active_device)
            except ContextTerminated:
                log.warning('ZMQ terminate: {}'.format(self.__class__.__name__))
                self.socket.close()
                log.warning('ZMQ terminated socket: {}'.format(self.__class__.__name__))
                for origin_push_socket in list(self._origin_connections.values()):
                    origin_push_socket.close()
                log.warning('ZMQ terminated origin push sockets: {}'.format(self.__class__.__name__))
                self.event_log.close()
                log.warning('ZMQ terminated event log: {}'.format(self.__class__.__name__))
                self.bot.close()
                log.warning('ZMQ terminated: {}'.format(self.__class__.__name__))
                break
            except Exception:
                log.exception(self.__class__.__name__)
                sentry.captureException()
                sleep(1)
                continue


class EventLog(Thread):

    def __init__(self):
        super(EventLog, self).__init__(name=self.__class__.__name__)
        self.daemon = True

        self._ddb_storage = None
        self._event_log_table = None
        self._metrics = None
        self.metric_namespace = None

        self.socket = zmq_context.socket(zmq.PULL)
        self.socket.bind(URL_WORKER_EVENT_LOG)

    def get_events(self, since_ts):
        event_data = self._event_log_table.scan(FilterExpression=Attr('timestamp').gte(since_ts))
        # extract the event data from the result set
        events = []
        for event in event_data['Items']:
            timestamp = event['timestamp']
            # noinspection PyTypeChecker
            events.append((
                int(timestamp),
                event['input_device'],
                event['output_device'],
                make_timestamp(float(timestamp)).astimezone(tz=tz.tzlocal()).strftime('%c')
            ))
        # reorder based on the timestamp
        return sorted(events, key=itemgetter(0, 1, 2), reverse=True)

    # noinspection PyBroadException
    def run(self):
        # connect to AWS services
        self._ddb_storage = boto3.resource('dynamodb')
        self._event_log_table = self._ddb_storage.Table('event_log')
        # set up metrics
        self._metrics = boto3.client('cloudwatch')
        self.metric_namespace = '{}:{}'.format(config.get('app', 'device_name'), APP)
        while True:
            try:
                event = self.socket.recv_pyobj()
                log.debug(event)
                timestamp = event['timestamp']
                # work around Python's brain-dead date handling
                unix_timestamp = int((timestamp.replace(tzinfo=None) - datetime(1970, 1, 1)).total_seconds())
                put_args = {'Item': {}}
                put_args['Item'].update({
                    # pad some millis for the actual insertion time to avoid key conflicts
                    'timestamp': Decimal('{}.{}'.format(unix_timestamp, datetime.now().microsecond)),
                    'input_device': event['input_device'],
                    'output_device': event['output_device'],
                })
                saved = self._event_log_table.put_item(**put_args)
                if not saved:
                    log.warning('Unable to save event log entry: {}'.format(event))
                    continue
                # show this as a metric
                self._metrics.put_metric_data(
                    Namespace=self.metric_namespace,
                    MetricData=[
                        {
                            'MetricName': 'Device Event',
                            'Value': 1,
                            'Dimensions': [
                                {
                                    'Name': 'Device',
                                    'Value': config.get('app', 'device_name')
                                },
                            ],
                            'Timestamp': timestamp,
                            'Unit': 'Count'
                        },
                    ]
                )
            except ContextTerminated:
                log.warning('ZMQ terminate: {}'.format(self.__class__.__name__))
                self.socket.close()
                log.warning('ZMQ terminated: {}'.format(self.__class__.__name__))
                break
            except Exception:
                log.exception(self.__class__.__name__)
                sentry.captureException()
                sleep(1)
                continue


class TBot(Thread):

    def __init__(self):
        super(TBot, self).__init__(name=self.__class__.__name__)
        self.daemon = True
        self.bot = None
        self.chat_id = config.getint('telegram', 'chat_room_id')

        self.socket = zmq_context.socket(zmq.PULL)
        self.socket.bind(URL_WORKER_TELEGRAM_BOT)

        self.sns = boto3.client('sns')

    def build_message(self, timestamp, event_data, max_length=160, build_sms=False):
        device_label = event_data['input_context']['device_label']
        event_detail = ""
        if 'event_detail' in event_data['input_context']:
            event_detail = ' {}'.format(event_data['input_context']['event_detail'])
        # include a timestamp in this SMS message
        notification_message = '{}{} ({}:{})'.format(
            device_label,
            event_detail,
            timestamp.hour,
            str(timestamp.minute).zfill(2))
        footer = ''
        # add in the callback URL
        if build_sms and ngrok_tunnel_url:
            footer = "\n{}".format(ngrok_tunnel_url)
        if not build_sms and 'storage_url' in event_data['input_context']:
            notification_message = '[{}]({})'.format(notification_message, event_data['input_context']['storage_url'])
        # add in some trigger history for context
        if 'trigger_history' in event_data:
            for history_device_label, trigger_secs_ago in event_data['trigger_history']:
                history_info = "\n{}s ago: {}".format(trigger_secs_ago, history_device_label)
                if len(notification_message) + len(history_info) + len(footer) >= max_length:
                    break
                notification_message += history_info
        notification_message += footer
        return notification_message

    # noinspection PyBroadException
    def run(self):
        # connect to Telegram
        self.bot = TelegramBot(token=config.get('telegram', 'bot_api_token'))
        while True:
            try:
                event = self.socket.recv_pyobj()
                #TODO: fix me for small payloads
                #log.debug(event)
                if 'timestamp' in event:
                    timestamp = parse_datetime(value=event['timestamp'], as_tz=tz.tzlocal())
                else:
                    timestamp = make_timestamp().astimezone(tz=tz.tzlocal())
                event_data = None
                # build the message
                image_data = None
                if 'message' in event:
                    notification_message = event['message']
                    if 'add_tunnel_url' in event:
                        notification_message = '[{}]({})'.format(notification_message, ngrok_tunnel_url_with_bauth)
                elif 'data' in event:
                    event_data = event['data']
                    notification_message = self.build_message(timestamp=timestamp,
                                                              event_data=event_data,
                                                              max_length=200)
                    if 'image' in event_data['input_context']:
                        image_data = BytesIO(event_data['input_context']['image'])

                # send the message
                try:
                    if image_data:
                        log.debug("Bot sends image to {} with caption '{}'".format(str(self.chat_id),
                                                                                   notification_message))
                        self.bot.send_photo(chat_id=self.chat_id,
                                            photo=image_data,
                                            caption=notification_message,
                                            parse_mode='Markdown')
                    else:
                        log.debug("Bot says to {}: '{}'".format(str(self.chat_id), notification_message))
                        self.bot.send_message(chat_id=self.chat_id,
                                              text=notification_message,
                                              parse_mode='Markdown')
                except (TimedOut, NetworkError):
                    log.warning('Timeout or network problem using Bot. Fallback back to SMS.')
                    if event_data:
                        # rebuild the message for SMS
                        notification_message = self.build_message(timestamp=timestamp,
                                                                  event_data=event_data,
                                                                  build_sms=True)
                        if 'device_params' not in event_data['trigger_output']:
                            raise RuntimeError('Cannot send SMS because no parameters are configured.')
                        recipients = event_data['trigger_output']['device_params'].strip().split(',')
                        for recipient in recipients:
                            name_number = recipient.split(';')
                            log.info("SMS {} ({}) '{}'".format(name_number[0], name_number[1], notification_message))
                            try:
                                resp = self.sns.publish(PhoneNumber=name_number[1], Message=notification_message)
                                log.info('SMS sent: {}'.format(str(resp)))
                            except Exception:
                                log.exception('Cannot send SMS {}: {}'.format(name_number[1], notification_message))
                    else:
                        log.error('No viable method to send notification for event: {}'.format(notification_message))
            except ContextTerminated:
                log.warning('ZMQ terminate: {}'.format(self.__class__.__name__))
                self.socket.close()
                log.warning('ZMQ terminated: {}'.format(self.__class__.__name__))
                break
            except Exception:
                log.exception(self.__class__.__name__)
                sentry.captureException()
                sleep(1)
                continue


class SourceSubscriber(Thread):

    def __init__(self, label, publisher_endpoint):
        super(SourceSubscriber, self).__init__()
        self.name = '{}::{}'.format(self.__class__.__name__, label)
        self.daemon = True

        self._label = label
        self._publisher_endpoint = publisher_endpoint

        self.subscriber = zmq_context.socket(zmq.SUB)
        self.processor = zmq_context.socket(zmq.PUSH)

        self._reconnected = False
        self.last_message = None
        # use half of the tolerated heartbeat value
        self._zmq_poll_period = int(config.get('app', 'max_heartbeat_delay_seconds')) / 2

    # noinspection PyBroadException
    def run(self):
        log.info('Subscribing to {} @ {}'.format(self._label, self._publisher_endpoint))
        self.subscriber.connect(self._publisher_endpoint)
        self.subscriber.setsockopt(zmq.SUBSCRIBE, b'')
        self.processor.connect(URL_WORKER_EVENT_PROCESSOR)
        while True:
            try:
                # timeout in millis
                zmq_events = self.subscriber.poll(timeout=self._zmq_poll_period * 1000)
                # TODO: remove nanny
                if zmq_events == 0:
                    # if a single message has been received ever
                    if self.last_message:
                        log.info('{} reconnecting to {} after more than {} seconds of inactivity...'.format(
                            self.name,
                            self._publisher_endpoint,
                            self._zmq_poll_period))
                        try:
                            self.subscriber.close()
                        except ZMQError:
                            log.exception(self.name)
                        self.subscriber = zmq_context.socket(zmq.SUB)
                        self.subscriber.connect(self._publisher_endpoint)
                        self.subscriber.setsockopt(zmq.SUBSCRIBE, b'')
                        self._reconnected = True
                    # nothing to do otherwise
                    continue
                try:
                    publisher_event = umsgpack.unpackb(
                        self.subscriber.recv(zmq.NOBLOCK))
                except Again as e:
                    log.debug('{}: {}'.format(self.name, str(e)))
                    continue
                # output how long since the last message
                if self.last_message and self._reconnected:
                    log.info('{} resumes events after {} seconds.'.format(
                        self._label,
                        time.time() - self.last_message))
                self.last_message = time.time()
                self._reconnected = False
                self.processor.send_pyobj({self._label: publisher_event})
            except UnpackException:
                log.exception('Cannot unpack message from {}.'.format(self._label))
                continue
            except ContextTerminated:
                log.warning('ZMQ terminate: {}'.format(self.__class__.__name__))
                self.subscriber.close()
                log.warning('ZMQ terminated subscriber: {}'.format(self.__class__.__name__))
                self.processor.close()
                log.warning('ZMQ terminated: {}'.format(self.__class__.__name__))
                break
            except ZMQError:
                log.exception(self.name)
                break
            except Exception:
                log.exception(self.name)
                sentry.captureException()
                sleep(1)
                continue


class SQSListener(Thread):

    def __init__(self):
        super(SQSListener, self).__init__(name=self.__class__.__name__)
        self.daemon = True

        self.processor = zmq_context.socket(zmq.PUSH)
        self._sqs = None
        self._sqs_queue = None

    # noinspection PyBroadException
    def run(self):
        sqs_queue_name = os.environ['SQS_QUEUE']
        log.info('Listening for control messages on SQS queue {}'.format(sqs_queue_name))
        # set up notifications
        self._sqs = boto3.resource('sqs')
        self._sqs_queue = self._sqs.get_queue_by_name(QueueName=sqs_queue_name)
        self.processor.connect(URL_WORKER_EVENT_PROCESSOR)
        while True:
            try:
                for sqs_message in self._sqs_queue.receive_messages(WaitTimeSeconds=20):
                    # forward for further processing
                    message_body = sqs_message.body
                    try:
                        self.processor.send_pyobj({'sqs': json.loads(message_body)})
                    except JSONDecodeError:
                        log.exception('Unstructured SQS message: {}'.format(message_body))
                    # Let the queue know that the message is processed
                    sqs_message.delete()
            except gaierror:
                log.exception()
                continue
            except UnpackException:
                log.exception('Cannot unpack message from SQS queue {}.'.format(self._sqs_queue))
                continue
            except ContextTerminated:
                log.warning('ZMQ terminate: {}'.format(self.__class__.__name__))
                self.processor.close()
                log.warning('ZMQ terminated: {}'.format(self.__class__.__name__))
                break
            except ZMQError:
                log.exception(self.name)
                break
            except Exception:
                log.exception(self.name)
                sentry.captureException()
                sleep(1)
                continue


class OriginNanny(Thread):

    def __init__(self):
        super(OriginNanny, self).__init__(name=self.__class__.__name__)
        self.daemon = True

        self.processor = zmq_context.socket(zmq.PUSH)

        self.origin_subscriber = {}
        self._max_heartbeat_delay = int(config.get('app', 'max_heartbeat_delay_seconds'))
        # set the Resin.io API key as expected by the resin-python-sdk
        # Note that the stored RESIN_API_KEY could be overridden in config via entrypoint.sh
        # configuration interpolation to favour key generated for this application.
        os.environ['RESIN_API_KEY'] = config.get('resin', 'api_key')

    # noinspection PyShadowingNames
    def add_origin_subscriber(self, origin, ip, subscriber):
        self.origin_subscriber[origin] = (ip, subscriber)

    def run(self):
        self.processor.connect(URL_WORKER_EVENT_PROCESSOR)
        # warm-up to wait for first volley of heartbeats
        interruptable_sleep.wait(self._max_heartbeat_delay)
        while True:
            try:
                resin_device = Device()
                for origin, (ip, origin_subscriber) in list(self.origin_subscriber.items()):
                    payload = {}
                    # when last was an event seen by this subscriber
                    last_message = origin_subscriber.last_message
                    heartbeat_age = None
                    if last_message:
                        heartbeat_age = time.time() - origin_subscriber.last_message
                    if last_message is None or heartbeat_age > self._max_heartbeat_delay:
                        device_status = None
                        device_last_seen = None
                        if last_message:
                            last_message = datetime.utcfromtimestamp(last_message).replace(tzinfo=pytz.utc).strftime(
                                DATE_FORMAT)
                        else:
                            last_message = "never"
                        try:
                            for d in resin_device.get_by_name(origin):
                                device_ip = d['ip_address'].split()[0]
                                # this matches the origin by name and IP
                                if device_ip == ip:
                                    device_status = d['status']
                                    if 'last_seen_time' in d:
                                        device_last_seen = d['last_seen_time']

                        except (RequestError, ConnectionError) as e:
                            log.debug("Unable to fetch device information for Resin device '{}': {}".format(origin,
                                                                                                            str(e)))
                        log_message = "'{}' last activity was {}.".format(origin, last_message)
                        if device_last_seen is None:
                            device_last_seen = "unknown"
                        if device_status:
                            log.debug("{} Device is {} (last seen: {})".format(log_message,
                                                                               device_status,
                                                                               device_last_seen))
                        else:
                            log.debug(log_message)
                        # used as an out-of-band trigger for something amiss
                        payload['stale_heartbeat'] = last_message
                        if device_status:
                            payload['device_status'] = device_status
                    # do this for each device irrespective of stale or not
                    if heartbeat_age:
                        payload['heartbeat_age'] = heartbeat_age
                    # send out either a stale alert or the heartbeat
                    if len(payload) > 0:
                        self.processor.send_pyobj({origin: {'data': payload}})
            except ContextTerminated:
                log.warning('ZMQ terminate: {}'.format(self.__class__.__name__))
                self.processor.close()
                log.warning('ZMQ terminated: {}'.format(self.__class__.__name__))
                break
            # sleep here unless interrupted
            interruptable_sleep.wait(self._max_heartbeat_delay)


class CallbackUrlDiscovery(Thread):

    def __init__(self):
        super(CallbackUrlDiscovery, self).__init__(name=self.__class__.__name__)
        self.daemon = True

        self._discover_url = 'http://127.0.0.1:{}/api/tunnels/{}'.format(
            config.get('ngrok', 'client_api_port'),
            config.get('ngrok', 'tunnel_name'))

    # noinspection PyBroadException
    def run(self):
        while True:
            try:
                # sudo update
                global ngrok_tunnel_url
                try:
                    ngrok_tunnel_url = requests.get(self._discover_url).json()['public_url']
                except KeyError:
                    log.exception('Attempting to discover ngrok tunnel URL...')
                    sleep(1)
                    continue
                log.info('External call-back URL is {}'.format(ngrok_tunnel_url))
                break
            except Exception:
                log.exception(self.__class__.__name__)
                sentry.captureException()
                sleep(1)
        try:
            purl = urlparse(ngrok_tunnel_url)
            # decorate the URL with basic-auth details
            global ngrok_tunnel_url_with_bauth
            ngrok_tunnel_url_with_bauth = '{}://{}:{}@{}{}'.format(purl.scheme,
                                                                   config.get('ngrok', 'auth_user'),
                                                                   config.get('ngrok', 'auth_password'),
                                                                   purl.netloc,
                                                                   purl.path)
        except Exception:
            log.exception(self.__class__.__name__)
            sentry.captureException()


class FlaskThread(Thread):

    def __init__(self, app):
        super(FlaskThread, self).__init__(name=self.__class__.__name__)
        # add Sentry
        sentry.init_app(app)
        # start frontend
        app.secret_key = os.environ['APP_FLASK_SECRET_KEY']
        app.jinja_env.add_extension('jinja2.ext.loopcontrols')
        app.jinja_env.filters.update({
            'is_list': is_list,
        })
        #TODO: how to enable debug mode
        self.srv = make_server(host='0.0.0.0',
                               port=int(config.get('flask', 'http_port')),
                               app=app,
                               threaded=True)
        self.ctx = app.app_context()
        self.ctx.push()

    def run(self):
        self.srv.serve_forever()

    def shutdown(self):
        self.srv.shutdown()


if __name__ == "__main__":
    # DEBUG logging until startup complete
    log.setLevel(logging.DEBUG)
    syslog_handler = logging.handlers.SysLogHandler(address='/dev/log')
    formatter = logging.Formatter('%(name)s [%(levelname)s] %(message)s')
    syslog_handler.setFormatter(formatter)
    log.addHandler(syslog_handler)
    if sys.stdout.isatty():
        log.warning("Using console logging because there is a tty.")
        stream_handler = logging.StreamHandler(stream=sys.stdout)
        stream_handler.setFormatter(formatter)
        log.addHandler(stream_handler)
    threads_tracked = set()
    # bind listeners first
    event_log = EventLog()
    event_processor = EventProcessor()
    origin_nanny = OriginNanny()
    telegram_bot = TBot()
    # set up subscribers
    subscription_sources = config.get('app', 'subscription_sources').split(',')
    for source in subscription_sources:
        label_ip = source.split(':')
        source_label = label_ip[0]
        source_ip = label_ip[1]
        connection_string = 'tcp://{}:{}'.format(source_ip, config.get('zmq', 'pubsub_port'))
        subscriber = SourceSubscriber(label=source_label, publisher_endpoint=connection_string)
        threads_tracked.add(subscriber.getName())
        subscriber.start()
        # nanny the heartbeats
        origin_nanny.add_origin_subscriber(origin=source_label, ip=source_ip, subscriber=subscriber)
        # make sure that the event processor creates a PUSH socket for each output
        event_processor.add_event_origin(origin=source_label, ip=source_ip)
    # notifications
    sqs_listener = SQSListener()
    # start the event processor
    event_log.start()
    threads_tracked.add(event_log.getName())
    event_processor.start()
    origin_nanny.start()
    threads_tracked.add(event_processor.getName())
    sqs_listener.start()
    threads_tracked.add(sqs_listener.getName())
    telegram_bot.start()
    threads_tracked.add(telegram_bot.getName())
    # set up signal handlers
    signal_handler = SignalHandler()
    # start Telegram integration
    telegram_updater = TelegramUpdater(token=config.get('telegram', 'bot_api_token'))
    telegram_dispatcher = telegram_updater.dispatcher
    telegram_dispatcher.add_handler(TelegramMessageHandler(TelegramFilters.text,
                                                           telegram_bot_echo))
    telegram_dispatcher.add_handler(TelegramCommandHandler('start',
                                                           telegram_bot_cmd,
                                                           pass_args=True))
    telegram_dispatcher.add_handler(TelegramCommandHandler('report',
                                                           telegram_bot_cmd,
                                                           pass_args=True))
    telegram_dispatcher.add_handler(TelegramInlineHandler(telegram_bot_inline))
    telegram_dispatcher.add_error_handler(telegram_error_handler)
    telegram_updater.start_polling()
    # start threads
    f = threading.Thread(name='nanny', target=thread_nanny, args=(threads_tracked, signal_handler,))
    f.setDaemon(True)
    f.start()
    server = FlaskThread(rest_api)
    server.start()
    threads_tracked.add(server.getName())
    try:
        # startup completed
        # back to INFO logging
        log.setLevel(logging.INFO)
        # discover callback URL
        CallbackUrlDiscovery().start()
        while True:
            interruptable_sleep.wait(60000)
    except(KeyboardInterrupt, RuntimeWarning) as e:
        log.info("Shutting down...")
        # bring any threads out of their Pythonic coma
        interruptable_sleep.set()
        server.shutdown()
        telegram_updater.stop()
        zmq_context.term()
