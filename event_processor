#!/usr/bin/env python
import dateutil.parser
import logging
import logging.handlers

import builtins
import boto3
import copy
import os
import pytz
import re
import requests
import schedule
import simplejson as json
import sqlite3
import threading
import time
import umsgpack
import zmq

from base64 import b64decode, b64encode
from botocore.exceptions import EndpointConnectionError as bcece, \
    ConnectionClosedError as bccce, \
    ConnectionError as bce
from boto3.dynamodb.conditions import Attr
from bs4 import BeautifulSoup
from configparser import ConfigParser
from datetime import datetime, timedelta
from dateutil import tz
from decimal import Decimal
from io import BytesIO
from onepasswordconnectsdk.client import Client as CredsClient
from operator import itemgetter
from pathlib import Path
from pylru import lrucache
from requests.exceptions import ConnectionError
from sentry_sdk import capture_exception, last_event_id
from sentry_sdk.integrations.flask import FlaskIntegration
from simplejson.scanner import JSONDecodeError
from socket import gaierror
from traceback import StackSummary
from telegram import Bot as TelegramBot, \
    InlineQueryResultArticle, InputTextMessageContent, \
    ParseMode, Update
from telegram.error import TelegramError, \
    Unauthorized, \
    BadRequest, \
    TimedOut, \
    ChatMigrated, \
    NetworkError
from telegram.ext import Updater as TelegramUpdater, \
    CommandHandler as TelegramCommandHandler, \
    MessageHandler as TelegramMessageHandler, \
    Filters as TelegramFilters, \
    InlineQueryHandler as TelegramInlineHandler, \
    CallbackContext as TelegramCallbackContext
from telegram.utils.helpers import escape_markdown
from telegram.utils.request import TimedOut
from threading import Thread
from time import sleep
from umsgpack import UnpackException
from urllib.parse import urlparse
from uuid import uuid4
from flask import Flask, g, flash, request, render_template, url_for, redirect
from flask_compress import Compress
from werkzeug.serving import make_server
from zmq.error import ZMQError, ContextTerminated, Again

import paho.mqtt.client as mqtt
from paho.mqtt.client import MQTT_ERR_SUCCESS

import botocore
import os.path
from botoflow import activity, \
    activities, \
    execute, \
    return_, \
    workflow_starter, \
    WorkflowDefinition, \
    ThreadedWorkflowExecutor, \
    ThreadedActivityExecutor
from botoflow.options import activity_options
from botoflow.workers.workflow_worker import WorkflowWorker
from botoflow.workers.activity_worker import ActivityWorker
from botoflow.constants import SECONDS, MINUTES
from botoflow.exceptions import ActivityTaskFailedError, ActivityTaskTimedOutError, \
    WorkflowFailedError, WorkflowTimedOutError

# setup builtins used by pylib init
app_name = Path(__file__).stem
builtins.APP_NAME = app_name
builtins.SENTRY_EXTRAS = [FlaskIntegration()]
AWS_REGION = os.environ['AWS_DEFAULT_REGION']
class CredsConfig:
    sentry_dsn: f'opitem:"Sentry" opfield:{app_name}.dsn' = None # type: ignore
    flask_secret_key: f'opitem:"Frontend" opfield:Flask.secret_key' = None # type: ignore
    flask_basic_auth_username: f'opitem:"Frontend" opfield:.username' = None # type: ignore
    flask_basic_auth_password: f'opitem:"Frontend" opfield:.password' = None # type: ignore
    mdash_api_key: f'opitem:"mdash" opfield:.password' = None # type: ignore
    telegram_bot_api_token: f'opitem:"Telegram" opfield:{app_name}.token' = None # type: ignore
    aws_akid: f'opitem:"AWS" opfield:{AWS_REGION}.akid' = None # type: ignore
    aws_sak: f'opitem:"AWS" opfield:{AWS_REGION}.sak' = None # type: ignore
    influxdb_org: f'opitem:"InfluxDB" opfield:automation.org' = None # type: ignore
    influxdb_token: f'opitem:"InfluxDB" opfield:automation.token' = None # type: ignore
    grafana_url: f'opitem:"Grafana" opfield:dashboard.URL' = None # type: ignore
# instantiate class
builtins.creds_config = CredsConfig()

from lib import app_config, \
    creds, \
    device_name, \
    device_name_base, \
    log

from lib.datetime import is_list, \
    make_timestamp, \
    make_unix_timestamp, \
    parse_datetime
from lib.data import make_payload
from lib.aws import boto_session, \
    swf_region, \
    swf_domain
from lib.aws.metrics import app_metrics, post_count_metric
from lib.aws.swf import SWFActivityWaiter, \
    swf_exception_handler, \
    DeviceInfoActivity, \
    DeviceWorkflow, \
    HelloWorldActivities, \
    HelloWorldWorkflow, \
    DeviceWorkflow, \
    ImageProcessWorkflow, \
    SnapshotWorkflow, \
    TTSWorkflow, \
    IOBoardWorkflow, \
    BluetoothWorkflow
from lib.leader import Leader
from lib.process import SignalHandler, \
    exec_cmd, \
    exec_cmd_log
from lib import threads
from lib.threads import thread_nanny
from lib.zmq import zmq_socket, zmq_term, Closable
from lib.handler import exception_handler

from influxdb_client import InfluxDBClient, Point, WritePrecision
from influxdb_client.client.write_api import ASYNCHRONOUS

ISO_DATE_FORMAT = builtins.ISO_DATE_FORMAT

flask_app = Flask(app_name)

OUTPUT_TYPE_BLUETOOTH = 'bluetooth'
OUTPUT_TYPE_SWITCH = 'ioboard'
OUTPUT_TYPE_IMAGE = 'image'
OUTPUT_TYPE_SNAPSHOT = 'snapshot'
OUTPUT_TYPE_TTS = 'tts'

URL_WORKER_APP = 'inproc://app-worker'
URL_WORKER_EVENT_LOG = 'inproc://event-log'
URL_WORKER_TELEGRAM_BOT = 'inproc://telegram-bot'
URL_WORKER_MQTT_PUBLISH = 'inproc://mqtt-publish'
URL_WORKER_AUTO_SCHEDULER = 'inproc://auto-scheduler'

event_processor = None
event_logger = None
ngrok_tunnel_url = None
ngrok_tunnel_url_with_bauth = None


@flask_app.route('/debug-sentry')
def trigger_error():
    1 / 0


@flask_app.route('/logging')
def debug():
    log.setLevel(request.args.get('level'))
    return 'OK'


@flask_app.errorhandler(500)
def internal_server_error(e):
    return render_template('error.html',
                           sentry_event_id=last_event_id(),
                           sentry_dsn=creds.sentry_dsn
                           ), 500


@flask_app.route('/', methods=['GET', 'POST'])
def index():
    meter_history = {}
    group_disabled = {}
    device_listing = {}
    input_labels = {}
    awol_input_labels = set()
    global event_processor
    awol_inputs = event_processor.awol_inputs
    if len(awol_inputs) > 0:
        flash(message='{} devices are unavailable right now.'.format(len(awol_inputs)), category='danger')
    # type: ignore
    for device_key, device_config in list(event_processor.input_config.items()):
        if device_key in awol_inputs:
            awol_input_labels.add(device_config['device_label'])
        if 'group_name' not in device_config:
            device_listing[device_key] = device_config
        else:
            group_name = device_config['group_name']
            if group_name not in device_listing:
                device_listing[group_name] = {}
                device_listing[group_name]['grouped_inputs'] = {}
            device_listing[group_name]['grouped_inputs'][device_key] = device_config
            if group_name not in input_labels:
                input_labels[group_name] = []
            input_labels[group_name].append(device_config['device_label'])
            # manufacture a device label for the group
            device_listing[group_name]['device_label'] = group_name
            # check for enabled/disabled disparity
            if 'device_disabled' in device_config:
                device_listing[group_name]['device_disabled'] = device_config['device_disabled']
                if group_name not in group_disabled:
                    group_disabled[group_name] = device_config['device_disabled']
                elif group_disabled[group_name] != device_config['device_disabled']:
                    device_listing[group_name]['mixed_disabled'] = True
            elif group_name in group_disabled and group_disabled[group_name]:
                device_listing[group_name]['mixed_disabled'] = True
    if request.method == 'POST':
        if 'panic_button' in request.form:
            log.info('Panic button pressed.')
            processor = zmq_socket(zmq.PUSH)
            processor.connect(URL_WORKER_APP)
            processor.send_pyobj({
                device_name: {
                    'data': {
                        'active_devices': [
                            {
                                'device_key': 'App Panic Button',
                                'device_label': 'Panic Button',
                                'type': 'Panic Button'
                            }
                        ]
                    }
                }
            })
            processor.close()
        elif 'meter_reset' in request.form:
            device_key = request.form['meter_reset']
            reset_value = 0
            if 'meter_reset_value' in device_listing[device_key]:
                reset_value = device_listing[device_key]['meter_reset_value']
            # override with the prompt value if specified
            if 'prompt_val' in request.form:
                try:
                    reset_value = int(request.form['prompt_val'])
                except ValueError:
                    # oh well
                    pass
            # pylint: disable=unused-variable
            if 'meter_reset_additive' in device_listing[device_key]:
                iot_message = {'adjust_register': reset_value}
                meter_value = device_listing[device_key]['meter_value']
                meter_value += reset_value
                # override the reset value
                reset_value = meter_value
            else:
                iot_message = {'set_register': reset_value}
            # update the in memory model
            #TODO: correctly update 'meter_reading'
            device_listing[device_key]['meter_value'] = reset_value
            # send IoT message
            mqtt_ipc = zmq_socket(zmq.PUSH)
            mqtt_ipc.connect(URL_WORKER_MQTT_PUBLISH)
            mqtt_ipc.send_pyobj((
                app_config.get('mqtt', 'meter_reset_topic'),
                json.dumps(iot_message)
            ))
            mqtt_ipc.close()
        elif 'meter_history' in request.form:
            scheme = None
            if 'X-Forwarded-Proto' in request.headers:
                scheme = request.headers['X-Forwarded-Proto']
            return redirect(url_for(
                'show_metrics',
                meter=request.form['meter_history'],
                _external=True,
                _scheme=scheme))
        elif 'device_key' in request.form:
            device_key = request.form['device_key']
            if 'grouped_inputs' not in device_listing[device_key]:
                if 'device_disabled' not in device_listing[device_key]:
                    disable = True
                    device_listing[device_key]['device_disabled'] = True
                else:
                    disable = None
                    del device_listing[device_key]['device_disabled']
                event_processor.flash_info = False
                event_processor.input_config = (
                    device_key,
                    {'device_disabled': disable}
                )
                event_processor.flash_info = True
            else:
                # ambiguity => enabled
                if 'mixed_disabled' in device_listing[device_key]:
                    disable = None
                    # ambiguity resolved
                    del device_listing[device_key]['mixed_disabled']
                    del device_listing[device_key]['device_disabled']
                elif 'device_disabled' not in device_listing[device_key]:
                    disable = True
                    device_listing[device_key]['device_disabled'] = True
                else:
                    disable = None
                    del device_listing[device_key]['device_disabled']
                event_processor.flash_info = False
                for grouped_device_key, grouped_device in list(device_listing[device_key]['grouped_inputs'].items()):
                    grouped_device['device_disabled'] = disable
                    event_processor.input_config = (
                        grouped_device_key,
                        {'device_disabled': disable}
                    )
                event_processor.flash_info = True
        else:
            log.error('No action associated with this request: {}'.format(request.form))
    render_timestamp = make_timestamp(timestamp=None, as_tz=tz.tzlocal(), make_string=True)
    return render_template('index.html',
                           inputs=device_listing,
                           input_labels=input_labels,
                           awol_inputs=awol_inputs,
                           awol_input_labels=awol_input_labels,
                           meter_history=meter_history,
                           server_context=device_name,
                           render_timestamp=render_timestamp,
                           healthchecks_badges=event_processor.healthchecks_badge_uris)


@flask_app.route('/metrics', methods=['GET', 'POST'])
def show_metrics():
    return redirect(creds.grafana_url, code=302)


@flask_app.route('/event_log', methods=['GET', 'POST'])
def event_log():
    events = {}
    if request.method == 'GET':
        # TODO: configurable
        global event_logger
        events = event_logger.get_events(since_ts=int(
            (datetime.utcnow() - timedelta(hours=24)).strftime('%s')
        ))
    return render_template('event_log.html',
                           events=events)


# TODO: generify
def update_config(event_processor, device_key, request_form):
    try:
        to_save = {}
        if request_form.get('auto_schedule'):
            to_save['auto_schedule'] = True
        else:
            to_save['auto_schedule'] = None
        if len(request_form['auto_schedule_enable']) > 0:
            to_save['auto_schedule_enable'] = request_form['auto_schedule_enable']
        else:
            to_save['auto_schedule_enable'] = None
        if len(request_form['auto_schedule_disable']) > 0:
            to_save['auto_schedule_disable'] = request_form['auto_schedule_disable']
        else:
            to_save['auto_schedule_disable'] = None
        event_processor.flash_info = False
        event_processor.input_config = (
            device_key,
            to_save
        )
        event_processor.flash_info = True
    except ValueError as e:
        exception_msg = "Cannot update '{}'".format(event_processor.input_config[device_key]['device_label'])
        flash(message='{}: {}'.format(exception_msg, str(e)), category='danger')


@flask_app.route('/config', methods=['GET', 'POST'])
def show_config():
    device_listing = {}
    input_labels = {}
    global event_processor
    # type: ignore
    for device_key, device_config in list(event_processor.input_config.items()):
        # exclude invalid types
        if 'type' in device_config and 'button' in device_config['type'].lower():
            continue
        if 'group_name' not in device_config:
            device_listing[device_key] = device_config
        else:
            group_name = device_config['group_name']
            if group_name not in device_listing:
                device_listing[group_name] = {}
                device_listing[group_name]['grouped_inputs'] = {}
            device_listing[group_name]['grouped_inputs'][device_key] = device_config
            if group_name not in input_labels:
                input_labels[group_name] = []
            input_labels[group_name].append(device_config['device_label'])
            # manufacture a device label for the group
            device_listing[group_name]['device_label'] = group_name
            # for group checkbox
            if 'auto_schedule' in device_config and device_config['auto_schedule']:
                device_listing[group_name]['auto_schedule'] = True
    device_key = None
    if request.method == 'POST':
        if 'device_key' in request.form:
            device_key = request.form['device_key']
            # sync up the device model for page load
            device_listing[device_key]['auto_schedule'] = request.form.get('auto_schedule')
            device_listing[device_key]['auto_schedule_enable'] = request.form['auto_schedule_enable']
            device_listing[device_key]['auto_schedule_disable'] = request.form['auto_schedule_disable']
            # open IPC
            auto_scheduler = zmq_socket(zmq.PUSH) # type: ignore
            auto_scheduler.connect(URL_WORKER_AUTO_SCHEDULER)
            # update device configuration
            if 'grouped_inputs' not in device_listing[device_key]:
                update_config(
                    event_processor=event_processor,
                    device_key=device_key,
                    request_form=request.form)
                # reload auto-scheduler
                auto_scheduler.send_pyobj([(device_key, event_processor.input_config[device_key])])
            else:
                for grouped_device_key in list(device_listing[device_key]['grouped_inputs'].keys()):
                    update_config(
                        event_processor=event_processor,
                        device_key=grouped_device_key,
                        request_form=request.form)
                    # reload auto-scheduler
                    auto_scheduler.send_pyobj([(grouped_device_key, event_processor.input_config[grouped_device_key])])
            # close IPC
            auto_scheduler.close()
        else:
            log.error('No action associated with this request: {}'.format(request.form))
    return render_template('config.html',
                           inputs=device_listing,
                           input_labels=input_labels,
                           last_saved_device_key=device_key)


@flask_app.route('/input_config', methods=['GET', 'POST'])
def input_config():
    global event_processor
    device_key = None
    if request.method == 'POST':
        device_key = request.form['device_key']
        try:
            customized = False
            to_save = {}
            if 'group_name' in request.form:
                group_name = request.form['group_name'].strip()
                if len(group_name) > 0:
                    to_save['group_name'] = group_name
                    customized = True
                else:
                    to_save['group_name'] = None
            if device_key in request.form.getlist('info_notify'):
                to_save['info_notify'] = True
                customized = True
            else:
                to_save['info_notify'] = None
            if request.form.get('multi_trigger'):
                to_save['multi_trigger'] = True
                customized = True
            else:
                to_save['multi_trigger'] = None
            if len(request.form['activation_interval']) > 0:
                to_save['activation_interval'] = int(request.form['activation_interval'])
                customized = True
            else:
                to_save['activation_interval'] = None
            if len(request.form['trigger_window']) > 0:
                to_save['trigger_window'] = int(request.form['trigger_window'])
                customized = True
            else:
                to_save['trigger_window'] = None
            if request.form.get('meter_low_limit', None) and len(request.form['meter_low_limit']) > 0:
                to_save['meter_low_limit'] = int(request.form['meter_low_limit'])
                customized = True
            else:
                to_save['meter_low_limit'] = None
            if request.form.get('meter_high_limit', None) and len(request.form['meter_high_limit']) > 0:
                to_save['meter_high_limit'] = int(request.form['meter_high_limit'])
                customized = True
            else:
                to_save['meter_high_limit'] = None
            if request.form.get('meter_reset_value', None) and len(request.form['meter_reset_value']) > 0:
                to_save['meter_reset_value'] = int(request.form['meter_reset_value'])
                customized = True
            else:
                to_save['meter_reset_value'] = None
            if device_key in request.form.getlist('meter_reset_additive'):
                to_save['meter_reset_additive'] = True
                customized = True
            else:
                to_save['meter_reset_additive'] = None
            if request.form.get('meter_iot_topic', None) and len(request.form['meter_iot_topic'].strip()) > 0:
                to_save['meter_iot_topic'] = request.form['meter_iot_topic'].strip()
                customized = True
            else:
                to_save['meter_iot_topic'] = None
            if request.form.get('meter_reading_unit', None) and len(request.form['meter_reading_unit'].strip()) > 0:
                to_save['meter_reading_unit'] = request.form['meter_reading_unit'].strip()
                customized = True
            else:
                to_save['meter_reading_unit'] = None
            if request.form.get('meter_reading_unit_factor', None) and \
                    len(request.form['meter_reading_unit_factor']) > 0:
                meter_reading_unit_factor = int(request.form['meter_reading_unit_factor'])
                if 1 <= meter_reading_unit_factor <= 1000000000 and (meter_reading_unit_factor % 10 == 0):
                    to_save['meter_reading_unit_factor'] = meter_reading_unit_factor
                    customized = True
            else:
                to_save['meter_reading_unit_factor'] = None
            if request.form.get('meter_reading_unit_precision', None) and len(
                    request.form['meter_reading_unit_precision']) > 0:
                meter_reading_unit_precision = int(request.form['meter_reading_unit_precision'])
                if 1 <= meter_reading_unit_precision <= 9:
                    to_save['meter_reading_unit_precision'] = meter_reading_unit_precision
                    customized = True
            else:
                to_save['meter_reading_unit_precision'] = None
            to_save['customized'] = customized
            event_processor.input_config = (
                device_key,
                to_save
            )
        except ValueError as e:
            exception_msg = "Cannot update '{}'".format(event_processor.input_config[device_key]['device_label'])
            flash(message='{}: {}'.format(exception_msg, str(e)), category='danger')
    return render_template('input_config.html',
                           inputs=event_processor.input_config,
                           last_saved_device_key=device_key,
                           default_trigger_window=int(app_config.get('config', 'default_trigger_window')),
                           default_activation_interval=int(app_config.get('config', 'default_activation_interval')))


@flask_app.route('/input_link', methods=['GET', 'POST'])
def input_link():
    global event_processor
    device_key = None
    if request.method == 'POST':
        device_key = request.form['device_key']
        event_processor.input_config = (
            device_key,
            {'linked_inputs': request.form.getlist('linked_input')}
        )
    return render_template('input_link.html',
                           inputs=event_processor.input_config,
                           last_saved_device_key=device_key)


@flask_app.route('/output_link', methods=['GET', 'POST'])
def output_link():
    global event_processor
    device_key = None
    if request.method == 'POST':
        device_key = request.form['device_key']
        event_processor.input_config = (
            device_key,
            {'linked_outputs': request.form.getlist('linked_output')}
        )
    return render_template('output_link.html',
                           inputs=event_processor.input_config,
                           last_saved_device_key=device_key,
                           outputs=event_processor.outputs)


@flask_app.route('/output_config', methods=['GET', 'POST'])
def output_config():
    global event_processor
    device_key = None
    if request.method == 'POST':
        device_key = request.form['device_key']
        to_save = {}
        device_params = request.form['device_params'].strip()
        if len(device_params) > 0:
            to_save['device_params'] = device_params
        else:
            to_save['device_params'] = None
        event_processor.output_config = (
            device_key,
            to_save
        )
    return render_template('output_config.html',
                           outputs=event_processor.output_config,
                           last_saved_device_key=device_key)


def telegram_bot_echo(update: Update, context: TelegramCallbackContext):
    global ngrok_tunnel_url
    try:
        authorized_users = app_config.get('telegram', 'authorized_users').split(',')
        if str(update.effective_user.id) not in authorized_users:
            log.warning('Unauthorized message {}'.format(str(update)))
            return

        log.info('Telegram Bot {} got message {} (chat ID: {}).'.format(context.bot.username,
                                                                        update.effective_message.text,
                                                                        update.effective_message.chat_id))

        group_info = context.bot.get_chat(chat_id=app_config.getint('telegram', 'chat_room_id'))
        bot_response = "I am in the [{}]({}) group.".format(group_info.title, group_info.invite_link)
        dashboard_link = '[Dashboard]({})'.format(ngrok_tunnel_url)
        context.bot.send_message(chat_id=update.effective_message.chat_id,
                         text=bot_response + "\n" + dashboard_link,
                         parse_mode='Markdown')
    except Exception:
        log.exception('bot handler')
        capture_exception()


def telegram_bot_cmd(update: Update, context: TelegramCallbackContext):
    global ngrok_tunnel_url_with_bauth
    try:
        authorized_users = app_config.get('telegram', 'authorized_users').split(',')
        if str(update.effective_user.id) not in authorized_users:
            log.warning('Unauthorized message {}'.format(str(update)))
            return

        log.info('Telegram Bot {} got command {} with args {} (chat ID: {}).'.format(context.bot.username,
                                                                                     update.effective_message.text,
                                                                                     str(context.args),
                                                                                     update.effective_message.chat_id))
        context.bot.send_message(chat_id=update.effective_message.chat_id,
                        text='[Dashboard]({})'.format(ngrok_tunnel_url_with_bauth),
                        parse_mode='Markdown')
        # status update
        if update.effective_message.text.startswith('/report'):
            processor = zmq_socket(zmq.PUSH) # type: ignore
            processor.connect(URL_WORKER_APP)
            processor.send_pyobj({
                device_name: {
                    'data': {
                        'active_devices': [
                            {
                                'device_key': 'App Dash Button',
                                'device_label': 'Dash Button',
                                'type': 'Dash Button'
                            }
                        ]
                    }
                }
            })
            processor.close()
    except Exception:
        log.exception('bot handler')
        capture_exception()


def telegram_bot_inline(update: Update, context: TelegramCallbackContext):
    global ngrok_tunnel_url
    try:
        authorized_users = app_config.get('telegram', 'authorized_users').split(',')
        if str(update.inline_query.from_user.id) not in authorized_users:
            log.warning('Unauthorized message {}'.format(str(update)))
            return

        log.info('Telegram Bot {} got inline query {} from {} {} (location: {}).'.format(context.bot.username,
                                                                                         update.inline_query.query,
                                                                                         update.inline_query.from_user.first_name,
                                                                                         update.inline_query.from_user.last_name,
                                                                                         update.inline_query.location))

        query = update.inline_query.query
        if not query:
            return
        results = [
            InlineQueryResultArticle(
                id=uuid4(),
                title="Dashboard",
                url=ngrok_tunnel_url,
                input_message_content=InputTextMessageContent(
                    query.upper())),
            InlineQueryResultArticle(
                id=uuid4(),
                title="Report",
                input_message_content=InputTextMessageContent(
                    "*{}*".format(escape_markdown(query)),
                    parse_mode=ParseMode.MARKDOWN)),
            InlineQueryResultArticle(
                id=uuid4(),
                title="Panic",
                input_message_content=InputTextMessageContent(
                    "_{}_".format(escape_markdown(query)),
                    parse_mode=ParseMode.MARKDOWN))]
        update.inline_query.answer(results)
    except Exception:
        log.exception('bot handler')
        capture_exception()


def telegram_error_handler(update: Update, context: TelegramCallbackContext):
    try:
        raise context.error
    except NetworkError as e:
        log.warning('Problem with {} network {}: {}'.format(context.bot, update, e.message))
    except TelegramError as e:
        log.warning('Problem with {} processing {}: {}'.format(context.bot, update, e.message))
    except Exception:
        log.exception('bot')
        capture_exception()


class EventProcessor(Thread, Closable):

    def __init__(self, origin_nanny, boto_session, swf_region, swf_domain, mqtt_subscriber):
        name = self.__class__.__name__
        Thread.__init__(self, name=name)
        Closable.__init__(self, name=name)
        self.daemon = True
        threads.threads_tracked.add(self.name)

        self._boto_session = boto_session
        self._swf_region = swf_region
        self._swf_domain = swf_domain

        self.inputs = {}
        self.outputs = {}

        self._input_trigger_history = {}
        self._input_active_history = {}

        self._origin_connections = {}
        self._origin_pull_connections = {}

        self._input_origin = {}
        self._output_origin = {}

        self._inputs_by_origin = {}
        self._outputs_by_origin = {}

        self._awol_inputs = set()
        self._awol_outputs = set()

        self._db_storage = None
        self._ddb_storage = None

        self._general_config = None
        self._general_config_table = None

        self._input_config = None
        self._input_config_table = None

        self._output_config = None
        self._output_config_table = None

        self._output_type_handlers = None

        self.flash_info = True

        self._max_message_validity_seconds = None

        self._device_event_lru = lrucache(100)

        self._origin_nanny = origin_nanny

        self.socket = self.get_socket(zmq.PULL) # type: ignore
        self.socket.bind(URL_WORKER_APP)

        self.event_log = self.get_socket(zmq.PUSH) # type: ignore

        self.bot = self.get_socket(zmq.PUSH) # type: ignore

        self._mqtt_subscriber = mqtt_subscriber

        self._metric_last_posted_meter_value = 0
        self._metric_meter_value_accumulator = 0
        self._metric_last_posted_register_value = 0

        self.healthchecks_badge_uris = app_config.get('app', 'healthchecks_badges').split(',')

        self.influxdb = None
        self.influxdb_rw = None
        self.influxdb_ro = None

    @property
    def origins(self):
        return self._origin_connections.keys()

    @property
    def general_config(self):
        return self._general_config

    @general_config.setter
    def general_config(self, config_update):
        _, _ = config_update
        self._general_config = {}

    @property
    def input_config(self):
        devices = copy.deepcopy(self.inputs)
        devices_config = self._input_config
        for device_key in list(devices.keys()):
            if device_key in devices_config:
                devices[device_key].update(devices_config[device_key])
        return devices

    @input_config.setter
    def input_config(self, config_update):
        device_key, updated_config = config_update
        EventProcessor._update_config(
            device_key=device_key,
            devices=self.inputs,
            device_configs=self._input_config,
            updates=updated_config,
            table_member=self._input_config_table,
            primary_key={'device_key': device_key},
            flash_info=self.flash_info)

    @property
    def output_config(self):
        devices = copy.deepcopy(self.outputs)
        devices_config = self._output_config
        for device_key in list(devices.keys()):
            if device_key in devices_config:
                devices[device_key].update(devices_config[device_key])
        return devices

    @output_config.setter
    def output_config(self, config_update):
        device_key, updated_config = config_update
        EventProcessor._update_config(
            device_key=device_key,
            devices=self.outputs,
            device_configs=self._output_config,
            updates=updated_config,
            table_member=self._output_config_table,
            primary_key={'device_key': device_key},
            flash_info=self.flash_info)

    @property
    def awol_inputs(self):
        return self._awol_inputs

    @staticmethod
    def _update_config(device_key, devices, device_configs, updates, table_member, primary_key, flash_info=True):
        device_label = devices[device_key]['device_label']
        # try to get the existing device config, or create a new mapping
        device_config = {}
        try:
            device_config = device_configs[device_key]
        except KeyError:
            device_configs[device_key] = device_config
        # these are not explicitly configured, but required
        if 'type' in devices[device_key] and 'type' not in device_configs[device_key]:
            updates['type'] = devices[device_key]['type']
        if 'device_label' in devices[device_key] and 'device_label' not in device_configs[device_key]:
            updates['device_label'] = device_label
        try:
            table_name = table_member.table_name
            log.debug("Updating table '{}'...".format(table_name))
            saved = False
            log.debug("Item '{}' to be updated with '{}'".format(primary_key, updates))
            # why no partial_update boto3?
            ddb_set_expression = []
            ddb_remove_expression = []
            attribute_values = {}
            attribute_names = {}
            val_counter = 1
            for key, value in list(updates.items()):
                attribute_holder = ':{}'.format('val'+str(val_counter))
                # reserved word
                if value:
                    ddb_key = '#'+key
                    ddb_set_expression.append('{} = {}'.format(ddb_key, attribute_holder))
                    attribute_names[ddb_key] = key
                    if value is True:
                        attribute_values[attribute_holder] = 1
                    else:
                        attribute_values[attribute_holder] = value
                    val_counter += 1
                else:
                    ddb_remove_expression.append('{}'.format(key))
            ddb_set = ''
            ddb_remove = ''
            if len(ddb_set_expression) > 0:
                ddb_set = 'SET {}'.format(', '.join(ddb_set_expression))
            if len(ddb_remove_expression) > 0:
                ddb_remove = 'REMOVE {}'.format(', '.join(ddb_remove_expression))
            if len(attribute_values) == 0:
                attribute_values = None
            if len(attribute_names) == 0:
                attribute_names = None
            ddb_expression = ''
            if len(ddb_set) > 0:
                ddb_expression = ddb_set
            if len(ddb_remove) > 0:
                if len(ddb_set) > 0:
                    ddb_expression += ' '
                ddb_expression += ddb_remove
            if len(ddb_expression) > 0:
                log.debug('Updating table {} ({}) with {} using {} and {}.'.format(table_name,
                                                                                   primary_key,
                                                                                   ddb_expression,
                                                                                   attribute_names,
                                                                                   attribute_values))
                update_args = {
                    'Key': primary_key,
                    'UpdateExpression': ddb_expression,
                    'ReturnValues': "UPDATED_NEW"
                }
                if attribute_values:
                    update_args.update({'ExpressionAttributeValues': attribute_values})
                if attribute_names:
                    update_args.update({'ExpressionAttributeNames': attribute_names})
                saved = table_member.update_item(**update_args)
            if saved:
                log.debug('Updated {} with {}'.format(table_name, str(saved)))
                if flash_info:
                    flash("Updated '{}'".format(device_label))
                for key, value in list(updates.items()):
                    if value:
                        device_config[key] = value
                    elif key in device_config:
                        del device_config[key]
            else:
                if flash_info:
                    flash("'{}' not updated.".format(device_label), category='warning')
        except Exception as e:
            exception_message = "Cannot update '{}'".format(device_label)
            log.exception(exception_message)
            capture_exception()
            flash(message='{}: {}'.format(exception_message, str(e)), category='danger')

    def _update_devices(self, event_origin, device_info):
        devices_updated = 0
        for input_outputs, device_origin, origin_devices, awol_devices, io in [
            (self.inputs, self._input_origin, self._inputs_by_origin, self._awol_inputs, 'inputs'),
            (self.outputs, self._output_origin, self._outputs_by_origin, self._awol_outputs, 'outputs')
        ]:
            # next if only input or output
            if io not in device_info:
                continue
            for device in device_info[io]:
                try:
                    devices_updated += self._update_device(
                        input_outputs=input_outputs,
                        device_origin=device_origin,
                        origin_devices=origin_devices,
                        event_origin=event_origin,
                        awol_devices=awol_devices,
                        device=device
                    )
                except RuntimeError:
                    log.exception('Bad device @ {}.'.format(device_origin))
        return devices_updated

    def _update_device(self, input_outputs, device_origin, origin_devices, event_origin, awol_devices, device):
        # device_key must always be present
        try:
            device_key = device['device_key']
        except KeyError:
            raise RuntimeError("No device key in {}".format(device))
        # set the device label if that hasn't already been done
        if 'device_label' not in device:
            device['device_label'] = device_key
        # associate the device with this event origin
        if event_origin not in origin_devices:
            origin_devices[event_origin] = set()
        if device_key not in origin_devices[event_origin]:
            origin_devices[event_origin].add(device_key)
        # has this device been awol?
        if device_key in awol_devices:
            log.debug("'{}' is no longer AWOL.".format(device_key))
        awol_devices.discard(device_key)
        # has this device been seen?
        if device_key not in device_origin:
            device_origin[device_key] = event_origin
        elif device_origin[device_key] != event_origin:
            raise RuntimeError("Device with key '{}' is already present at '{}' "
                               "but is also present at '{}' and is ignored.".format(device_key,
                                                                                    device_origin[device_key],
                                                                                    event_origin))
        if device_key not in input_outputs:
            input_outputs[device_key] = device
            return 1
        return 0

    def _process_device_event(self, event_origin, timestamp, active_device_key, active_device):
        if active_device_key in self._input_config and 'linked_outputs' in self._input_config[active_device_key]:
            output_device_keys = self._input_config[active_device_key]['linked_outputs']
            log.debug('{} {} => {}'.format(event_origin, active_device_key, output_device_keys))
            for output_device_key in output_device_keys:
                output_device_activation = {}
                if output_device_key not in self.outputs:
                    log.warning('{} is linked to an unknown output {}'.format(active_device_key,
                                                                              output_device_key))
                    continue
                if output_device_key not in self._output_origin:
                    log.warning('{} {} => {} but nowhere to route the response.'.format(event_origin,
                                                                                        active_device_key,
                                                                                        output_device_key))
                    continue
                # put the event information into the LRU
                self._device_event_lru[active_device_key] = timestamp
                # build up the device activation history
                activation_history = []
                for device_key, activation_time in list(self._device_event_lru.items()):
                    # filter out the device being activated
                    if device_key == active_device_key:
                        continue
                    try:
                        input_device_config = self._input_config[device_key]
                    except KeyError:
                        del self._device_event_lru[device_key]
                        continue
                    # TODO: make this configurable
                    if (timestamp - activation_time).seconds > 5 * 60:
                        continue
                    # TODO: fix
                    try:
                        input_device_label = input_device_config['device_label']
                    except KeyError:
                        log.warning('No label for device {}'.format(active_device_key))
                        input_device_label = active_device_key
                    # list of tuples
                    activation_history.append((
                        input_device_label,
                        (timestamp - activation_time).seconds
                    ))
                # get the event destination
                event_destination = self._output_origin[output_device_key]
                log.info('{} {} => {} {}'.format(
                    event_origin,
                    active_device_key,
                    event_destination,
                    output_device_key))
                # add information about the output device
                output_device_activation.update(self.outputs[output_device_key])
                # add output device configuration, if any
                if output_device_key in self._output_config:
                    output_device_activation.update(self._output_config[output_device_key])
                activation_command = {
                    'trigger_output': output_device_activation,
                    'input_context': active_device,
                    'trigger_history': activation_history,
                }
                trigger_duration = None
                if 'activation_interval' in self._input_config[active_device_key]:
                    trigger_duration = int(
                        self._input_config[active_device_key]['activation_interval']
                    )
                    activation_command['trigger_duration'] = trigger_duration
                # get the output type
                output_device_type = output_device_activation['type'].lower()
                # let the bot know first
                if output_device_type == 'sms':
                    self.bot.send_pyobj({
                        'timestamp': timestamp,
                        'data': activation_command
                    })
                # strip out image data that is no longer needed
                if 'image' in active_device:
                    del active_device['image']
                try:
                    output_device_label = self._output_config[output_device_key]['device_label']
                except KeyError:
                    output_device_label = output_device_key
                log.info('DEBUG: Activation command for {} ({}) ({} mapped in {}) is {}'.format(
                    output_device_key,
                    output_device_label,
                    output_device_type,
                    self._output_type_handlers,
                    activation_command))
                # dispatch the event, test SWF binding
                if output_device_type in self._output_type_handlers:
                    output_type = self._output_type_handlers[output_device_type]
                    log.debug('Active device {}: {} with params {}.'.format(
                        active_device,
                        output_type,
                        output_device_activation))
                    workflow_instance = None
                    if output_type == OUTPUT_TYPE_BLUETOOTH:
                        swf_tasklist = app_config.get('swf_tasklist', OUTPUT_TYPE_BLUETOOTH)
                        with workflow_starter(self._boto_session, self._swf_region, self._swf_domain, app_name) as starter:
                            # pylint: disable=no-value-for-parameter
                            workflow_instance = BluetoothWorkflow.execute(
                                app=swf_tasklist,
                                owner_device_list=self._output_config[output_device_key]['device_params'])
                        SWFActivityWaiter(
                            zmq_ipc_url=URL_WORKER_APP,
                            event_source=swf_tasklist,
                            output_type=OUTPUT_TYPE_BLUETOOTH,
                            workflow_starter=starter,
                            workflow_instance=workflow_instance).start()
                    elif output_type == OUTPUT_TYPE_SNAPSHOT:
                        camera_config = self._output_config[output_device_key]['device_params']
                        with workflow_starter(self._boto_session, self._swf_region, self._swf_domain, app_name) as starter:
                            # pylint: disable=no-value-for-parameter
                            workflow_instance = SnapshotWorkflow.execute(
                                app=app_config.get('swf_tasklist', OUTPUT_TYPE_SNAPSHOT),
                                device_key=output_device_key,
                                device_label=output_device_label,
                                camera_config=camera_config)
                        # image detection
                        image_processor_source = app_config.get('swf_tasklist', OUTPUT_TYPE_IMAGE)
                        with workflow_starter(self._boto_session, self._swf_region, self._swf_domain, app_name) as starter:
                            # pylint: disable=no-value-for-parameter
                            workflow_instance = ImageProcessWorkflow.execute(
                                app=image_processor_source,
                                device_key=output_device_key,
                                device_label=output_device_label,
                                camera_config=camera_config,
                                # pass the address of the device that performs snapshots
                                snapshot_processor_address=self._origin_pull_connections[app_config.get('swf_tasklist', OUTPUT_TYPE_SNAPSHOT)])
                    elif output_type in OUTPUT_TYPE_SWITCH:
                        with workflow_starter(self._boto_session, self._swf_region, self._swf_domain, app_name) as starter:
                            # pylint: disable=no-value-for-parameter
                            workflow_instance = IOBoardWorkflow.execute(
                                app=app_config.get('swf_tasklist', OUTPUT_TYPE_SWITCH),
                                device_key=output_device_key,
                                duration=trigger_duration)
                    elif output_type == OUTPUT_TYPE_TTS:
                        active_device_label = active_device['device_label']
                        event_detail = ""
                        if 'event_detail' in active_device:
                            event_detail = ' {}'.format(active_device['event_detail'])
                        notification_message = '{}{}'.format(active_device_label, event_detail)
                        with workflow_starter(self._boto_session, self._swf_region, self._swf_domain, app_name) as starter:
                            # pylint: disable=no-value-for-parameter
                            workflow_instance = TTSWorkflow.execute(
                                app=app_config.get('swf_tasklist', OUTPUT_TYPE_TTS),
                                message=notification_message)
                    if workflow_instance is not None:
                        # type: ignore
                        log.info("{} workflow is {}".format(output_type, workflow_instance.workflow_execution))
                elif event_destination == device_name:
                    #TODO: route this properly
                    log.warning('Not dispatching event to self: {} {} => {}.'.format(event_origin,
                                                                                     active_device_key,
                                                                                     output_device_key))
                else:
                    log.warning('{} {} => {} but nowhere to route the response.'.format(event_origin,
                                                                                        active_device_key,
                                                                                        output_device_key))
                # add an entry into the event log
                try:
                    input_device_label = self._input_config[active_device_key]['device_label']
                except KeyError:
                    input_device_label = active_device_key
                self.event_log.send_pyobj({
                    'timestamp': timestamp,
                    'input_device': input_device_label,
                    'output_device': output_device_label,
                })
        else:
            log.warning('{} is not configured or linked to any output: {}'.format(active_device_key, active_device))

    def _load_config_table(self, table_name, primary_key='device_key'):
        log.info("Loading Dynamo table '{}'...".format(table_name))
        member_table = self._ddb_storage.Table(table_name)
        member = {}
        scan_response = member_table.scan()
        for result in scan_response['Items']:
            device_key = None
            member_config = {}
            for key, value in list(result.items()):
                if key == primary_key:
                    device_key = value
                else:
                    member_config.update([(key, value)])
            if device_key and len(member_config) > 0:
                member[device_key] = member_config
        log.info("Loaded {} items from table '{}'".format(len(scan_response['Items']), table_name))
        return member, member_table

    def _influxdb_write(self, bucket, active_device_key, field_name, field_value):
        measurement_name = '_'.join(active_device_key.split()).lower()
        self.influxdb_rw.write(
            bucket=bucket,
            record=Point(measurement_name).tag("application", app_name).tag("device", device_name_base).field(field_name, field_value))

    # noinspection PyBroadException
    def run(self):
        # set up local DB storage
        self._db_storage = sqlite3.connect(database=os.environ['TABLESPACE_PATH'])
        # connect to AWS services
        self._ddb_storage = boto3.resource('dynamodb')
        # load configuration data
        self._general_config, self._general_config_table = self._load_config_table(
            table_name=os.environ['CONFIG_TABLE_GENERAL'],
            primary_key='config_key')
        self._input_config, self._input_config_table = self._load_config_table(
            table_name=os.environ['CONFIG_TABLE_INPUT'])
        self._output_config, self._output_config_table = self._load_config_table(
            table_name=os.environ['CONFIG_TABLE_OUTPUT'])
        # event log
        self.event_log.connect(URL_WORKER_EVENT_LOG)
        # bot
        self.bot.connect(URL_WORKER_TELEGRAM_BOT)
        # influx DB
        self.influxdb = InfluxDBClient(
            url=app_config.get('influxdb', 'url'),
            token=creds.influxdb_token,
            org=creds.influxdb_org)
        self.influxdb_rw = self.influxdb.write_api(write_options=ASYNCHRONOUS)
        self.influxdb_ro = self.influxdb.query_api()
        # load auto-scheduler
        auto_scheduler = zmq_socket(zmq.PUSH) # type: ignore
        auto_scheduler.connect(URL_WORKER_AUTO_SCHEDULER)
        auto_scheduler.send_pyobj(self._input_config)
        auto_scheduler.close()
        # informational notifications
        # TODO: move to UI configuration
        self.notify_not_before_time = make_timestamp(app_config.get('info_notify', 'not_before_time'))
        self.notify_not_after_time = make_timestamp(app_config.get('info_notify', 'not_after_time'))
        # message validity
        self._max_message_validity_seconds = int(app_config.get('app', 'max_message_validity_seconds'))
        # output type handlers
        self._output_type_handlers = dict()
        for output_type_handler in [OUTPUT_TYPE_BLUETOOTH, OUTPUT_TYPE_SWITCH, OUTPUT_TYPE_SNAPSHOT, OUTPUT_TYPE_TTS]:
            output_types = app_config.get('output_types', output_type_handler).lower().split(',')
            for output_type in output_types:
                self._output_type_handlers[output_type] = output_type_handler
        # set up the special input for the panic button
        self._update_device(
            input_outputs=self.inputs,
            device_origin=self._input_origin,
            origin_devices=self._inputs_by_origin,
            event_origin=device_name,
            awol_devices=self._awol_inputs,
            device={
                'device_key': 'App Panic Button',
                'device_label': 'Panic Button',
                'type': 'Panic Button'
            })
        # set up the special input for the dash button
        self._update_device(
            input_outputs=self.inputs,
            device_origin=self._input_origin,
            origin_devices=self._inputs_by_origin,
            event_origin=device_name,
            awol_devices=self._awol_inputs,
            device={
                'device_key': 'App Dash Button',
                'device_label': 'Dash Button',
                'type': 'Dash Button'
            })
        # set up special output for SMS (text notifications)
        self._update_device(
            input_outputs=self.outputs,
            device_origin=self._output_origin,
            origin_devices=self._outputs_by_origin,
            event_origin=device_name,
            awol_devices=self._awol_outputs,
            device={
                'device_key': 'SMS',
                'device_label': 'SMS',
                'type': 'SMS'
            })
        while True:
            try:
                event = self.socket.recv_pyobj()
                log.debug(event)
                if isinstance(event, dict):
                    for event_origin, event_data in list(event.items()):
                        if not isinstance(event_data, dict):
                            log.warning('Ignoring non-dict event format from {}: {} ({})'.format(
                                event_origin, event_data.__class__, event_data))
                            continue
                        if 'timestamp' in event_data:
                            str_timestamp = event_data['timestamp']
                            log.debug('{} timestamp is {}'.format(event_origin, str_timestamp))
                            timestamp = make_timestamp(str_timestamp)
                        else:
                            timestamp = make_timestamp()
                            log_msg = "Message from {} does not include a 'timestamp' so it can't be filtered if it " \
                                      "is stale. Using {}.".format(event_origin, timestamp.strftime(ISO_DATE_FORMAT))
                            if 'data' in event_data and 'active_devices' in event_data['data']:
                                log.warning(log_msg)
                            else:
                                log.debug(log_msg)
                        if 'register_origin' == event_origin:
                            # connect to event origins
                            for origin, ip in list(event_data.items()):
                                connection_string = 'tcp://{}:{}'.format(ip, app_config.get('zmq', 'pubsub_port'))
                                subscriber = ZmqEventSourceSubscriber(label=origin, publisher_endpoint=connection_string)
                                subscriber.start()
                                threads.threads_tracked.add(subscriber.getName())
                                # nanny the heartbeats
                                self._origin_nanny.add_origin_subscriber(origin=origin, ip=ip, subscriber=subscriber)
                                # keep track of the available event origins
                                self._origin_connections[origin] = connection_string
                                self._origin_pull_connections[origin] = 'tcp://{}:{}'.format(ip, app_config.get('zmq', 'pushpull_port'))
                            continue
                        if 'register_mqtt_origin' == event_origin:
                            # connect to event origins
                            for mqtt_topic, device_id in list(event_data.items()):
                                subscriber = MqttEventSourceSubscriber(mqtt_topic=mqtt_topic, device_id=device_id)
                                # nanny the heartbeats
                                self._origin_nanny.add_origin_subscriber(origin=mqtt_topic, ip=None, subscriber=subscriber)
                                # keep the heartbeats up to date
                                self._mqtt_subscriber.add_source_subscriber(topic=mqtt_topic, subscriber=subscriber)
                            continue
                        if 'auto-scheduler' == event_origin:
                            device_key = event_data['device_key']
                            device_disable = not event_data['device_state']
                            event_processor.flash_info = False
                            log.info('Updating device {}; disable: {}'.format(device_key, device_disable))
                            try:
                                event_processor.input_config = (
                                    device_key,
                                    {'device_disabled': device_disable}
                                )
                            except KeyError:
                                log.exception('Problem with device {}: {}'.format(device_key, str(event_data)))
                            event_processor.flash_info = True
                            # skip further processing because of enable/disable
                            continue
                        if 'sqs' == event_origin:
                            device_disable = None
                            if 'enable' in event_data:
                                device_disable = False
                            elif 'disable' in event_data:
                                device_disable = True
                            # dash button
                            if 'dash_button' in event_data:
                                log.info('Dash button event: {}'.format(event_data['dash_button']))
                                # splice in a new event
                                event_origin = device_name
                                event_data.update({
                                    'data': {
                                        'active_devices': [
                                            {
                                                'device_key': 'App Dash Button',
                                                'device_label': 'Dash Button',
                                                'type': 'Dash Button',
                                                'dash_button': event_data['dash_button']
                                            }
                                        ]
                                    }
                                })
                                # splice in device descriptions
                                #TODO: configurable somehow
                                event_data['device_description'] = ['House Security']
                            if device_disable is not None:
                                # this is a fuzzy name that refers to either a group or specific device
                                device_descriptions = None
                                if 'device_description' in event_data:
                                    device_descriptions = event_data['device_description']
                                if device_descriptions is None:
                                    log.warning('No valid device description found in SQS message: {}'.format(event_data))
                                    continue
                                event_processor.flash_info = False
                                devices_updated = 0
                                for device_description in device_descriptions:
                                    for device_key, device_config in list(self._input_config.items()):
                                        device_name_match = False
                                        device_name_test = device_config['device_label'].lower()
                                        # custom skill
                                        if device_name_test.startswith(device_description.lower()):
                                            device_name_match = True
                                        # smart home skill device ID
                                        elif device_name_test\
                                                .replace(' ', '_')\
                                                .replace('(', '#')\
                                                .replace(')', '#') == device_description:
                                            device_name_match = True
                                        elif 'group_name' in device_config and device_config['group_name']:
                                            device_name_test = device_config['group_name'].lower()
                                            if device_name_test.startswith(device_description.lower()):
                                                device_name_match = True
                                            elif device_name_test\
                                                    .replace(' ', '_')\
                                                    .replace('(', '#')\
                                                    .replace(')', '#') == device_description:
                                                device_name_match = True
                                        if device_name_match:
                                            # device matches our description
                                            log.info(
                                                'Updating device {} based on matching description {}; '
                                                'disable: {}'.format(device_key, device_description, device_disable))
                                            try:
                                                event_processor.input_config = (
                                                    device_key,
                                                    {'device_disabled': device_disable}
                                                )
                                                devices_updated += 1
                                            except KeyError:
                                                log.exception('Problem with device {}: {}'.format(device_key,
                                                                                                  str(event_data)))
                                if devices_updated > 0:
                                    state_change = 'Enabled'
                                    if device_disable is True:
                                        state_change = 'Disabled'
                                    self.bot.send_pyobj({
                                        'message': '{} notifications for {} devices.'.format(state_change,
                                                                                             devices_updated),
                                    })
                                event_processor.flash_info = True
                                # skip further processing because of enable/disable
                                continue
                        if 'data' in event_data:
                            if 'stale_heartbeat' in event_data['data']:
                                stale_heartbeat = event_data['data']['stale_heartbeat']
                                device_status = "unknown"
                                if 'device_status' in event_data['data']:
                                    device_status = event_data['data']['device_status']
                                # check if there are any inputs or outputs configured for this origin
                                for _, origin_devices, awol_devices in [
                                    (self.inputs, self._inputs_by_origin, self._awol_inputs),
                                    (self.outputs, self._outputs_by_origin, self._awol_outputs)
                                ]:
                                    new_awol = 0
                                    if event_origin in origin_devices and len(origin_devices[event_origin]) > 0:
                                        log.debug("'{}' last checked-in: {} in an '{}' state.".format(
                                            event_origin,
                                            stale_heartbeat,
                                            device_status.lower()))
                                        for device_key in origin_devices[event_origin]:
                                            if device_key not in awol_devices:
                                                awol_devices.add(device_key)
                                                new_awol += 1
                                    if new_awol > 0:
                                        log.warning(
                                            "{} devices are unavailable because '{}' has gone AWOL. "
                                            "{} devices: {}. Last seen: {}, status: {}".format(
                                                len(awol_devices),
                                                event_origin,
                                                new_awol,
                                                str(awol_devices),
                                                stale_heartbeat,
                                                device_status
                                            ))
                            if 'max_heartbeat_age' in event_data['data']:
                                heartbeat_age = int(event_data['data']['max_heartbeat_age'])
                                post_count_metric(
                                    metric_name='Heartbeat Age',
                                    count=heartbeat_age,
                                    unit='Seconds')
                            if 'device_info' in event_data['data']:
                                devices_updated = self._update_devices(
                                    event_origin=event_origin,
                                    device_info=event_data['data']['device_info'])
                                if devices_updated > 0:
                                    log.info('{} advertised {} new devices.'.format(event_origin, devices_updated))
                            if 'active_devices' in event_data['data']:
                                for active_device in event_data['data']['active_devices']:
                                    # patch in top-level data, if any
                                    if 'storage_url' in event_data['data']:
                                        active_device['storage_url'] = event_data['data']['storage_url']
                                    active_device_key = active_device['device_key']
                                    # input known?
                                    if active_device_key not in self._input_config:
                                        log.warning(
                                            "Input device '{}' is not configured, ignoring.".format(active_device_key))
                                        continue
                                    # message stale?
                                    message_age = make_timestamp() - timestamp
                                    if message_age > timedelta(seconds=self._max_message_validity_seconds):
                                        log.warning('Skipping further processing of {} from {} due to message age '
                                                 '{} exceeding {} seconds.'.format(
                                            active_device_key,
                                            event_origin,
                                            message_age.seconds,
                                            self._max_message_validity_seconds))
                                        continue
                                    active_device_config = self._input_config[active_device_key]
                                    # always process a fresh meter update
                                    if 'type' in active_device and 'meter' in active_device['type'].lower():
                                        meter_value = int(active_device['sample_values']['meter'])
                                        register_value = int(active_device['sample_values']['register'])
                                        if (register_value < 0):
                                            # TODO: reset to knkown value
                                            log.debug('Resetting negative {} meter register value {} to 0.'.format(active_device_key, register_value))
                                            register_value = 0
                                        meter_reading_unit = ''
                                        if 'meter_reading_unit' in active_device_config:
                                            meter_reading_unit = ' ' + active_device_config['meter_reading_unit']
                                        meter_reading_unit_factor = 1
                                        if 'meter_reading_unit_factor' in active_device_config:
                                            meter_reading_unit_factor = active_device_config[
                                                'meter_reading_unit_factor']
                                        meter_reading_unit_precision = 0
                                        if 'meter_reading_unit_precision' in active_device_config:
                                            meter_reading_unit_precision = active_device_config[
                                                'meter_reading_unit_precision']
                                        number_format_string = "{:." + str(meter_reading_unit_precision) + "f}"
                                        # create normalized values
                                        normalized_register_value = int(register_value) / float(meter_reading_unit_factor)
                                        # update but do not persist
                                        active_device_config.update({
                                            'meter_value': register_value,
                                            'meter_reading': number_format_string.format(normalized_register_value) + meter_reading_unit
                                        })
                                        # post metric every n-minutes
                                        now = time.time()
                                        # accumulated meter value
                                        if now - self._metric_last_posted_meter_value > 5*60:
                                            self._influxdb_write(
                                                bucket='meter',
                                                active_device_key=active_device_key,
                                                field_name='metered',
                                                field_value=int(self._metric_meter_value_accumulator) / float(meter_reading_unit_factor))
                                            self._metric_last_posted_meter_value = now
                                            self._metric_meter_value_accumulator = 0
                                        else:
                                            self._metric_meter_value_accumulator += meter_value
                                        # register values
                                        if now - self._metric_last_posted_register_value > 5*60:
                                            self._influxdb_write(
                                                bucket='meter',
                                                active_device_key=active_device_key,
                                                field_name='register',
                                                field_value=normalized_register_value)
                                            self._metric_last_posted_register_value = now
                                    # input disabled?
                                    if 'device_disabled' in active_device_config:
                                        continue
                                    # only consider a meter active if the value is out of bounds
                                    if 'type' in active_device and 'meter' in active_device['type'].lower():
                                        out_of_range = False
                                        if 'meter_low_limit' in active_device_config:
                                            if meter_value < active_device_config['meter_low_limit']:
                                                out_of_range = True
                                        if 'meter_high_limit' in active_device_config:
                                            if meter_value > active_device_config['meter_high_limit']:
                                                out_of_range = True
                                        if not out_of_range:
                                            continue
                                    # multi-trigger
                                    if 'multi_trigger' in active_device_config:
                                        if 'trigger_window' in active_device_config:
                                            trigger_window = active_device_config['trigger_window']
                                        else:
                                            trigger_window = int(app_config.get('config', 'default_trigger_window'))
                                        # if not in the trigger history, treat as never activated
                                        if active_device_key not in self._input_trigger_history:
                                            self._input_trigger_history[active_device_key] = time.time()
                                            continue
                                        input_last_triggered = self._input_trigger_history[active_device_key]
                                        # the device must have been considered active within the trigger window
                                        last_triggered = time.time() - input_last_triggered
                                        if last_triggered > trigger_window:
                                            # update the history and continue
                                            self._input_trigger_history[active_device_key] = time.time()
                                            log.debug('Not activating {} because it was triggered '
                                                      'more than {} seconds ago. ({})'.format(active_device_key,
                                                                                              trigger_window,
                                                                                              last_triggered))
                                            continue
                                    # get the event detail for debouncing
                                    event_detail = None
                                    if 'event_detail' in active_device:
                                        event_detail = active_device['event_detail']
                                    # debounce
                                    if active_device_key in self._input_active_history:
                                        # debounce this input
                                        if active_device_key in self._input_config and 'activation_interval' in active_device_config:
                                            activation_interval = active_device_config['activation_interval']
                                        else:
                                            activation_interval = int(
                                                app_config.get('config', 'default_activation_interval'))
                                        input_last_active, last_event_detail = self._input_active_history[
                                            active_device_key]
                                        if last_event_detail == event_detail:
                                            last_activated = time.time() - input_last_active
                                            if last_activated < activation_interval:
                                                # device is still considered active
                                                log.debug('Not activating {} ({}) because it was triggered '
                                                          'less than {} seconds ago. ({})'.format(active_device_key,
                                                                                                  last_event_detail,
                                                                                                  activation_interval,
                                                                                                  last_activated))
                                                continue
                                    self._input_active_history[active_device_key] = (time.time(), event_detail)
                                    # active devices are presently assumed to be inputs
                                    self._update_device(
                                        input_outputs=self.inputs,
                                        device_origin=self._input_origin,
                                        origin_devices=self._inputs_by_origin,
                                        event_origin=event_origin,
                                        awol_devices=self._awol_inputs,
                                        device=active_device)
                                    # informational event?
                                    # TODO: move to _process_device_event
                                    if 'info_notify' in active_device_config:
                                        # make a future date that is relative (after) now time.
                                        now = datetime.now().replace(tzinfo=tz.tzlocal())
                                        not_before = now.replace(
                                            hour=self.notify_not_before_time.hour,
                                            minute=self.notify_not_before_time.minute,
                                            second=0,
                                            microsecond=0)
                                        not_after = now.replace(
                                            hour=self.notify_not_after_time.hour,
                                            minute=self.notify_not_after_time.minute,
                                            second=0,
                                            microsecond=0)
                                        defer_until = None
                                        if now < not_before:
                                            defer_until = not_before
                                        if now >= not_after:
                                            # the not-before time may not be on the same day
                                            defer_until = not_before + timedelta(days=1)
                                        if defer_until:
                                            # defer the notification
                                            log.info("Deferring notification for '{}' until {}".format(
                                                active_device_key,
                                                defer_until))
                                            continue
                                    self._process_device_event(
                                        event_origin=event_origin,
                                        timestamp=timestamp,
                                        active_device_key=active_device_key,
                                        active_device=active_device)
            except ContextTerminated:
                self.close()
                break
            except Exception:
                log.exception(self.__class__.__name__)
                capture_exception()
                sleep(1)
                continue


class EventLog(Thread):

    def __init__(self):
        super(EventLog, self).__init__(name=self.__class__.__name__)
        self.daemon = True
        threads.threads_tracked.add(self.name)

        self._ddb_storage = None
        self._event_log_table = None
        self._metric_last_posted_device_event = 0
        self._device_events_accumulator = 0

        self.socket = zmq_socket(zmq.PULL) # type: ignore
        self.socket.bind(URL_WORKER_EVENT_LOG)

    def get_events(self, since_ts):
        event_data = self._event_log_table.scan(FilterExpression=Attr('timestamp').gte(since_ts))
        # extract the event data from the result set
        events = []
        for event in event_data['Items']:
            timestamp = event['timestamp']
            # noinspection PyTypeChecker
            events.append((
                int(timestamp),
                event['input_device'],
                event['output_device'],
                make_timestamp(float(timestamp)).astimezone(tz=tz.tzlocal()).strftime('%c')
            ))
        # reorder based on the timestamp
        return sorted(events, key=itemgetter(0, 1, 2), reverse=True)

    # noinspection PyBroadException
    def run(self):
        # connect to AWS services
        self._ddb_storage = boto3.resource('dynamodb')
        self._event_log_table = self._ddb_storage.Table('event_log')
        while True:
            try:
                event = self.socket.recv_pyobj()
                log.debug(event)
                timestamp = event['timestamp']
                # work around Python's brain-dead date handling
                unix_timestamp = make_unix_timestamp(timestamp)
                put_args = {'Item': {}}
                put_args['Item'].update({
                    # pad some millis for the actual insertion time to avoid key conflicts
                    'timestamp': Decimal('{}.{}'.format(unix_timestamp, datetime.now().microsecond)),
                    'input_device': event['input_device'],
                    'output_device': event['output_device'],
                })
                saved = self._event_log_table.put_item(**put_args)
                if not saved:
                    log.warning('Unable to save event log entry: {}'.format(event))
                    continue
                now = time.time()
                if now - self._metric_last_posted_device_event > 5*60:
                    post_count_metric(metric_name='Device Event')
                    self._metric_last_posted_device_event = now
                    self._device_events_accumulator = 0
                else:
                    self._device_events_accumulator += 1
            except ContextTerminated:
                log.warning('ZMQ terminate: {}'.format(self.__class__.__name__))
                self.socket.close()
                log.warning('ZMQ terminated: {}'.format(self.__class__.__name__))
                break
            except Exception:
                log.exception(self.__class__.__name__)
                capture_exception()
                sleep(1)
                continue


class TBot(Thread):

    def __init__(self):
        super(TBot, self).__init__(name=self.__class__.__name__)
        self.daemon = True
        threads.threads_tracked.add(self.name)

        self.bot = None
        self.chat_id = app_config.getint('telegram', 'chat_room_id')
        self.socket = zmq_socket(zmq.PULL) # type: ignore
        self.socket.bind(URL_WORKER_TELEGRAM_BOT)

        self.sns = boto3.client('sns')

    def build_message(self, timestamp, event_data, max_length=160, build_sms=False):
        global ngrok_tunnel_url
        device_label = event_data['input_context']['device_label']
        event_detail = ""
        if 'event_detail' in event_data['input_context']:
            event_detail = ' {}'.format(event_data['input_context']['event_detail'])
        # include a timestamp in this SMS message
        notification_message = '{}{} ({}:{})'.format(
            device_label,
            event_detail,
            timestamp.hour,
            str(timestamp.minute).zfill(2))
        footer = ''
        # add in the callback URL
        if build_sms and ngrok_tunnel_url:
            footer = "\n{}".format(ngrok_tunnel_url)
        if not build_sms and 'storage_url' in event_data['input_context']:
            notification_message = '[{}]({})'.format(notification_message, event_data['input_context']['storage_url'])
        # add in some trigger history for context
        if 'trigger_history' in event_data:
            for history_device_label, trigger_secs_ago in event_data['trigger_history']:
                history_info = "\n{}s ago: {}".format(trigger_secs_ago, history_device_label)
                if len(notification_message) + len(history_info) + len(footer) >= max_length:
                    break
                notification_message += history_info
        notification_message += footer
        return notification_message

    # noinspection PyBroadException
    def run(self):
        global ngrok_tunnel_url_with_bauth
        # connect to Telegram
        self.bot = TelegramBot(token=creds.telegram_bot_api_token)
        while True:
            try:
                event = self.socket.recv_pyobj()
                #TODO: fix me for small payloads
                #log.debug(event)
                if 'timestamp' in event:
                    timestamp = parse_datetime(value=event['timestamp'], as_tz=tz.tzlocal())
                else:
                    timestamp = make_timestamp().astimezone(tz=tz.tzlocal())
                event_data = None
                # build the message
                image_data = None
                if 'message' in event:
                    notification_message = event['message']
                    if 'add_tunnel_url' in event:
                        notification_message = '[{}]({})'.format(notification_message, ngrok_tunnel_url_with_bauth)
                elif 'data' in event:
                    event_data = event['data']
                    notification_message = self.build_message(timestamp=timestamp,
                                                              event_data=event_data,
                                                              max_length=200)
                    if 'image' in event_data['input_context']:
                        image_data = BytesIO(event_data['input_context']['image'])

                # send the message
                try:
                    if image_data:
                        log.debug("Bot sends image to {} with caption '{}'".format(str(self.chat_id),
                                                                                   notification_message))
                        self.bot.send_photo(chat_id=self.chat_id,
                                            photo=image_data,
                                            caption=notification_message,
                                            parse_mode='Markdown')
                    else:
                        log.debug("Bot says to {}: '{}'".format(str(self.chat_id), notification_message))
                        self.bot.send_message(chat_id=self.chat_id,
                                              text=notification_message,
                                              parse_mode='Markdown')
                except (TimedOut, NetworkError):
                    log.warning('Timeout or network problem using Bot. Fallback back to SMS.')
                    if event_data:
                        # rebuild the message for SMS
                        notification_message = self.build_message(timestamp=timestamp,
                                                                  event_data=event_data,
                                                                  build_sms=True)
                        if 'device_params' not in event_data['trigger_output']:
                            raise RuntimeError('Cannot send SMS because no parameters are configured.')
                        recipients = event_data['trigger_output']['device_params'].strip().split(',')
                        for recipient in recipients:
                            name_number = recipient.split(';')
                            log.info("SMS {} ({}) '{}'".format(name_number[0], name_number[1], notification_message))
                            try:
                                resp = self.sns.publish(PhoneNumber=name_number[1], Message=notification_message)
                                log.info('SMS sent: {}'.format(str(resp)))
                            except Exception:
                                log.exception('Cannot send SMS {}: {}'.format(name_number[1], notification_message))
                    else:
                        log.error('No viable method to send notification for event: {}'.format(notification_message))
            except ContextTerminated:
                log.warning('ZMQ terminate: {}'.format(self.__class__.__name__))
                self.socket.close()
                log.warning('ZMQ terminated: {}'.format(self.__class__.__name__))
                break
            except Exception:
                log.exception(self.__class__.__name__)
                capture_exception()
                sleep(1)
                continue


class MqttSubscriber(Thread):

    def __init__(self):
        super(MqttSubscriber, self).__init__(name=self.__class__.__name__)
        self.daemon = True
        threads.threads_tracked.add(self.name)

        self.processor = zmq_socket(zmq.PUSH) # type: ignore
        self._mqtt_client = None
        self._mqtt_server_address = app_config.get('mqtt', 'server_address')
        self._mqtt_subscribe_topics = list()
        # match Paho interface
        for mqtt_source in app_config.get('mqtt', 'subscription_sources').split(','):
            self._mqtt_subscribe_topics.append((mqtt_source, 0))
        self._source_subscribers = dict()
        # IPC for publish
        self.socket = zmq_socket(zmq.PULL) # type: ignore
        self.socket.bind(URL_WORKER_MQTT_PUBLISH)

    def add_source_subscriber(self, topic, subscriber):
        self._source_subscribers[topic] = subscriber

    def on_connect(self, client, userdata, flags, rc):
        log.info('Subscribing to topics {}'.format(self._mqtt_subscribe_topics))
        self._mqtt_client.subscribe(self._mqtt_subscribe_topics)

    def on_disconnect(self, client, userdata, rc):
        log.info('MQTT client has disconnected.')

    def on_message(self, client, userdata, msg):
        log.debug('{} received {} bytes.'.format(msg.topic, len(msg.payload)))
        msg_data = None
        try:
            msg_data = json.loads(msg.payload)
        except JSONDecodeError:
            log.exception('Unstructured message: {}'.format(msg.payload))
            return
        # ignore any message without a device ID
        if 'device_id' not in msg_data:
            log.warning('Ignoring {} bytes from topic {} with no device_id set.'.format(len(msg.payload), msg.topic))
            return
        device_id = msg_data['device_id']
        input_location = msg_data['input_location']
        # FIXME: create a canonical topic form
        topic_base = '/'.join(msg.topic.split('/')[0:2])
        # get the subscriber and update the timestamp
        if topic_base in self._source_subscribers:
            subscriber = self._source_subscribers[topic_base]
            subscriber.last_message = time.time()
        event_timestamp = make_timestamp()
        # unpack the message
        try:
            if msg.topic.startswith('sensor'):
                device_inputs = list()
                active_devices = list()
                for msg_key in msg_data:
                    # look for inputs
                    if re.match("input_\d+", msg_key): # pylint: disable=anomalous-backslash-in-string
                        input_label = msg_data[msg_key]['input_label']
                        sample_value = msg_data[msg_key]['sample_value']
                        input_active = msg_data[msg_key]['active']
                        device_description = {
                            'type': input_label,
                            'location': input_location,
                            'device_key': '{} {}'.format(input_location, input_label)
                        }
                        if input_active:
                            log.info('{}: {} {} ({})'.format(device_id, input_location, input_label, sample_value))
                            device_description['sample_value'] = sample_value
                            active_devices.append(device_description)
                        else:
                            device_inputs.append(device_description)
                self.processor.send_pyobj({
                    topic_base: {
                        'data': {
                            'device_info': {'inputs': device_inputs},
                            'active_devices': active_devices
                        },
                        'timestamp': event_timestamp
                    }
                })
            elif msg.topic.startswith('meter'):
                topic_parts = msg.topic.split('/')
                device_type = topic_parts[0]
                device_name = topic_parts[1]
                device_key = '{} {}'.format(device_name, device_type).title()
                metered = msg_data['last_minute_metered']
                register = msg_data['register_reading']
                log.debug('{}: {} ({} of {})'.format(device_id, input_location, metered, register))
                self.processor.send_pyobj({
                    topic_base: {
                        'data': {
                            'device_info': {
                                'inputs': [{
                                    'device_key': device_key,
                                    'type': 'meter'
                                }]
                            },
                            'active_devices': [{
                                'device_key': device_key,
                                'type': 'meter',
                                'sample_values': {
                                    'meter': metered,
                                    'register': register
                                }
                            }]
                        },
                        'timestamp': event_timestamp
                    }
                })
        except ContextTerminated:
            log.warning('ZMQ terminated: {}'.format(self.__class__.__name__))

    # noinspection PyBroadException
    def run(self):
        log.info('Connecting to MQTT server {}...'.format(self._mqtt_server_address))
        self._mqtt_client = mqtt.Client()
        self._mqtt_client.on_connect = self.on_connect
        self._mqtt_client.on_disconnect = self.on_disconnect
        self._mqtt_client.on_message = self.on_message
        self._mqtt_client.connect(self._mqtt_server_address)
        self.processor.connect(URL_WORKER_APP)
        while True:
            try:
                self._mqtt_client.loop()
                # check for messages to publish
                try:
                    mqtt_pub_topic, message_data = self.socket.recv_pyobj(flags=zmq.NOBLOCK) # type: ignore
                    log.debug('Publishing {} bytes to topic {}...'.format(len(message_data), mqtt_pub_topic))
                    self._mqtt_client.publish(topic=mqtt_pub_topic, payload=message_data)
                except ZMQError:
                    # ignore, no data
                    pass
                # test for application shutdown
                if threads.shutting_down:
                    log.warning('App terminate: {}'.format(self.__class__.__name__))
                    self.socket.close()
                    self._mqtt_client.disconnect()
                    self.processor.close()
                    log.warning('App terminated: {}'.format(self.__class__.__name__))
                    break
            except ContextTerminated:
                log.warning('ZMQ terminate: {}'.format(self.__class__.__name__))
                self.socket.close()
                self._mqtt_client.disconnect()
                self.processor.close()
                log.warning('ZMQ terminated: {}'.format(self.__class__.__name__))
                break
            except ZMQError:
                log.exception(self.name)
                break
            except Exception:
                # consider mqttc.reinitialise()
                log.exception(self.name)
                capture_exception()
                sleep(1)
                continue


class EventSourceSubscriber(object):

    def __init__(self, label):
        self._label = label
        self.last_message = None

    @property
    def label(self):
        return self._label


class MqttEventSourceSubscriber(EventSourceSubscriber):

    def __init__(self, mqtt_topic, device_id):
        super(MqttEventSourceSubscriber, self).__init__(label=mqtt_topic)
        self._device_id = device_id

    @property
    def device_id(self):
        return self._device_id


class ZmqEventSourceSubscriber(EventSourceSubscriber, Thread):

    def __init__(self, label, publisher_endpoint):
        EventSourceSubscriber.__init__(self, label=label)
        Thread.__init__(self)
        self.name = '{}::{}'.format(self.__class__.__name__, label)
        self.daemon = True

        self._publisher_endpoint = publisher_endpoint

        self.subscriber = zmq_socket(zmq.SUB) # type: ignore
        self.processor = zmq_socket(zmq.PUSH) # type: ignore

        self._reconnected = False
        # use half of the tolerated heartbeat value
        self._zmq_poll_period = int(app_config.get('app', 'max_heartbeat_delay_seconds')) / 2

    # noinspection PyBroadException
    def run(self):
        log.info('Subscribing to {} @ {}'.format(self._label, self._publisher_endpoint))
        self.subscriber.connect(self._publisher_endpoint)
        self.subscriber.setsockopt(zmq.SUBSCRIBE, b'') # type: ignore
        self.processor.connect(URL_WORKER_APP)
        while True:
            try:
                # timeout in millis
                zmq_events = self.subscriber.poll(timeout=self._zmq_poll_period * 1000)
                # TODO: remove nanny
                if zmq_events == 0:
                    log.info('{} reconnecting to {} after more than {} seconds of inactivity...'.format(
                        self.name,
                        self._publisher_endpoint,
                        self._zmq_poll_period))
                    try:
                        self.subscriber.close()
                    except ZMQError:
                        log.exception(self.name)
                    self.subscriber = zmq_socket(zmq.SUB) # type: ignore
                    self.subscriber.connect(self._publisher_endpoint)
                    self.subscriber.setsockopt(zmq.SUBSCRIBE, b'') # type: ignore
                    self._reconnected = True
                    # poll again
                    continue
                try:
                    publisher_data = self.subscriber.recv(zmq.NOBLOCK) # type: ignore
                    publisher_event = umsgpack.unpackb(publisher_data)
                except Again as e:
                    log.debug('{}: {}'.format(self.name, str(e)))
                    continue
                # output how long since the last message
                if self.last_message and self._reconnected:
                    log.info('{} resumes events after {} seconds.'.format(
                        self._label,
                        time.time() - self.last_message))
                self.last_message = time.time()
                self._reconnected = False
                # do not info on heartbeats
                if 'data' in publisher_event and 'device_info' not in publisher_event['data']:
                    log.debug('Received {} bytes from {}'.format(
                        len(publisher_data),
                        self._publisher_endpoint))
                self.processor.send_pyobj({self._label: publisher_event})
            except UnpackException:
                log.exception('Cannot unpack message from {}.'.format(self._label))
                continue
            except ContextTerminated:
                log.warning('ZMQ terminate: {}'.format(self.__class__.__name__))
                self.subscriber.close()
                log.warning('ZMQ terminated subscriber: {}'.format(self.__class__.__name__))
                self.processor.close()
                log.warning('ZMQ terminated: {}'.format(self.__class__.__name__))
                break
            except ZMQError:
                log.exception(self.name)
                break
            except Exception:
                log.exception(self.name)
                capture_exception()
                sleep(1)
                continue


class SQSListener(Thread):

    def __init__(self):
        super(SQSListener, self).__init__(name=self.__class__.__name__)
        self.daemon = True
        threads.threads_tracked.add(self.name)

        self.processor = zmq_socket(zmq.PUSH) # type: ignore
        self._sqs = None
        self._sqs_queue = None

    # noinspection PyBroadException
    def run(self):
        sqs_queue_name = os.environ['SQS_QUEUE']
        log.info('Listening for control messages on SQS queue {}'.format(sqs_queue_name))
        # set up notifications
        self._sqs = boto3.resource('sqs')
        self._sqs_queue = self._sqs.get_queue_by_name(QueueName=sqs_queue_name)
        self.processor.connect(URL_WORKER_APP)
        while True:
            try:
                for sqs_message in self._sqs_queue.receive_messages(WaitTimeSeconds=20):
                    # forward for further processing
                    message_body = sqs_message.body
                    try:
                        self.processor.send_pyobj({'sqs': json.loads(message_body)})
                    except JSONDecodeError:
                        log.exception('Unstructured SQS message: {}'.format(message_body))
                    # Let the queue know that the message is processed
                    sqs_message.delete()
                # test for ZMQ shutdown
                self.processor.poll(timeout=0)
                # test for application shutdown
                if threads.shutting_down:
                    log.warning('App terminate: {}'.format(self.__class__.__name__))
                    self.processor.close()
                    log.warning('App terminated: {}'.format(self.__class__.__name__))
                    break
            except (gaierror, bce, bccce, bcece) as e:
                log.warning(repr(e))
                sleep(1)
                continue
            except UnpackException:
                log.exception('Cannot unpack message from SQS queue {}.'.format(self._sqs_queue))
                continue
            except ContextTerminated:
                log.warning('ZMQ terminate: {}'.format(self.__class__.__name__))
                self.processor.close()
                log.warning('ZMQ terminated: {}'.format(self.__class__.__name__))
                break
            except ZMQError:
                log.exception(self.name)
                sleep(1)
                break
            except Exception:
                log.exception(self.name)
                capture_exception()
                sleep(1)
                continue


class AutoScheduler(Thread):

    def __init__(self):
        super(AutoScheduler, self).__init__(name=self.__class__.__name__)
        self.daemon = True
        threads.threads_tracked.add(self.name)

        self.processor = zmq_socket(zmq.PUSH) # type: ignore
        # IPC for publish
        self.socket = zmq_socket(zmq.PULL) # type: ignore
        self.socket.bind(URL_WORKER_AUTO_SCHEDULER)

    def update_device(self, device_key, device_state):
        log.info('Updating {} to enabled={}'.format(device_key, device_state))
        self.processor.send_pyobj({
            'auto-scheduler': {
                'device_key': device_key,
                'device_state': device_state
            }})

    def _schedule(self, device_key, schedule_time, device_state):
        schedule.every().day.at(schedule_time).do(self.update_device, device_key=device_key, device_state=device_state).tag(device_key)

    # noinspection PyBroadException
    def run(self):
        self.processor.connect(URL_WORKER_APP)
        while True:
            next_message = False
            try:
                # trigger any scheduled work
                schedule.run_pending()
                # look for device updates
                device_config = None
                try:
                    device_config = self.socket.recv_pyobj(flags=zmq.NOBLOCK) # type: ignore
                    next_message = True
                except ZMQError:
                    # ignore, no data
                    next_message = False
                if device_config:
                    devices = device_config
                    if isinstance(device_config, dict):
                        devices = list(device_config.items())
                    log.info('Reloading auto-schedule configuration for {} devices: {}'.format(len(devices), [device[0] for device in devices]))
                    for device_key, device_config in devices:
                        # clear any previous schedule
                        schedule.clear(device_key)
                        if 'auto_schedule' in device_config and (device_config['auto_schedule'] or device_config['auto_schedule'] == 1):
                            auto_enable_time = device_config['auto_schedule_enable']
                            auto_disable_time = device_config['auto_schedule_disable']
                            log.info('Setting auto-schedule for {} to disable at {} and enable at {}.'.format(
                                device_key,
                                auto_disable_time,
                                auto_enable_time))
                            # install a new scedule
                            self._schedule(
                                device_key=device_key,
                                schedule_time=auto_disable_time,
                                device_state=False)
                            self._schedule(
                                device_key=device_key,
                                schedule_time=auto_enable_time,
                                device_state=True)
                # test for application shutdown
                if threads.shutting_down:
                    log.warning('App terminate: {}'.format(self.__class__.__name__))
                    self.socket.close()
                    self.processor.close()
                    log.warning('App terminated: {}'.format(self.__class__.__name__))
                    break
            except ContextTerminated:
                log.warning('ZMQ terminate: {}'.format(self.__class__.__name__))
                self.socket.close()
                self.processor.close()
                log.warning('ZMQ terminated: {}'.format(self.__class__.__name__))
                break
            except ZMQError:
                log.exception(self.name)
                break
            except Exception:
                log.exception(self.name)
                capture_exception()
                sleep(1)
                continue
            # don't spin
            if not next_message:
                threads.interruptable_sleep.wait(10)


class OriginNanny(Thread):

    def __init__(self):
        super(OriginNanny, self).__init__(name=self.__class__.__name__)
        self.daemon = True
        threads.threads_tracked.add(self.name)

        self.processor = zmq_socket(zmq.PUSH) # type: ignore

        self.origin_subscriber = {}
        self._heartbeat_sample_interval = int(app_config.get('app', 'heartbeat_sample_interval_seconds'))
        self._heartbeat_report_interval = int(app_config.get('app', 'heartbeat_report_interval_seconds'))
        self._max_heartbeat_delay = int(app_config.get('app', 'max_heartbeat_delay_seconds'))
        self._heartbeats = {}

    # noinspection PyShadowingNames
    def add_origin_subscriber(self, origin, ip, subscriber):
        self.origin_subscriber[origin] = (ip, subscriber)

    def run(self):
        self.processor.connect(URL_WORKER_APP)
        # warm-up to wait for first volley of heartbeats
        threads.interruptable_sleep.wait(self._heartbeat_sample_interval)
        last_report = make_timestamp()
        heartbeat_due = False
        max_heartbeat = -1
        while True:
            if threads.shutting_down:
                log.warning('App terminate: {}'.format(self.__class__.__name__))
                self.processor.close()
                log.warning('App terminated: {}'.format(self.__class__.__name__))
                break
            try:
                # send out either a stale alert or the heartbeat
                now = make_timestamp()
                if now - last_report > timedelta(seconds=self._heartbeat_report_interval):
                    last_report = now
                    heartbeat_due = True
                    max_heartbeat = -1
                payload = {}
                for origin, (_, origin_subscriber) in list(self.origin_subscriber.items()):
                    if origin not in self._heartbeats:
                        self._heartbeats[origin] = []
                    # when last was an event seen by this subscriber
                    last_message = origin_subscriber.last_message
                    heartbeat_age = None
                    if last_message:
                        heartbeat_age = time.time() - origin_subscriber.last_message
                    if last_message is None or heartbeat_age > self._max_heartbeat_delay:
                        device_status = None
                        if last_message:
                            last_message = datetime.utcfromtimestamp(last_message).replace(tzinfo=pytz.utc).strftime(ISO_DATE_FORMAT)
                        else:
                            last_message = "never"
                        log_message = "'{}' last activity was {}.".format(origin, last_message)
                        if device_status:
                            log.debug("{} Device is {}.".format(log_message, device_status))
                        else:
                            log.debug(log_message)
                        # used as an out-of-band trigger for something amiss
                        payload['stale_heartbeat'] = last_message
                        if device_status:
                            payload['device_status'] = device_status
                    # do this for each device irrespective of stale or not
                    origin_heartbeat = self._heartbeats[origin]
                    if heartbeat_age:
                        origin_heartbeat.append(heartbeat_age)
                    # send out either a stale alert or the heartbeat
                    if heartbeat_due:
                        if len(payload) > 0 or len(origin_heartbeat) > 0:
                            # add in the maximum heartbeat observed
                            if len(origin_heartbeat) > 0:
                                log.debug("Aggregating {} heartbeats captured from {}.".format(len(origin_heartbeat), origin))
                                device_max_heartbeat = 0
                                for heartbeat in origin_heartbeat:
                                    if heartbeat > max_heartbeat:
                                        max_heartbeat = heartbeat
                                    if heartbeat > device_max_heartbeat:
                                        device_max_heartbeat = heartbeat
                                origin_heartbeat.clear()
                                payload['heartbeat_age'] = device_max_heartbeat
                                self.processor.send_pyobj({origin: {'data': payload}})
                # send the maximum heartbeat
                if heartbeat_due and max_heartbeat >= 0:
                    self.processor.send_pyobj({
                        device_name: {
                            'data': {
                                'max_heartbeat_age': max_heartbeat
                            }
                        }
                    })
                    heartbeat_due = False
                    max_heartbeat = -1
                # test for ZMQ shutdown
                self.processor.poll(timeout=0)
            except ContextTerminated:
                log.warning('ZMQ terminate: {}'.format(self.__class__.__name__))
                self.processor.close()
                log.warning('ZMQ terminated: {}'.format(self.__class__.__name__))
                break
            threads.interruptable_sleep.wait(self._heartbeat_sample_interval)


class EventSourceDiscovery(Thread):
    def __init__(self, boto_session, swf_region, swf_domain):
        super(EventSourceDiscovery, self).__init__(name=self.__class__.__name__)
        self.daemon = True
        threads.threads_tracked.add(self.name)

        self.processor = zmq_socket(zmq.PUSH) # type: ignore

        self._boto_session = boto_session
        self._swf_region = swf_region
        self._swf_domain = swf_domain

        self._mdash_api_key = creds.mdash_api_key
        self._mdash_devices_url = app_config.get('mdash', 'base_url')
        self._app_config_mqtt_pub_topic = app_config.get('mdash', 'app_config_mqtt_pub_topic')

    def run(self):
        self.processor.connect(URL_WORKER_APP)
        # register ZMQ sources
        try:
            # start with static sources
            subscription_sources = app_config.get('app', 'subscription_sources')
            if len(subscription_sources) > 0:
                for source in app_config.get('app', 'subscription_sources').split(','):
                    label_ip = source.split(':')
                    source_label = label_ip[0]
                    source_ip = label_ip[1]
                    self.processor.send_pyobj({'register_origin': {source_label: source_ip}})
        except ContextTerminated:
            self.processor.close()
            log.warning('ZMQ terminated: {}'.format(self.__class__.__name__))
            return
        except ZMQError:
            log.exception(self.name)
            return
        # register SWF actions
        sources_to_register = (
            app_config.get('swf_tasklist', OUTPUT_TYPE_BLUETOOTH),
            app_config.get('swf_tasklist', OUTPUT_TYPE_SWITCH),
            app_config.get('swf_tasklist', OUTPUT_TYPE_SNAPSHOT),
            app_config.get('swf_tasklist', OUTPUT_TYPE_TTS))
        while not threads.shutting_down:
            try:
                outstanding_registrations = set(sources_to_register) - event_processor.origins
                for source_to_register in outstanding_registrations:
                     # type: ignore
                    workflow_instance = None
                    # determine IPs of available devices for ZMQ subscriptions
                    with workflow_starter(self._boto_session,
                                        self._swf_region,
                                        self._swf_domain,
                                        app_name) as starter:
                        workflow_instance = DeviceWorkflow.execute(app=source_to_register) # pylint: disable=no-value-for-parameter
                        log.debug("Registration workflow for {} is {}".format(
                            source_to_register,
                            workflow_instance.workflow_execution))
                    SWFActivityWaiter(
                        zmq_ipc_url=URL_WORKER_APP,
                        event_source='register_origin',
                        output_type=source_to_register,
                        workflow_starter=starter,
                        workflow_instance=workflow_instance).start()
                # try get more in a minute
                threads.interruptable_sleep.wait(60)
                outstanding_registrations = set(sources_to_register) - event_processor.origins
                if not outstanding_registrations:
                    log.info('All event sources {} have been discovered and registered.'.format(
                        event_processor.origins))
                    break
                else:
                    log.warning('Waiting to retry on incomplete source registration: {}'.format(outstanding_registrations))
            except Exception:
                log.exception(self.name)
                capture_exception()
                threads.interruptable_sleep.wait(10)
                continue
        # register MQTT inputs
        while not threads.shutting_down:
            mdash_devices = None
            log.info('Requesting mDash device listing from {}'.format(self._mdash_devices_url))
            try:
                # get listing of all applications
                mdash_devices = requests.get(
                    url=self._mdash_devices_url,
                    params={
                        "access_token": self._mdash_api_key
                    }).json()
            except Exception:
                log.exception(self.__class__.__name__)
                capture_exception()
                threads.interruptable_sleep.wait(10)
                continue
            log.info('mDash returns {} devices.'.format(len(mdash_devices)))
            for device in mdash_devices:
                device_id = device['id']
                log.info('Retrieving mDash information for device {}'.format(device_id))
                try:
                    # retrieve specific configuration item
                    mqtt_pub_topic = requests.post(
                        url='{}/{}/rpc/Config.Get'.format(
                            self._mdash_devices_url,
                            device_id),
                        json={
                            'key': self._app_config_mqtt_pub_topic
                        },
                        params={
                            "access_token": self._mdash_api_key
                        })
                    log.info('MQTT topic for {} is {}'.format(device_id, mqtt_pub_topic.text))
                    self.processor.send_pyobj({'register_mqtt_origin': {mqtt_pub_topic.text: device_id}})
                except ContextTerminated:
                    self.processor.close()
                    log.warning('ZMQ terminated: {}'.format(self.__class__.__name__))
                    return
                except ZMQError:
                    log.exception(self.name)
                    return
                except Exception:
                    log.exception(self.__class__.__name__)
                    capture_exception()
                    threads.interruptable_sleep.wait(10)
                    continue
            # important to stop
            break

        # close the IPC socket
        self.processor.close()
        # un-nanny and goodbye
        threads.threads_tracked.remove(self.getName())


class CallbackUrlDiscovery(Thread):

    def __init__(self):
        super(CallbackUrlDiscovery, self).__init__(name=self.__class__.__name__)
        self.daemon = True

        self._discover_url = 'http://127.0.0.1:{}/api/tunnels/{}'.format(
            app_config.get('ngrok', 'client_api_port'),
            app_config.get('ngrok', 'tunnel_name'))

    # noinspection PyBroadException
    def run(self):
        while True:
            try:
                # sudo update
                global ngrok_tunnel_url
                try:
                    ngrok_tunnel_url = requests.get(self._discover_url).json()['public_url']
                except (KeyError, ConnectionError) as e:
                    log.warning('Still attempting to discover ngrok tunnel URL ({})...'.format(repr(e)))
                    threads.interruptable_sleep.wait(10)
                    continue
                log.info('External call-back URL is {}'.format(ngrok_tunnel_url))
                break
            except Exception:
                log.exception(self.__class__.__name__)
                capture_exception()
                sleep(1)
        try:
            purl = urlparse(ngrok_tunnel_url)
            # decorate the URL with basic-auth details
            global ngrok_tunnel_url_with_bauth
            ngrok_tunnel_url_with_bauth = '{}://{}:{}@{}{}'.format(purl.scheme,
                                                                   creds.flask_basic_auth_username,
                                                                   creds.flask_basic_auth_password,
                                                                   purl.netloc,
                                                                   purl.path)
        except Exception:
            log.exception(self.__class__.__name__)
            capture_exception()


class FlaskThread(Thread):

    def __init__(self, app, compress):
        super(FlaskThread, self).__init__(name=self.__class__.__name__)
        # start frontend
        app.secret_key = creds.flask_secret_key
        app.jinja_env.add_extension('jinja2.ext.loopcontrols')
        app.jinja_env.filters.update({
            'is_list': is_list,
        })
        # enable compression
        compress.init_app(app)
        #TODO: how to enable debug mode
        self.srv = make_server(host='0.0.0.0',
                               port=int(app_config.get('flask', 'http_port')),
                               app=app,
                               threaded=True)
        self.ctx = app.app_context()
        self.ctx.push()

    def run(self):
        self.srv.serve_forever()

    def shutdown(self):
        log.warning('Flask server shutting down: {}'.format(self.__class__.__name__))
        self.srv.shutdown()
        log.warning('Flask server shutdown complete: {}'.format(self.__class__.__name__))


if __name__ == "__main__":
    log.setLevel(logging.INFO)
    # determine leadership
    leader_election = Leader()
    leader_election.yield_to_leader()
    # get ngrok going
    exec_cmd_log(['sudo', 'systemctl', 'enable', 'ngrok'])
    exec_cmd_log(['sudo', 'systemctl', 'start', 'ngrok'])
    # elected leader, now stay leader
    leader_election.start()
    # connect to SWF
    swf_decider = ThreadedWorkflowExecutor(WorkflowWorker(boto_session,
                                             swf_region,
                                             swf_domain,
                                             app_name,
                                             HelloWorldWorkflow,
                                             DeviceWorkflow,
                                             BluetoothWorkflow,
                                             TTSWorkflow,
                                             IOBoardWorkflow,
                                             SnapshotWorkflow,
                                             ImageProcessWorkflow))
    swf_decider._worker.unhandled_exception_handler = swf_exception_handler
    swf_decider.start()
    # activities run on devices hosting this application
    swf_worker = ThreadedActivityExecutor(ActivityWorker(boto_session,
                                            swf_region,
                                            swf_domain,
                                            app_name,
                                            HelloWorldActivities()))
    swf_worker._worker.unhandled_exception_handler = swf_exception_handler
    swf_worker.start()
    # bind listeners first
    event_logger = EventLog()
    origin_nanny = OriginNanny()
    mqtt_subscriber = MqttSubscriber()
    auto_scheduler = AutoScheduler()
    event_processor = EventProcessor(origin_nanny, boto_session, swf_region, swf_domain, mqtt_subscriber)
    # connect ZMQ IPC clients next
    event_source_discovery = EventSourceDiscovery(boto_session, swf_region, swf_domain)
    sqs_listener = SQSListener()
    telegram_bot = TBot()
    # start the binders
    event_logger.start()
    event_processor.start()
    # start the connectors
    origin_nanny.start()
    event_source_discovery.start()
    mqtt_subscriber.start()
    auto_scheduler.start()
    sqs_listener.start()
    telegram_bot.start()
    # start Telegram integration
    telegram_updater = TelegramUpdater(token=creds.telegram_bot_api_token, use_context=True)
    telegram_dispatcher = telegram_updater.dispatcher
    telegram_dispatcher.add_handler(TelegramCommandHandler('start',
                                                           telegram_bot_cmd,
                                                           pass_args=True))
    telegram_dispatcher.add_handler(TelegramCommandHandler('report',
                                                           telegram_bot_cmd,
                                                           pass_args=True))
    telegram_dispatcher.add_handler(TelegramInlineHandler(telegram_bot_inline))
    telegram_dispatcher.add_handler(TelegramMessageHandler(TelegramFilters.text,
                                                            telegram_bot_echo))
    telegram_dispatcher.add_error_handler(telegram_error_handler)
    telegram_updater.start_polling()
    # must be main thread
    signal_handler = SignalHandler()
    # start the nanny
    f = threading.Thread(name='nanny', target=thread_nanny, args=(signal_handler,))
    f.setDaemon(True)
    f.start()
    # not tracked by nanny because this is used for Flask bootstrap
    server = FlaskThread(app=flask_app, compress=Compress())
    server.start()
    try:
        # startup completed
        # back to INFO logging
        log.setLevel(logging.INFO)
        # discover callback URL
        CallbackUrlDiscovery().start()
        # hang around until something goes wrong
        threads.interruptable_sleep.wait()
        raise RuntimeWarning("Shutting down...")
    except(KeyboardInterrupt, RuntimeWarning, ContextTerminated) as e:
        log.warning(str(e))
        threads.shutting_down = True
        threads.interruptable_sleep.set()
        message = "Shutting down {}..."
        log.info(message.format('SWF workflow worker'))
        swf_decider.stop()
        log.info(message.format('SWF activity worker'))
        swf_worker.stop()
        log.info(message.format('Web server'))
        server.shutdown()
        log.info(message.format('Telegram bot'))
        telegram_updater.stop()
        log.info(message.format('Application threads'))
        # bring any threads out of their Pythonic coma
        threads.interruptable_sleep.set()
        zmq_term()
        log.info(message.format('leader election.'))
        leader_election.surrender_leadership()
        log.info(message.format('ngrok tunnel'))
        exec_cmd_log(['sudo', 'systemctl', 'stop', 'ngrok'])
        log.info('Shutdown complete.')