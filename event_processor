#!/usr/bin/python
import dateutil.parser
import hashlib
import logging
import logging.handlers

import abc
import os
import pytz
import signal
import sys
import threading
import time
import umsgpack
import zmq

from boto import dynamodb2
from boto.dynamodb2.table import Table
from boto.ec2 import cloudwatch
from ConfigParser import ConfigParser
from datetime import datetime, timedelta
from dateutil import tz
from pprint import pprint
from sets import Set
from Queue import Queue, Empty
from threading import Thread, Timer
from time import sleep
from umsgpack import UnpackException
from zmq import ContextTerminated
from flask import Flask, flash, request, render_template, url_for, redirect, session, escape

# unbuffered STDOUT for print
sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)
sys.displayhook = pprint

APP = os.path.basename(__file__)
DIR = os.path.abspath(os.path.dirname(__file__))
# set the working directory for libraries that assume this (such as PyDrive)
os.chdir(DIR)
log = logging.getLogger(APP)
# do not propagate to console logging
log.propagate = False

config = ConfigParser()
config.optionxform = str
config.read([os.path.join(DIR, '{}.conf'.format(APP))])

rest_api = Flask(APP)

URL_WORKER_EVENT_PROCESSOR = 'inproc://event-processor'
zmq_context = zmq.Context()

event_processor = None


def signal_handler(signum, frame):
    log.warn('Signal {} received.'.format(signum))
    log.setLevel(logging.DEBUG)


@rest_api.route('/logging')
def debug():
    log.setLevel(request.args.get('level'))
    return 'OK'


@rest_api.route('/relay_ctrl_toggle', methods=['GET', 'POST'])
def relay_ctrl_toggle():
    #if SnapshotProcessor._relay_ctrl:
    #    SnapshotProcessor._relay_ctrl = False
    #else:
    #    SnapshotProcessor._relay_ctrl = True
    return redirect(url_for('index'))

@rest_api.route('/notification_toggle', methods=['GET', 'POST'])
def notification_toggle():
    #if SnapshotProcessor._notification_ctrl:
    #    SnapshotProcessor._notification_ctrl = False
    #else:
    #    SnapshotProcessor._notification_ctrl = True
    return redirect(url_for('index'))


@rest_api.route('/', methods=['GET', 'POST'])
def index():
    relays = 'Beep Beeps {}'
    #if SnapshotProcessor._relay_ctrl:
    #    relays = relays.format('ON')
    #else:
    #    relays = relays.format('OFF')
    notifications = 'Crazy Lady {}'
    #if SnapshotProcessor._notification_ctrl:
    #    notifications = notifications.format('ON')
    #else:
    #    notifications = notifications.format('OFF')
    return render_template('index.html', relays=relays, notifications=notifications)


@rest_api.route('/input_config', methods=['GET', 'POST'])
def input_config():
    if request.method == 'POST':
        flash(request.form)
    return render_template('input_config.html',
                           inputs=event_processor.inputs,
                           default_trigger_count=1,
                           default_triggers_per_internal=5,
                           default_debounce_seconds=60)


@rest_api.route('/input_link', methods=['GET', 'POST'])
def input_link():
    if request.method == 'POST':
        flash(request.form)
    return render_template('input_link.html',
                           inputs=event_processor.inputs,
                           outputs=event_processor.outputs)


@rest_api.route('/input_output', methods=['GET', 'POST'])
def input_output():
    if request.method == 'POST':
        input_device = None
        for input_device_key in event_processor.inputs:
            if input_device_key in request.form:
                input_device = input_device_key
                break
        saved = False
        if input_device is not None:
            saved = event_processor.device_config.put_item(
                data={
                    'input_device': input_device,
                    'output_device': request.form[input_device],
                    'output_params': request.form['output_params'].strip(),
                    'output_enabled': 'output_enabled' in request.form
                },
                overwrite=True)
        flash('Saved? {}'.format(saved))
    return render_template('input_output.html',
                           inputs=event_processor.inputs,
                           outputs=event_processor.outputs)


@rest_api.route('/config', methods=['GET', 'POST'])
def show_config():
    return render_template('config.html',
                           inputs=event_processor.inputs,
                           outputs=event_processor.outputs)


def thread_nanny(threads_tracked):
    while True:
        # TODO: check on overdue heartbeats?
        threads_alive = Set()
        for thread_info in threading.enumerate():
            if thread_info.isAlive():
                threads_alive.add(thread_info.getName())
        if len(threads_tracked - threads_alive) > 0:
            message = 'A thread has died. Expected threads are [{}], missing is [{}].'.format(threads_tracked, threads_tracked - threads_alive)
            log.error(message)
        time.sleep(10)


class ZMQEndpoint(object):
    __metaclass__ = abc.ABCMeta

    def __init__(self, zmq_sockets):
        self._zmq_sockets = zmq_sockets

    def close(self):
        for socket in self._zmq_sockets:
            socket.close()


class EventProcessor(Thread, ZMQEndpoint):

    def __init__(self):
        super(EventProcessor, self).__init__()
        self.name = self.__class__.__name__
        self.daemon = True

        self.inputs = dict()
        self.outputs = dict()

        self._input_origin = dict()
        self._output_origin = dict()

        self._db_storage = None
        self.device_config = None
        self._metrics = None

        self.socket = zmq_context.socket(zmq.PULL)
        self.socket.bind(URL_WORKER_EVENT_PROCESSOR)
        ZMQEndpoint.__init__(self, zmq_sockets=[self.socket])

    def _update_devices(self, device_origin, device_info):
        for input_outputs, origin, io in [(self.inputs, self._input_origin, 'inputs'),
                                          (self.outputs, self._output_origin, 'outputs')]:
            for device in device_info[io]:
                identifier = None
                try:
                    device_name = device['name']
                    identifier = device_name
                except KeyError:
                    device_name = None
                try:
                    device_type = device['type']
                    identifier = device_type
                except KeyError:
                    device_type = None
                try:
                    device_location = device['location']
                    identifier = device_location
                except KeyError:
                    device_location = None
                if identifier is None:
                    log.error("No distinct device identifier for '{}' and is ignored.".format(device))
                    continue
                # construct the friendly name for this device
                device_key = device_type
                if device_name is not None:
                    if device_location is not None:
                        device_key = '{} {} ({})'.format(device_name, device_type, device_location)
                    else:
                        device_key = '{} {}'.format(device_name, device_type)
                elif device_location is not None:
                    device_key = '{} {}'.format(device_location, device_type)
                # has this device been seen?
                if device_key not in origin:
                    origin[device_key] = device_origin
                elif origin[device_key] != device_origin:
                    log.error("Device with key '{}' is already present at '{}' "
                              "but is also present at '{}' and is ignored.".format(device_key,
                                                                                   origin[device_key],
                                                                                   device_origin))
                    continue
                if device_key not in input_outputs:
                    input_outputs[device_key] = device

    def post_metric(self, name, value, timestamp=None, unit='Count'):
        scalar = None
        if isinstance(value, list):
            scalar = len(value)
        elif isinstance(value, int):
            scalar = value
        else:
            raise RuntimeError('Unable to determine scalar value from {}'.format(value))
        if timestamp is None:
            timestamp = datetime.utcfromtimestamp(time.time()).replace(tzinfo=pytz.utc)
        log.debug("Posting '{}' of '{}' for '{}' at {}".format(unit,
                                                               scalar,
                                                               self.metric_namespace,
                                                               timestamp.isoformat()))
        self._metrics.put_metric_data(namespace=self.metric_namespace,
                                     name=name,
                                     value=scalar,
                                     timestamp=timestamp,
                                     unit=unit)

    def run(self):
        # connect to AWS services
        self._db_storage = dynamodb2.connect_to_region(
            region_name=config.get('aws', 'region'),
            aws_access_key_id=config.get('aws', 'aws_access_key_id'),
            aws_secret_access_key=config.get('aws', 'aws_secret_access_key'))
        # set up metrics
        self._metrics = cloudwatch.connect_to_region(
            region_name=config.get('aws', 'region'),
            aws_access_key_id=config.get('aws', 'aws_access_key_id'),
            aws_secret_access_key=config.get('aws', 'aws_secret_access_key'))
        self.metric_namespace = '{}:{}'.format(config.get('metric', 'namespace'), APP)
        # set up configuration table
        self.device_config = Table(
            table_name=config.get('config', 'table_name'),
            connection=self._db_storage)

        while True:
            try:
                event = self.socket.recv_pyobj()
                log.debug(event)
                if isinstance(event, dict):
                    for origin, data in event.items():
                        if 'data' in data and 'device_info' in data['data']:
                            self._update_devices(device_origin=origin, device_info=data['data']['device_info'])
            except ContextTerminated:
                break
            except Exception:
                log.exception(self.__class__.__name__)
                continue


class SourceSubscriber(Thread, ZMQEndpoint):

    def __init__(self, label, publisher_endpoint):
        super(SourceSubscriber, self).__init__()
        self.name = '{}::{}'.format(self.__class__.__name__, label)
        self.daemon = True

        self._label = label
        self._publisher_endpoint = publisher_endpoint

        self.subscriber = zmq_context.socket(zmq.SUB)
        self.processor = zmq_context.socket(zmq.PUSH)
        ZMQEndpoint.__init__(self, zmq_sockets=[self.subscriber, self.processor])

    def run(self):
        log.info('Connecting event processor to {} @ {}'.format(self._label, self._publisher_endpoint))
        self.subscriber.connect(self._publisher_endpoint)
        self.subscriber.setsockopt(zmq.SUBSCRIBE, "")
        self.processor.connect(URL_WORKER_EVENT_PROCESSOR)
        while True:
            try:
                publisher_event = umsgpack.unpackb(self.subscriber.recv())
            except UnpackException:
                log.exception('Cannot unpack message from {}.'.format(self._label))
                continue
            except ContextTerminated:
                break
            self.processor.send_pyobj({self._label: publisher_event})


if __name__ == "__main__":
    # DEBUG logging until startup complete
    log.setLevel(logging.DEBUG)
    syslog_handler = logging.handlers.SysLogHandler(address='/dev/log')
    formatter = logging.Formatter('%(name)s [%(levelname)s] %(message)s')
    syslog_handler.setFormatter(formatter)
    log.addHandler(syslog_handler)
    if sys.stdout.isatty():
        log.warn("Using console logging because there is a tty.")
        stream_handler = logging.StreamHandler(stream=sys.stdout)
        stream_handler.setFormatter(formatter)
        log.addHandler(stream_handler)
    threads_tracked = Set()
    # bind main processor first
    event_processor = EventProcessor()
    event_processor.start()
    threads_tracked.add(event_processor.getName())
    # set up subscribers
    pubsub_port = config.get('zmq', 'pubsub_port')
    subscription_sources = config.get('app', 'subscription_sources').split(',')
    log.debug('Subscribing to these sources: {}'.format(subscription_sources))
    for source in subscription_sources:
        label_ip = source.split(':')
        source_label = label_ip[0]
        source_ip = label_ip[1]
        connection_string = 'tcp://{}:{}'.format(source_ip, pubsub_port)
        subscriber = SourceSubscriber(label=source_label, publisher_endpoint=connection_string)
        threads_tracked.add(subscriber.getName())
        subscriber.start()
    # set up signal handlers
    signal.signal(signal.SIGHUP, signal_handler)
    # start threads
    f = threading.Thread(name='nanny', target=thread_nanny, args=(threads_tracked,))
    f.setDaemon(True)
    f.start()
    try:
        # startup completed
        # back to INFO logging
        log.setLevel(logging.INFO)
        rest_api.secret_key = config.get('flask', 'session_secret_key')
        rest_api.jinja_env.add_extension('jinja2.ext.loopcontrols')
        rest_api.run(
            host=config.get('app', 'eth0_ip'),
            port=int(config.get('flask', 'http_port')),
            debug=config.get('flask', 'debug').lower() == 'true')
    except(KeyboardInterrupt, SystemExit):
        for thread_info in threading.enumerate():
            if thread_info.isAlive() and isinstance(thread_info, ZMQEndpoint):
                log.info("Closing sockets for '{}'".format(thread_info.getName()))
                thread_info.close()
        log.info('Closing messaging...')
        zmq_context.term()
