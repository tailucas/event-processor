#!/usr/bin/python
import dateutil.parser
import hashlib
import logging
import logging.handlers

import abc
import copy
import os
import pytz
import signal
import sys
import threading
import time
import umsgpack
import zmq

from boto import dynamodb2
from boto.dynamodb2.table import Table
from boto.dynamodb2.exceptions import ItemNotFound, JSONResponseError, DynamoDBError
from boto.ec2 import cloudwatch
from ConfigParser import ConfigParser
from datetime import datetime, timedelta
from dateutil import tz
from pprint import pprint
from sets import Set
from Queue import Queue, Empty
from threading import Thread, Timer
from time import sleep
from umsgpack import UnpackException
from zmq import ContextTerminated
from flask import Flask, flash, request, render_template, url_for, redirect, session, escape

# unbuffered STDOUT for print
sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)
sys.displayhook = pprint

APP = os.path.basename(__file__)
DIR = os.path.abspath(os.path.dirname(__file__))
# set the working directory for libraries that assume this (such as PyDrive)
os.chdir(DIR)
log = logging.getLogger(APP)
# do not propagate to console logging
log.propagate = False

config = ConfigParser()
config.optionxform = str
config.read([os.path.join(DIR, '{}.conf'.format(APP))])

rest_api = Flask(APP)

URL_WORKER_EVENT_PROCESSOR = 'inproc://event-processor'
zmq_context = zmq.Context()

event_processor = None


def signal_handler(signum, frame):
    log.warn('Signal {} received.'.format(signum))
    log.setLevel(logging.DEBUG)


def is_list(value):
    return isinstance(value, list)


@rest_api.route('/logging')
def debug():
    log.setLevel(request.args.get('level'))
    return 'OK'


@rest_api.route('/', methods=['GET', 'POST'])
def index():
    return render_template('index.html',
                           inputs=event_processor.input_config)


@rest_api.route('/config', methods=['GET', 'POST'])
def show_config():
    return render_template('config.html')


@rest_api.route('/input_config', methods=['GET', 'POST'])
def input_config():
    if request.method == 'POST':
        device_key = request.form['device_key']
        try:
            customized = False
            to_save = dict()
            group_name = request.form['group_name'].strip()
            if len(group_name) > 0:
                to_save['group_name'] = group_name
                customized = True
            else:
                to_save['group_name'] = None
            if len(request.form['activations_per_trigger']) > 0:
                to_save['activations_per_trigger'] = int(request.form['activations_per_trigger'])
                customized = True
            else:
                to_save['activations_per_trigger'] = None
            if len(request.form['activation_interval']) > 0:
                to_save['activation_interval'] = int(request.form['activation_interval'])
                customized = True
            else:
                to_save['activation_interval'] = None
            if len(request.form['trigger_window']) > 0:
                to_save['trigger_window'] = int(request.form['trigger_window'])
                customized = True
            else:
                to_save['trigger_window'] = None
            to_save['customized'] = customized
            event_processor.input_config = (
                device_key,
                to_save
            )
        except ValueError as e:
            message = "Cannot update '{}'".format(event_processor.input_config[device_key]['device_label'])
            flash(message='{}: {}'.format(message, e.message), category='danger')
    return render_template('input_config.html',
                           inputs=event_processor.input_config,
                           default_activations_per_trigger=int(config.get('config', 'default_activations_per_trigger')),
                           default_trigger_window=int(config.get('config', 'default_trigger_window')),
                           default_activation_interval=int(config.get('config', 'default_activation_interval')))


@rest_api.route('/input_link', methods=['GET', 'POST'])
def input_link():
    if request.method == 'POST':
        event_processor.input_config = (
            request.form['device_key'],
            {'linked_inputs': request.form.getlist('linked_input')}
        )
    return render_template('input_link.html',
                           inputs=event_processor.input_config)


@rest_api.route('/output_link', methods=['GET', 'POST'])
def output_link():
    if request.method == 'POST':
        event_processor.input_config = (
            request.form['device_key'],
            {'linked_outputs': request.form.getlist('linked_output')}
        )
    return render_template('output_link.html',
                           inputs=event_processor.input_config,
                           outputs=event_processor.outputs)


@rest_api.route('/output_config', methods=['GET', 'POST'])
def output_config():
    if request.method == 'POST':
        to_save = dict()
        device_params = request.form['device_params'].strip()
        if len(device_params) > 0:
            to_save['device_params'] = device_params
        else:
            to_save['device_params'] = None
        event_processor.output_config = (
            request.form['device_key'],
            to_save
        )
    return render_template('output_config.html',
                           outputs=event_processor.output_config)


def thread_nanny(threads_tracked):
    while True:
        # TODO: check on overdue heartbeats?
        threads_alive = Set()
        for thread_info in threading.enumerate():
            if thread_info.isAlive():
                threads_alive.add(thread_info.getName())
        if len(threads_tracked - threads_alive) > 0:
            message = 'A thread has died. Expected threads are [{}], missing is [{}].'.format(threads_tracked, threads_tracked - threads_alive)
            log.error(message)
        time.sleep(10)


class ZMQEndpoint(object):
    __metaclass__ = abc.ABCMeta

    def __init__(self, zmq_sockets):
        self._zmq_sockets = zmq_sockets

    def close(self):
        for socket in self._zmq_sockets:
            socket.close()


class EventProcessor(Thread, ZMQEndpoint):

    def __init__(self):
        super(EventProcessor, self).__init__()
        self.name = self.__class__.__name__
        self.daemon = True

        self.inputs = dict()
        self.outputs = dict()

        self._input_origin = dict()
        self._output_origin = dict()

        self._db_storage = None

        self._general_config = None
        self._general_config_table = None

        self._input_config = None
        self._input_config_table = None

        self._output_config = None
        self._output_config_table = None

        self._metrics = None

        self.socket = zmq_context.socket(zmq.PULL)
        self.socket.bind(URL_WORKER_EVENT_PROCESSOR)
        ZMQEndpoint.__init__(self, zmq_sockets=[self.socket])

    @property
    def general_config(self):
        return self._general_config

    @general_config.setter
    def general_config(self, config_update):
        config_key, updated_config = config_update
        self._general_config = dict()

    @property
    def input_config(self):
        devices = copy.deepcopy(self.inputs)
        devices_config = self._input_config
        for device_key in devices.keys():
            if device_key in devices_config:
                devices[device_key].update(devices_config[device_key])
        return devices

    @input_config.setter
    def input_config(self, config_update):
        device_key, updated_config = config_update
        EventProcessor._update_config(
            device_key=device_key,
            devices=self.inputs,
            device_configs=self._input_config,
            updates=updated_config,
            table_member=self._input_config_table,
            primary_key={'device_key': device_key})

    @property
    def output_config(self):
        devices = copy.deepcopy(self.outputs)
        devices_config = self._output_config
        for device_key in devices.keys():
            if device_key in devices_config:
                devices[device_key].update(devices_config[device_key])
        return devices

    @output_config.setter
    def output_config(self, config_update):
        device_key, updated_config = config_update
        EventProcessor._update_config(
            device_key=device_key,
            devices=self.outputs,
            device_configs=self._output_config,
            updates=updated_config,
            table_member=self._output_config_table,
            primary_key={'device_key': device_key})

    @staticmethod
    def _update_config(device_key, devices, device_configs, updates, table_member, primary_key):
        device_label = devices[device_key]['device_label']
        device_config = dict()
        try:
            device_config = device_configs[device_key]
        except KeyError:
            device_configs[device_key] = device_config
        try:
            table_name = table_member.table_name
            log.info("Updating table '{}'...".format(table_name))
            try:
                table_item = table_member.get_item(**primary_key)
                for key, value in updates.items():
                    if value:
                        table_item[key] = value
                    elif key in table_item:
                        del table_item[key]
                saved = table_item.partial_save()
            except ItemNotFound:
                log.debug("Item '{}' not found in '{}'. Creating new.".format(primary_key, table_name))
                put_args = dict()
                put_args['data'] = dict()
                put_args['data'].update(primary_key)
                put_args['data'].update(updates)
                saved = table_member.put_item(**put_args)
            if saved:
                flash("Updated '{}'".format(device_label))
                for key, value in updates.items():
                    if value:
                        device_config[key] = value
                    elif key in device_config:
                        del device_config[key]
            else:
                flash("'{}' not updated.".format(device_label), category='warning')
        except Exception as e:
            message = "Cannot update '{}'".format(device_label)
            log.exception(message)
            flash(message='{}: {}'.format(message, e.message), category='danger')

    def _update_devices(self, device_origin, device_info):
        for input_outputs, origin, io in [(self.inputs, self._input_origin, 'inputs'),
                                          (self.outputs, self._output_origin, 'outputs')]:
            for device in device_info[io]:
                identifier = None
                try:
                    device_name = device['name']
                    identifier = device_name
                except KeyError:
                    device_name = None
                try:
                    device_type = device['type']
                    identifier = device_type
                except KeyError:
                    device_type = None
                try:
                    device_location = device['location']
                    identifier = device_location
                except KeyError:
                    device_location = None
                if identifier is None:
                    log.error("No distinct device identifier for '{}' and is ignored.".format(device))
                    continue
                # construct the device key and associated friendly name
                device_key = device_type
                device_label = device_key
                if device_name is not None:
                    device_label = '{} {}'.format(device_name, device_type)
                    if device_location is not None:
                        # friendly name includes location only if the name is missing
                        device_key = '{} {} ({})'.format(device_name, device_type, device_location)
                    else:
                        device_key = '{} {}'.format(device_name, device_type)
                        device_label = device_key
                elif device_location is not None:
                    device_key = '{} {}'.format(device_location, device_type)
                    device_label = device_key
                # add the friendly name
                device['device_label'] = device_label
                # has this device been seen?
                if device_key not in origin:
                    origin[device_key] = device_origin
                elif origin[device_key] != device_origin:
                    log.error("Device with key '{}' is already present at '{}' "
                              "but is also present at '{}' and is ignored.".format(device_key,
                                                                                   origin[device_key],
                                                                                   device_origin))
                    continue
                if device_key not in input_outputs:
                    input_outputs[device_key] = device

    def post_metric(self, name, value, timestamp=None, unit='Count'):
        scalar = None
        if isinstance(value, list):
            scalar = len(value)
        elif isinstance(value, int):
            scalar = value
        else:
            raise RuntimeError('Unable to determine scalar value from {}'.format(value))
        if timestamp is None:
            timestamp = datetime.utcfromtimestamp(time.time()).replace(tzinfo=pytz.utc)
        log.debug("Posting '{}' of '{}' for '{}' at {}".format(unit,
                                                               scalar,
                                                               self.metric_namespace,
                                                               timestamp.isoformat()))
        self._metrics.put_metric_data(namespace=self.metric_namespace,
                                     name=name,
                                     value=scalar,
                                     timestamp=timestamp,
                                     unit=unit)

    def __setup_config_table(self, table_name):
        log.info("Loading Dynamo table '{}'...".format(table_name))
        member_table = Table(
            table_name=table_name,
            connection=self._db_storage)
        log.info("Reading table '{}'...".format(table_name))
        member = dict()
        for result in member_table.scan():
            device_key = None
            member_config = dict()
            for key, value in result.items():
                if key == 'device_key':
                    device_key = value
                else:
                    member_config.update([(key, value)])
            if device_key and len(member_config) > 0:
                member[device_key] = member_config
        return member, member_table

    def run(self):
        # connect to AWS services
        self._db_storage = dynamodb2.connect_to_region(
            region_name=config.get('aws', 'region'),
            aws_access_key_id=config.get('aws', 'aws_access_key_id'),
            aws_secret_access_key=config.get('aws', 'aws_secret_access_key'))
        # set up metrics
        self._metrics = cloudwatch.connect_to_region(
            region_name=config.get('aws', 'region'),
            aws_access_key_id=config.get('aws', 'aws_access_key_id'),
            aws_secret_access_key=config.get('aws', 'aws_secret_access_key'))
        self.metric_namespace = '{}:{}'.format(config.get('metric', 'namespace'), APP)
        # load configuration data
        self._general_config, self._general_config_table = self.__setup_config_table(
            config.get('config', 'general_config_table'))
        self._input_config, self._input_config_table = self.__setup_config_table(
            config.get('config', 'input_config_table'))
        self._output_config, self._output_config_table = self.__setup_config_table(
            config.get('config', 'output_config_table'))

        while True:
            try:
                event = self.socket.recv_pyobj()
                log.debug(event)
                if isinstance(event, dict):
                    for origin, data in event.items():
                        if 'data' in data and 'device_info' in data['data']:
                            self._update_devices(device_origin=origin, device_info=data['data']['device_info'])
            except ContextTerminated:
                break
            except Exception:
                log.exception(self.__class__.__name__)
                continue


class SourceSubscriber(Thread, ZMQEndpoint):

    def __init__(self, label, publisher_endpoint):
        super(SourceSubscriber, self).__init__()
        self.name = '{}::{}'.format(self.__class__.__name__, label)
        self.daemon = True

        self._label = label
        self._publisher_endpoint = publisher_endpoint

        self.subscriber = zmq_context.socket(zmq.SUB)
        self.processor = zmq_context.socket(zmq.PUSH)
        ZMQEndpoint.__init__(self, zmq_sockets=[self.subscriber, self.processor])

    def run(self):
        log.info('Connecting event processor to {} @ {}'.format(self._label, self._publisher_endpoint))
        self.subscriber.connect(self._publisher_endpoint)
        self.subscriber.setsockopt(zmq.SUBSCRIBE, "")
        self.processor.connect(URL_WORKER_EVENT_PROCESSOR)
        while True:
            try:
                publisher_event = umsgpack.unpackb(self.subscriber.recv())
            except UnpackException:
                log.exception('Cannot unpack message from {}.'.format(self._label))
                continue
            except ContextTerminated:
                break
            self.processor.send_pyobj({self._label: publisher_event})


if __name__ == "__main__":
    # DEBUG logging until startup complete
    log.setLevel(logging.DEBUG)
    syslog_handler = logging.handlers.SysLogHandler(address='/dev/log')
    formatter = logging.Formatter('%(name)s [%(levelname)s] %(message)s')
    syslog_handler.setFormatter(formatter)
    log.addHandler(syslog_handler)
    if sys.stdout.isatty():
        log.warn("Using console logging because there is a tty.")
        stream_handler = logging.StreamHandler(stream=sys.stdout)
        stream_handler.setFormatter(formatter)
        log.addHandler(stream_handler)
    threads_tracked = Set()
    # bind main processor first
    event_processor = EventProcessor()
    event_processor.start()
    threads_tracked.add(event_processor.getName())
    # set up subscribers
    pubsub_port = config.get('zmq', 'pubsub_port')
    subscription_sources = config.get('app', 'subscription_sources').split(',')
    log.debug('Subscribing to these sources: {}'.format(subscription_sources))
    for source in subscription_sources:
        label_ip = source.split(':')
        source_label = label_ip[0]
        source_ip = label_ip[1]
        connection_string = 'tcp://{}:{}'.format(source_ip, pubsub_port)
        subscriber = SourceSubscriber(label=source_label, publisher_endpoint=connection_string)
        threads_tracked.add(subscriber.getName())
        subscriber.start()
    # set up signal handlers
    signal.signal(signal.SIGHUP, signal_handler)
    # start threads
    f = threading.Thread(name='nanny', target=thread_nanny, args=(threads_tracked,))
    f.setDaemon(True)
    f.start()
    try:
        # startup completed
        # back to INFO logging
        log.setLevel(logging.INFO)
        rest_api.secret_key = config.get('flask', 'session_secret_key')
        rest_api.jinja_env.add_extension('jinja2.ext.loopcontrols')
        rest_api.jinja_env.filters.update({
            'is_list': is_list,
        })
        rest_api.run(
            host=config.get('app', 'eth0_ip'),
            port=int(config.get('flask', 'http_port')),
            debug=config.get('flask', 'debug').lower() == 'true',
            use_reloader=False)
    except(KeyboardInterrupt, SystemExit):
        for thread_info in threading.enumerate():
            if thread_info.isAlive() and isinstance(thread_info, ZMQEndpoint):
                log.info("Closing sockets for '{}'".format(thread_info.getName()))
                thread_info.close()
        log.info('Closing messaging...')
        zmq_context.term()
