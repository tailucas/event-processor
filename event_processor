#!/usr/bin/python
import dateutil.parser
import hashlib
import logging
import logging.handlers

import os
import pytz
import signal
import sys
import threading
import time
import umsgpack
import zmq

from ConfigParser import ConfigParser

from datetime import datetime, timedelta
from dateutil import tz
from pprint import pprint
from sets import Set
from Queue import Queue, Empty
from threading import Thread, Timer
from time import sleep
from umsgpack import UnpackException
from zmq import ContextTerminated
from flask import Flask, request, render_template, url_for, redirect

# unbuffered STDOUT for print
sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)
sys.displayhook = pprint

APP = os.path.basename(__file__)
DIR = os.path.abspath(os.path.dirname(__file__))
# set the working directory for libraries that assume this (such as PyDrive)
os.chdir(DIR)
log = logging.getLogger(APP)
# do not propagate to console logging
log.propagate = False

config = ConfigParser()
config.optionxform = str
config.read([os.path.join(DIR, '{}.conf'.format(APP))])

rest_api = Flask(APP)
zmq_context = zmq.Context()


def signal_handler(signum, frame):
    log.warn('Signal {} received.'.format(signum))
    log.setLevel(logging.DEBUG)


@rest_api.route('/logging')
def debug():
    log.setLevel(request.args.get('level'))
    return 'OK'


@rest_api.route('/relay_ctrl_toggle', methods=['GET','POST'])
def relay_ctrl_toggle():
    #if SnapshotProcessor._relay_ctrl:
    #    SnapshotProcessor._relay_ctrl = False
    #else:
    #    SnapshotProcessor._relay_ctrl = True
    return redirect(url_for('index'))

@rest_api.route('/notification_toggle', methods=['GET','POST'])
def notification_toggle():
    #if SnapshotProcessor._notification_ctrl:
    #    SnapshotProcessor._notification_ctrl = False
    #else:
    #    SnapshotProcessor._notification_ctrl = True
    return redirect(url_for('index'))


@rest_api.route('/', methods=['GET','POST'])
def index():
    relays = 'Beep Beeps {}'
    #if SnapshotProcessor._relay_ctrl:
    #    relays = relays.format('ON')
    #else:
    #    relays = relays.format('OFF')
    notifications = 'Crazy Lady {}'
    #if SnapshotProcessor._notification_ctrl:
    #    notifications = notifications.format('ON')
    #else:
    #    notifications = notifications.format('OFF')
    return render_template('index.html', relays=relays, notifications=notifications)


def run_flask():
    rest_api.run(host=config.get('app', 'eth0_ip'), port=5000)


if __name__ == "__main__":
    # set up logging
    log.setLevel(logging.INFO)
    syslog_handler = logging.handlers.SysLogHandler(address='/dev/log')
    formatter = logging.Formatter('%(name)s [%(levelname)s] %(message)s')
    syslog_handler.setFormatter(formatter)
    log.addHandler(syslog_handler)
    if sys.stdout.isatty():
        log.warn("Using console logging because there is a tty.")
        stream_handler = logging.StreamHandler(stream=sys.stdout)
        stream_handler.setFormatter(formatter)
        log.addHandler(stream_handler)
    # set up config
    subscription_sources = config.get('app', 'subscription_sources').split(',')
    # set up signal handlers
    signal.signal(signal.SIGHUP, signal_handler)
    threads_tracked = Set()
    # start threads
    f = threading.Thread(name='flask', target=run_flask)
    f.setDaemon(True)
    f.start()
    threads_tracked.add(f.getName())
    try:
        log.info('Subscribing to these sources: {}'.format(subscription_sources))
        # connect to publishers
        while True:
            threads_alive = Set()
            for thread_info in threading.enumerate():
                if thread_info.isAlive():
                    threads_alive.add(thread_info.getName())
            if len(threads_tracked - threads_alive) > 0:
                message = 'A thread has died. Expected threads are [{}], missing is [{}].'.format(threads_tracked, threads_tracked - threads_alive)
                log.error(message)
                # bail out
                raise RuntimeError(message)
            # TODO: check on overdue heartbeats?
            time.sleep(60)
    except(KeyboardInterrupt, SystemExit):
        log.info('Stopping threads...')
        log.info('Closing subscribers...')
        zmq_context.term()
